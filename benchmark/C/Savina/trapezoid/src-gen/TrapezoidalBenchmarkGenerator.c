#define LOG_LEVEL 2
#include "ctarget.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor_threaded.c"
// Code generated by the Lingua Franca compiler from file:
// C:\Users\soyer\lingua-franca-master\git\lingua-franca\benchmark\C\Savina\trapezoid\TrapezoidalBenchmarkGenerator.lf
typedef struct WorkMessage {

  double l;
  double r;
  double h;
} WorkMessage;

//    void printBenchmarkInfo(char* benchmarkId) {
//        printf("Benchmark: %s\n", benchmarkId);
//    }
//        
//    void printSystemInfo() {
//            
//        printf("System information\n"); 
//        printf("O/S Name: ");
//            
//        #ifdef _WIN32
//        printf("Windows 32-bit");
//        #elif _WIN64
//        printf("Windows 64-bit");
//        #elif __APPLE__ || __MACH__
//        printf("Mac OSX");
//        #elif __linux__
//        printf("Linux");
//        #elif __FreeBSD__
//        printf("FreeBSD");
//        #elif __unix || __unix__
//        printf("Unix");
//        #else
//        printf("Other");
//        #endif
//            
//        printf("\n");
//    }
// =============== START reactor class Worker
// *********** From the preamble, verbatim:
#line 115 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
#include <math.h>

// the function to integrate
double fx(double x) {
    
    double a = sin(pow(x, 3.0) - 1);
    double b = x + 1;
    double c = a / b;
    double d = sqrt(1.0 + exp(sqrt(2 * x)));
    double r = c * d;
    return r;
}
    

// *********** End of preamble.
#line 129 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
typedef struct {
typedef struct {
    int bank_index;
    int instance;
    worker_inMaster_t* __inMaster;
    // width of -2 indicates that it is not a multiport.
    int __inMaster__width;
    // Default input (in case it does not get connected)
    worker_inMaster_t __default__inMaster;
    worker_outMaster_t __outMaster;
    int __outMaster__width;
    reaction_t ___reaction_0;
    trigger_t ___inMaster;
    reaction_t* ___inMaster_reactions[1];
} worker_self_t;
void workerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    worker_self_t* self = (worker_self_t*)instance_args;
    #pragma GCC diagnostic pop
    worker_inMaster_t* inMaster = self->__inMaster;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inMaster_width = self->__inMaster__width;
    #pragma GCC diagnostic pop
    worker_outMaster_t* outMaster = &self->__outMaster;
    double r = inMaster->value.r;
    double l = inMaster->value.l;
    double h = inMaster->value.h;
    int n = (int)( ((r - l) / h) );
    double accumArea = 0.0;
    
    int i = 0;
    while(i < n) {
        double lx = (i * h) + l;
        double rx = lx + h;
        
        double ly = fx(lx);
        double ry = fx(rx);
        
        double area = 0.5 * (ly + ry) * h;
        accumArea += area;
        
        i += 1;
    }
    
    SET(outMaster, accumArea);
        
}
worker_self_t* new_Worker() {
    worker_self_t* self = (worker_self_t*)calloc(1, sizeof(worker_self_t));
    // Set input by default to an always absent default input.
    self->__inMaster = &self->__default__inMaster;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = workerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___inMaster.last = NULL;
    self->___inMaster_reactions[0] = &self->___reaction_0;
    self->___inMaster.reactions = &self->___inMaster_reactions[0];
    self->___inMaster.number_of_reactions = 1;
    self->___inMaster.element_size = sizeof(WorkMessage);
    return self;
}
void delete_Worker(worker_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Worker

// =============== START reactor class BenchmarkRunner
// *********** From the preamble, verbatim:
#line 138 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
        
static double toMS(interval_t t) {
    return t / 1000000.0;
}

int comp (const void * elem1, const void * elem2) {
            int f = *((double*)elem1);
            int s = *((double*)elem2);
            if (f > s) return  1;
            if (f < s) return -1;
            return 0;
        }
        
        static double median(double* execTimes, int size) {
    if (size == 0) {
        return 0.0;
    }
    
    int middle = size / 2;
    if(size % 2 == 1) {
        return execTimes[middle];
    } else {
        return (execTimes[middle-1] + execTimes[middle]) / 2;
    }
}

static double* getMSMeasurements(interval_t* measured_times, int numIterations) {
    
    double* msMeasurements = calloc(numIterations, sizeof(double));
    for (int i = 0; i < numIterations; i++) {
        msMeasurements[i] = toMS(measured_times[i]);
    }
    
    return msMeasurements;
}
    

// *********** End of preamble.
// *********** From the preamble, verbatim:
#line 176 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
        
void printBenchmarkInfo(char* benchmarkId) {
    printf("Benchmark: %s\n", benchmarkId);
}

void printSystemInfo() {
    
    printf("System information\n"); 
    printf("O/S Name: ");
    
    #ifdef _WIN32
    printf("Windows 32-bit");
    #elif _WIN64
    printf("Windows 64-bit");
    #elif __APPLE__ || __MACH__
    printf("Mac OSX");
    #elif __linux__
    printf("Linux");
    #elif __FreeBSD__
    printf("FreeBSD");
    #elif __unix || __unix__
    printf("Unix");
    #else
    printf("Other");
    #endif
    
    printf("\n");
}
    

// *********** End of preamble.
#line 43 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numIterations;
    bool useInit;
    bool useCleanupIteration;
    unsigned count;
    instant_t startTime;
    interval_t* measuredTimes;
    benchmarkrunner_initBenchmark_t __initBenchmark;
    benchmarkrunner_cleanupIteration_t __cleanupIteration;
    benchmarkrunner_nextIteration_t __nextIteration;
    benchmarkrunner_finish_t __finish;
    benchmarkrunner_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inStart_t __default__inStart;
    benchmarkrunner_inIterationFinish_t* __inIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inIterationFinish_t __default__inIterationFinish;
    benchmarkrunner_inInitializeFinish_t* __inInitializeFinish;
    // width of -2 indicates that it is not a multiport.
    int __inInitializeFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inInitializeFinish_t __default__inInitializeFinish;
    benchmarkrunner_inCleanupIterationFinish_t* __inCleanupIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inCleanupIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inCleanupIterationFinish_t __default__inCleanupIterationFinish;
    benchmarkrunner_outIterationStart_t __outIterationStart;
    int __outIterationStart__width;
    benchmarkrunner_outInitializeStart_t __outInitializeStart;
    int __outInitializeStart__width;
    benchmarkrunner_outCleanupIterationStart_t __outCleanupIterationStart;
    int __outCleanupIterationStart__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    reaction_t ___reaction_3;
    reaction_t ___reaction_4;
    reaction_t ___reaction_5;
    reaction_t ___reaction_6;
    reaction_t ___reaction_7;
    reaction_t ___reaction_8;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___initBenchmark;
    reaction_t* ___initBenchmark_reactions[1];
    trigger_t ___cleanupIteration;
    reaction_t* ___cleanupIteration_reactions[1];
    trigger_t ___nextIteration;
    reaction_t* ___nextIteration_reactions[1];
    trigger_t ___finish;
    reaction_t* ___finish_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
    trigger_t ___inIterationFinish;
    reaction_t* ___inIterationFinish_reactions[1];
    trigger_t ___inInitializeFinish;
    reaction_t* ___inInitializeFinish_reactions[1];
    trigger_t ___inCleanupIterationFinish;
    reaction_t* ___inCleanupIterationFinish_reactions[1];
} benchmarkrunner_self_t;
void benchmarkrunnerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    self->measuredTimes = calloc(self->numIterations, sizeof(interval_t));
        
}
void benchmarkrunnerreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_initBenchmark_t* initBenchmark = &self->__initBenchmark;
        schedule(initBenchmark, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outInitializeStart_t* outInitializeStart = &self->__outInitializeStart;
        
}
void benchmarkrunnerreaction_function_3(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inInitializeFinish_t* inInitializeFinish = self->__inInitializeFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inInitializeFinish_width = self->__inInitializeFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_4(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outCleanupIterationStart_t* outCleanupIterationStart = &self->__outCleanupIterationStart;
        
}
void benchmarkrunnerreaction_function_5(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inCleanupIterationFinish_t* inCleanupIterationFinish = self->__inCleanupIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inCleanupIterationFinish_width = self->__inCleanupIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_6(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outIterationStart_t* outIterationStart = &self->__outIterationStart;
    benchmarkrunner_finish_t* finish = &self->__finish;
        self->startTime = get_physical_time();
        SET(outIterationStart, true);
    } else {
        schedule(finish, 0);
    }
        
}
void benchmarkrunnerreaction_function_7(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inIterationFinish_t* inIterationFinish = self->__inIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inIterationFinish_width = self->__inIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_cleanupIteration_t* cleanupIteration = &self->__cleanupIteration;
    interval_t duration = end_time - self->startTime;
    self->measuredTimes[self->count] = duration;
    self->count += 1;
    
    printf("Iteration: %d\t Duration: %.3f msec\n", self->count, toMS(duration));
    
    if(self->useCleanupIteration) {
        schedule(cleanupIteration, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_8(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    qsort(measuredMSTimes, self->numIterations, sizeof(double), comp);
    
    printf("Execution - Summary:\n");
    printf("Best Time:\t %.3f msec\n", measuredMSTimes[0]);
    printf("Worst Time:\t %.3f msec\n", measuredMSTimes[self->numIterations - 1]);
    printf("Median Time:\t %.3f msec\n", median(measuredMSTimes, self->numIterations));
    request_stop();
        
}
benchmarkrunner_self_t* new_BenchmarkRunner() {
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)calloc(1, sizeof(benchmarkrunner_self_t));
    self->__initBenchmark.trigger = &self->___initBenchmark;
    self->__cleanupIteration.trigger = &self->___cleanupIteration;
    self->__nextIteration.trigger = &self->___nextIteration;
    self->__finish.trigger = &self->___finish;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    // Set input by default to an always absent default input.
    self->__inIterationFinish = &self->__default__inIterationFinish;
    // Set input by default to an always absent default input.
    self->__inInitializeFinish = &self->__default__inInitializeFinish;
    // Set input by default to an always absent default input.
    self->__inCleanupIterationFinish = &self->__default__inCleanupIterationFinish;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = benchmarkrunnerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = benchmarkrunnerreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = benchmarkrunnerreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___reaction_3.number = 3;
    self->___reaction_3.function = benchmarkrunnerreaction_function_3;
    self->___reaction_3.self = self;
    self->___reaction_3.deadline_violation_handler = NULL;
    self->___reaction_3.tardy_handler = NULL;
    self->___reaction_4.number = 4;
    self->___reaction_4.function = benchmarkrunnerreaction_function_4;
    self->___reaction_4.self = self;
    self->___reaction_4.deadline_violation_handler = NULL;
    self->___reaction_4.tardy_handler = NULL;
    self->___reaction_5.number = 5;
    self->___reaction_5.function = benchmarkrunnerreaction_function_5;
    self->___reaction_5.self = self;
    self->___reaction_5.deadline_violation_handler = NULL;
    self->___reaction_5.tardy_handler = NULL;
    self->___reaction_6.number = 6;
    self->___reaction_6.function = benchmarkrunnerreaction_function_6;
    self->___reaction_6.self = self;
    self->___reaction_6.deadline_violation_handler = NULL;
    self->___reaction_6.tardy_handler = NULL;
    self->___reaction_7.number = 7;
    self->___reaction_7.function = benchmarkrunnerreaction_function_7;
    self->___reaction_7.self = self;
    self->___reaction_7.deadline_violation_handler = NULL;
    self->___reaction_7.tardy_handler = NULL;
    self->___reaction_8.number = 8;
    self->___reaction_8.function = benchmarkrunnerreaction_function_8;
    self->___reaction_8.self = self;
    self->___reaction_8.deadline_violation_handler = NULL;
    self->___reaction_8.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___initBenchmark.last = NULL;
    self->___initBenchmark_reactions[0] = &self->___reaction_2;
    self->___initBenchmark.reactions = &self->___initBenchmark_reactions[0];
    self->___initBenchmark.number_of_reactions = 1;
    self->___initBenchmark.is_physical = false;
    self->___initBenchmark.element_size = sizeof(bool);
    self->___cleanupIteration.last = NULL;
    self->___cleanupIteration_reactions[0] = &self->___reaction_4;
    self->___cleanupIteration.reactions = &self->___cleanupIteration_reactions[0];
    self->___cleanupIteration.number_of_reactions = 1;
    self->___cleanupIteration.is_physical = false;
    self->___cleanupIteration.element_size = sizeof(bool);
    self->___nextIteration.last = NULL;
    self->___nextIteration_reactions[0] = &self->___reaction_6;
    self->___nextIteration.reactions = &self->___nextIteration_reactions[0];
    self->___nextIteration.number_of_reactions = 1;
    self->___nextIteration.is_physical = false;
    self->___nextIteration.element_size = sizeof(bool);
    self->___finish.last = NULL;
    self->___finish_reactions[0] = &self->___reaction_8;
    self->___finish.reactions = &self->___finish_reactions[0];
    self->___finish.number_of_reactions = 1;
    self->___finish.is_physical = false;
    self->___finish.element_size = sizeof(bool);
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_1;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    self->___inIterationFinish.last = NULL;
    self->___inIterationFinish_reactions[0] = &self->___reaction_7;
    self->___inIterationFinish.reactions = &self->___inIterationFinish_reactions[0];
    self->___inIterationFinish.number_of_reactions = 1;
    self->___inIterationFinish.element_size = sizeof(bool);
    self->___inInitializeFinish.last = NULL;
    self->___inInitializeFinish_reactions[0] = &self->___reaction_3;
    self->___inInitializeFinish.reactions = &self->___inInitializeFinish_reactions[0];
    self->___inInitializeFinish.number_of_reactions = 1;
    self->___inInitializeFinish.element_size = sizeof(bool);
    self->___inCleanupIterationFinish.last = NULL;
    self->___inCleanupIterationFinish_reactions[0] = &self->___reaction_5;
    self->___inCleanupIterationFinish.reactions = &self->___inCleanupIterationFinish_reactions[0];
    self->___inCleanupIterationFinish.number_of_reactions = 1;
    self->___inCleanupIterationFinish.element_size = sizeof(bool);
    return self;
}
void delete_BenchmarkRunner(benchmarkrunner_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    if (self->___reaction_3.output_produced != NULL) {
        free(self->___reaction_3.output_produced);
    }
    if (self->___reaction_3.triggers != NULL) {
        free(self->___reaction_3.triggers);
    }
    if (self->___reaction_3.triggered_sizes != NULL) {
        free(self->___reaction_3.triggered_sizes);
    }
    if (self->___reaction_4.output_produced != NULL) {
        free(self->___reaction_4.output_produced);
    }
    if (self->___reaction_4.triggers != NULL) {
        free(self->___reaction_4.triggers);
    }
    if (self->___reaction_4.triggered_sizes != NULL) {
        free(self->___reaction_4.triggered_sizes);
    }
    if (self->___reaction_5.output_produced != NULL) {
        free(self->___reaction_5.output_produced);
    }
    if (self->___reaction_5.triggers != NULL) {
        free(self->___reaction_5.triggers);
    }
    if (self->___reaction_5.triggered_sizes != NULL) {
        free(self->___reaction_5.triggered_sizes);
    }
    if (self->___reaction_6.output_produced != NULL) {
        free(self->___reaction_6.output_produced);
    }
    if (self->___reaction_6.triggers != NULL) {
        free(self->___reaction_6.triggers);
    }
    if (self->___reaction_6.triggered_sizes != NULL) {
        free(self->___reaction_6.triggered_sizes);
    }
    if (self->___reaction_7.output_produced != NULL) {
        free(self->___reaction_7.output_produced);
    }
    if (self->___reaction_7.triggers != NULL) {
        free(self->___reaction_7.triggers);
    }
    if (self->___reaction_7.triggered_sizes != NULL) {
        free(self->___reaction_7.triggered_sizes);
    }
    if (self->___reaction_8.output_produced != NULL) {
        free(self->___reaction_8.output_produced);
    }
    if (self->___reaction_8.triggers != NULL) {
        free(self->___reaction_8.triggers);
    }
    if (self->___reaction_8.triggered_sizes != NULL) {
        free(self->___reaction_8.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_3.num_outputs; i++) {
        free(self->___reaction_3.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_4.num_outputs; i++) {
        free(self->___reaction_4.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_5.num_outputs; i++) {
        free(self->___reaction_5.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_6.num_outputs; i++) {
        free(self->___reaction_6.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_7.num_outputs; i++) {
        free(self->___reaction_7.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_8.num_outputs; i++) {
        free(self->___reaction_8.triggers[i]);
    }
    free(self);
}
// =============== END reactor class BenchmarkRunner

// =============== START reactor class Master
#line 65 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\trapezoid\\TrapezoidalBenchmarkGenerator.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numWorkers;
    double L;
    double R;
    int N;
    int numTermsReceived;
    double resultArea;
    master_sendWorkMessages_t __sendWorkMessages;
    master_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    master_inStart_t __default__inStart;
    // Multiport input array will be malloc'd later.
    master_inWorkers_t** __inWorkers;
    int __inWorkers__width;
    // Default input (in case it does not get connected)
    master_inWorkers_t __default__inWorkers;
    master_outFinished_t __outFinished;
    int __outFinished__width;
    // Array of output ports.
    master_outWorkers_t* __outWorkers;
    int __outWorkers__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    trigger_t ___sendWorkMessages;
    reaction_t* ___sendWorkMessages_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
    trigger_t ___inWorkers;
    reaction_t* ___inWorkers_reactions[1];
} master_self_t;
void masterreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    master_self_t* self = (master_self_t*)instance_args;
    #pragma GCC diagnostic pop
    master_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    master_sendWorkMessages_t* sendWorkMessages = &self->__sendWorkMessages;
    // reset local state
    self->numTermsReceived = 0;
    self->resultArea = 0.0;
    
    // start execution
    schedule(sendWorkMessages, 0);
        
}
void masterreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    master_self_t* self = (master_self_t*)instance_args;
    #pragma GCC diagnostic pop
    int outWorkers_width = self->__outWorkers__width;
    master_outWorkers_t* outWorkers[outWorkers_width];
    for(int i=0; i < outWorkers_width; i++) {
         outWorkers[i] = &(self->__outWorkers[i]);
    }
    double workerRange = (self->R - self->L) / self->numWorkers;
    double precision = (self->R - self->L) / self->N;
    for(int i = 0; i < outWorkers_width; ++i) {
        double wl = (workerRange * i) + self->L;
        double wr = wl + workerRange;
        
        SET(outWorkers[i], ((WorkMessage){wl,wr,precision}));
    }
        
}
void masterreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    master_self_t* self = (master_self_t*)instance_args;
    #pragma GCC diagnostic pop
    master_inWorkers_t** inWorkers = self->__inWorkers;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inWorkers_width = self->__inWorkers__width;
    #pragma GCC diagnostic pop
    master_outFinished_t* outFinished = &self->__outFinished;
    for(int i = 0; i < inWorkers_width; ++i) {
        if(inWorkers[i]->is_present) {
            self->numTermsReceived += 1;
            self->resultArea += inWorkers[i]->value;
        }
    }
    
    if(self->numTermsReceived == self->numWorkers) {
        printf("Area: %f.\n", self->resultArea);
        SET(outFinished, true);
    }
        
}
master_self_t* new_Master() {
    master_self_t* self = (master_self_t*)calloc(1, sizeof(master_self_t));
    self->__sendWorkMessages.trigger = &self->___sendWorkMessages;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = masterreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = masterreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = masterreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___sendWorkMessages.last = NULL;
    self->___sendWorkMessages_reactions[0] = &self->___reaction_1;
    self->___sendWorkMessages.reactions = &self->___sendWorkMessages_reactions[0];
    self->___sendWorkMessages.number_of_reactions = 1;
    self->___sendWorkMessages.is_physical = false;
    self->___sendWorkMessages.element_size = 0;
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_0;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    self->___inWorkers.last = NULL;
    self->___inWorkers_reactions[0] = &self->___reaction_2;
    self->___inWorkers.reactions = &self->___inWorkers_reactions[0];
    self->___inWorkers.number_of_reactions = 1;
    self->___inWorkers.element_size = sizeof(double);
    return self;
}
void delete_Master(master_self_t* self) {
    free(self->__inWorkers);
    free(self->__outWorkers);
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Master

// =============== START reactor class ProdConsBenchmark
typedef struct {
    int bank_index;
    int numWorkers;
    int numIterations;
    int numPieces;
    double leftEndPoint;
    double rightEndPoint;
    struct {
        benchmarkrunner_inStart_t inStart;
    } __runner;
    reaction_t ___reaction_0;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
} prodconsbenchmark_self_t;
void prodconsbenchmarkreaction_function_0(void* instance_args) {
    struct runner{
        benchmarkrunner_inStart_t* inStart;
    } runner;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    prodconsbenchmark_self_t* self = (prodconsbenchmark_self_t*)instance_args;
    #pragma GCC diagnostic pop
    runner.inStart = &(self->__runner.inStart);
    printf("numWorkers: %d.\n", self->numWorkers);
    printf("numIterations: %d.\n", self->numIterations);
    printf("numPieces: %d.\n", self->numPieces);
    printf("leftEndPoint: %f.\n", self->leftEndPoint);
    printf("rightEndPoint: %f.\n", self->rightEndPoint);
    printSystemInfo();
    SET(runner.inStart, true);
        
}
prodconsbenchmark_self_t* new_ProdConsBenchmark() {
    prodconsbenchmark_self_t* self = (prodconsbenchmark_self_t*)calloc(1, sizeof(prodconsbenchmark_self_t));
    self->___reaction_0.number = 0;
    self->___reaction_0.function = prodconsbenchmarkreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    return self;
}
void delete_ProdConsBenchmark(prodconsbenchmark_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class ProdConsBenchmark

char* __default_argv[] = {"TrapezoidalBenchmarkGenerator", "-k", "true"};
void __set_default_command_line_options() {
    default_argc = 3;
    default_argv = __default_argv;
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t** __timer_triggers = NULL;
int __timer_triggers_size = 0;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[2];
int __startup_reactions_size = 2;
// Empty array of pointers to shutdown triggers.
reaction_t** __shutdown_reactions = NULL;
int __shutdown_reactions_size = 0;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 5;
    __tokens_with_ref_count = (token_present_t*)malloc(5 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 210;
    __is_present_fields = (bool**)malloc(210 * sizeof(bool*));
    // ************* Instance ProdConsBenchmark of class ProdConsBenchmark
    prodconsbenchmark_self_t* prodconsbenchmark_self = new_ProdConsBenchmark();
    //***** Start initializing ProdConsBenchmark
    prodconsbenchmark_self->numWorkers = 100; 
    prodconsbenchmark_self->numIterations = 12; 
    prodconsbenchmark_self->numPieces = 10000000; 
    prodconsbenchmark_self->leftEndPoint = 1.0; 
    prodconsbenchmark_self->rightEndPoint = 5.0; 
    __startup_reactions[0] = &prodconsbenchmark_self->___reaction_0;
    // ************* Instance ProdConsBenchmark.master of class Master
    master_self_t* prodconsbenchmark_master_self = new_Master();
    //***** Start initializing ProdConsBenchmark.master
    prodconsbenchmark_master_self->numWorkers = 100; 
    prodconsbenchmark_master_self->L = 1.0; 
    prodconsbenchmark_master_self->R = 5.0; 
    prodconsbenchmark_master_self->N = 10000000; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_master_self->__outFinished__width = -2;
    prodconsbenchmark_master_self->__outWorkers__width = prodconsbenchmark_master_self->numWorkers;
    // Allocate memory for multiport output.
    prodconsbenchmark_master_self->__outWorkers = (master_outWorkers_t*)malloc(sizeof(master_outWorkers_t) * prodconsbenchmark_master_self->__outWorkers__width); 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_master_self->__inStart__width = -2;
    prodconsbenchmark_master_self->__inWorkers__width = prodconsbenchmark_master_self->numWorkers;
    // Allocate memory for multiport inputs.
    prodconsbenchmark_master_self->__inWorkers = (master_inWorkers_t**)malloc(sizeof(master_inWorkers_t*) * prodconsbenchmark_master_self->__inWorkers__width); 
    // Set inputs by default to an always absent default input.
    for (int i = 0; i < prodconsbenchmark_master_self->__inWorkers__width; i++) {
        prodconsbenchmark_master_self->__inWorkers[i] = &prodconsbenchmark_master_self->__default__inWorkers;
    }
    static int prodconsbenchmark_master_initial_numTermsReceived = 0;
    prodconsbenchmark_master_self->numTermsReceived = prodconsbenchmark_master_initial_numTermsReceived;
    static double prodconsbenchmark_master_initial_resultArea = 0.0;
    prodconsbenchmark_master_self->resultArea = prodconsbenchmark_master_initial_resultArea;
    prodconsbenchmark_master_self->___sendWorkMessages.offset = 0;
    prodconsbenchmark_master_self->___sendWorkMessages.period = -1;
    prodconsbenchmark_master_self->___sendWorkMessages.token = __create_token(0);
    prodconsbenchmark_master_self->___sendWorkMessages.is_present = false;
    __tokens_with_ref_count[0].token
            = &prodconsbenchmark_master_self->___sendWorkMessages.token;
    __tokens_with_ref_count[0].is_present
            = &prodconsbenchmark_master_self->___sendWorkMessages.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing ProdConsBenchmark.master
    // ************* Instance ProdConsBenchmark.runner of class BenchmarkRunner
    benchmarkrunner_self_t* prodconsbenchmark_runner_self = new_BenchmarkRunner();
    //***** Start initializing ProdConsBenchmark.runner
    prodconsbenchmark_runner_self->numIterations = 12; 
    prodconsbenchmark_runner_self->useInit = false; 
    prodconsbenchmark_runner_self->useCleanupIteration = false; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__outIterationStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__outInitializeStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__outCleanupIterationStart__width = -2;
    __startup_reactions[1] = &prodconsbenchmark_runner_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__inStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__inIterationFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__inInitializeFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_runner_self->__inCleanupIterationFinish__width = -2;
    static unsigned prodconsbenchmark_runner_initial_count = 0;
    prodconsbenchmark_runner_self->count = prodconsbenchmark_runner_initial_count;
    prodconsbenchmark_runner_self->___initBenchmark.offset = 0;
    prodconsbenchmark_runner_self->___initBenchmark.period = -1;
    prodconsbenchmark_runner_self->___cleanupIteration.offset = 0;
    prodconsbenchmark_runner_self->___cleanupIteration.period = -1;
    prodconsbenchmark_runner_self->___nextIteration.offset = 0;
    prodconsbenchmark_runner_self->___nextIteration.period = -1;
    prodconsbenchmark_runner_self->___finish.offset = 0;
    prodconsbenchmark_runner_self->___finish.period = -1;
    prodconsbenchmark_runner_self->___initBenchmark.token = __create_token(sizeof(bool));
    prodconsbenchmark_runner_self->___initBenchmark.is_present = false;
    __tokens_with_ref_count[1].token
            = &prodconsbenchmark_runner_self->___initBenchmark.token;
    __tokens_with_ref_count[1].is_present
            = &prodconsbenchmark_runner_self->___initBenchmark.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    prodconsbenchmark_runner_self->___cleanupIteration.token = __create_token(sizeof(bool));
    prodconsbenchmark_runner_self->___cleanupIteration.is_present = false;
    __tokens_with_ref_count[2].token
            = &prodconsbenchmark_runner_self->___cleanupIteration.token;
    __tokens_with_ref_count[2].is_present
            = &prodconsbenchmark_runner_self->___cleanupIteration.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    prodconsbenchmark_runner_self->___nextIteration.token = __create_token(sizeof(bool));
    prodconsbenchmark_runner_self->___nextIteration.is_present = false;
    __tokens_with_ref_count[3].token
            = &prodconsbenchmark_runner_self->___nextIteration.token;
    __tokens_with_ref_count[3].is_present
            = &prodconsbenchmark_runner_self->___nextIteration.is_present;
    __tokens_with_ref_count[3].reset_is_present = true;
    prodconsbenchmark_runner_self->___finish.token = __create_token(sizeof(bool));
    prodconsbenchmark_runner_self->___finish.is_present = false;
    __tokens_with_ref_count[4].token
            = &prodconsbenchmark_runner_self->___finish.token;
    __tokens_with_ref_count[4].is_present
            = &prodconsbenchmark_runner_self->___finish.is_present;
    __tokens_with_ref_count[4].reset_is_present = true;
    //***** End initializing ProdConsBenchmark.runner
    // ************* Instance ProdConsBenchmark.workers of class Worker
    worker_self_t* prodconsbenchmark_workers_self[100];
    // ************* Instance ProdConsBenchmark.workers[0] of class Worker
    prodconsbenchmark_workers_self[0] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[0]
    prodconsbenchmark_workers_self[0]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[0]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[0]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[0]
    // ************* Instance ProdConsBenchmark.workers[1] of class Worker
    prodconsbenchmark_workers_self[1] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[1]
    prodconsbenchmark_workers_self[1]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[1]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[1]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[1]
    // ************* Instance ProdConsBenchmark.workers[2] of class Worker
    prodconsbenchmark_workers_self[2] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[2]
    prodconsbenchmark_workers_self[2]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[2]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[2]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[2]
    // ************* Instance ProdConsBenchmark.workers[3] of class Worker
    prodconsbenchmark_workers_self[3] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[3]
    prodconsbenchmark_workers_self[3]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[3]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[3]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[3]
    // ************* Instance ProdConsBenchmark.workers[4] of class Worker
    prodconsbenchmark_workers_self[4] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[4]
    prodconsbenchmark_workers_self[4]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[4]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[4]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[4]
    // ************* Instance ProdConsBenchmark.workers[5] of class Worker
    prodconsbenchmark_workers_self[5] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[5]
    prodconsbenchmark_workers_self[5]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[5]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[5]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[5]
    // ************* Instance ProdConsBenchmark.workers[6] of class Worker
    prodconsbenchmark_workers_self[6] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[6]
    prodconsbenchmark_workers_self[6]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[6]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[6]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[6]
    // ************* Instance ProdConsBenchmark.workers[7] of class Worker
    prodconsbenchmark_workers_self[7] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[7]
    prodconsbenchmark_workers_self[7]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[7]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[7]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[7]
    // ************* Instance ProdConsBenchmark.workers[8] of class Worker
    prodconsbenchmark_workers_self[8] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[8]
    prodconsbenchmark_workers_self[8]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[8]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[8]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[8]
    // ************* Instance ProdConsBenchmark.workers[9] of class Worker
    prodconsbenchmark_workers_self[9] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[9]
    prodconsbenchmark_workers_self[9]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[9]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[9]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[9]
    // ************* Instance ProdConsBenchmark.workers[10] of class Worker
    prodconsbenchmark_workers_self[10] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[10]
    prodconsbenchmark_workers_self[10]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[10]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[10]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[10]
    // ************* Instance ProdConsBenchmark.workers[11] of class Worker
    prodconsbenchmark_workers_self[11] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[11]
    prodconsbenchmark_workers_self[11]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[11]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[11]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[11]
    // ************* Instance ProdConsBenchmark.workers[12] of class Worker
    prodconsbenchmark_workers_self[12] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[12]
    prodconsbenchmark_workers_self[12]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[12]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[12]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[12]
    // ************* Instance ProdConsBenchmark.workers[13] of class Worker
    prodconsbenchmark_workers_self[13] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[13]
    prodconsbenchmark_workers_self[13]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[13]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[13]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[13]
    // ************* Instance ProdConsBenchmark.workers[14] of class Worker
    prodconsbenchmark_workers_self[14] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[14]
    prodconsbenchmark_workers_self[14]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[14]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[14]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[14]
    // ************* Instance ProdConsBenchmark.workers[15] of class Worker
    prodconsbenchmark_workers_self[15] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[15]
    prodconsbenchmark_workers_self[15]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[15]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[15]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[15]
    // ************* Instance ProdConsBenchmark.workers[16] of class Worker
    prodconsbenchmark_workers_self[16] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[16]
    prodconsbenchmark_workers_self[16]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[16]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[16]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[16]
    // ************* Instance ProdConsBenchmark.workers[17] of class Worker
    prodconsbenchmark_workers_self[17] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[17]
    prodconsbenchmark_workers_self[17]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[17]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[17]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[17]
    // ************* Instance ProdConsBenchmark.workers[18] of class Worker
    prodconsbenchmark_workers_self[18] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[18]
    prodconsbenchmark_workers_self[18]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[18]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[18]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[18]
    // ************* Instance ProdConsBenchmark.workers[19] of class Worker
    prodconsbenchmark_workers_self[19] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[19]
    prodconsbenchmark_workers_self[19]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[19]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[19]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[19]
    // ************* Instance ProdConsBenchmark.workers[20] of class Worker
    prodconsbenchmark_workers_self[20] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[20]
    prodconsbenchmark_workers_self[20]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[20]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[20]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[20]
    // ************* Instance ProdConsBenchmark.workers[21] of class Worker
    prodconsbenchmark_workers_self[21] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[21]
    prodconsbenchmark_workers_self[21]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[21]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[21]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[21]
    // ************* Instance ProdConsBenchmark.workers[22] of class Worker
    prodconsbenchmark_workers_self[22] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[22]
    prodconsbenchmark_workers_self[22]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[22]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[22]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[22]
    // ************* Instance ProdConsBenchmark.workers[23] of class Worker
    prodconsbenchmark_workers_self[23] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[23]
    prodconsbenchmark_workers_self[23]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[23]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[23]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[23]
    // ************* Instance ProdConsBenchmark.workers[24] of class Worker
    prodconsbenchmark_workers_self[24] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[24]
    prodconsbenchmark_workers_self[24]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[24]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[24]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[24]
    // ************* Instance ProdConsBenchmark.workers[25] of class Worker
    prodconsbenchmark_workers_self[25] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[25]
    prodconsbenchmark_workers_self[25]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[25]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[25]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[25]
    // ************* Instance ProdConsBenchmark.workers[26] of class Worker
    prodconsbenchmark_workers_self[26] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[26]
    prodconsbenchmark_workers_self[26]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[26]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[26]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[26]
    // ************* Instance ProdConsBenchmark.workers[27] of class Worker
    prodconsbenchmark_workers_self[27] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[27]
    prodconsbenchmark_workers_self[27]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[27]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[27]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[27]
    // ************* Instance ProdConsBenchmark.workers[28] of class Worker
    prodconsbenchmark_workers_self[28] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[28]
    prodconsbenchmark_workers_self[28]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[28]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[28]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[28]
    // ************* Instance ProdConsBenchmark.workers[29] of class Worker
    prodconsbenchmark_workers_self[29] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[29]
    prodconsbenchmark_workers_self[29]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[29]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[29]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[29]
    // ************* Instance ProdConsBenchmark.workers[30] of class Worker
    prodconsbenchmark_workers_self[30] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[30]
    prodconsbenchmark_workers_self[30]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[30]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[30]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[30]
    // ************* Instance ProdConsBenchmark.workers[31] of class Worker
    prodconsbenchmark_workers_self[31] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[31]
    prodconsbenchmark_workers_self[31]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[31]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[31]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[31]
    // ************* Instance ProdConsBenchmark.workers[32] of class Worker
    prodconsbenchmark_workers_self[32] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[32]
    prodconsbenchmark_workers_self[32]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[32]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[32]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[32]
    // ************* Instance ProdConsBenchmark.workers[33] of class Worker
    prodconsbenchmark_workers_self[33] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[33]
    prodconsbenchmark_workers_self[33]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[33]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[33]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[33]
    // ************* Instance ProdConsBenchmark.workers[34] of class Worker
    prodconsbenchmark_workers_self[34] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[34]
    prodconsbenchmark_workers_self[34]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[34]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[34]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[34]
    // ************* Instance ProdConsBenchmark.workers[35] of class Worker
    prodconsbenchmark_workers_self[35] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[35]
    prodconsbenchmark_workers_self[35]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[35]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[35]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[35]
    // ************* Instance ProdConsBenchmark.workers[36] of class Worker
    prodconsbenchmark_workers_self[36] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[36]
    prodconsbenchmark_workers_self[36]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[36]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[36]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[36]
    // ************* Instance ProdConsBenchmark.workers[37] of class Worker
    prodconsbenchmark_workers_self[37] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[37]
    prodconsbenchmark_workers_self[37]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[37]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[37]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[37]
    // ************* Instance ProdConsBenchmark.workers[38] of class Worker
    prodconsbenchmark_workers_self[38] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[38]
    prodconsbenchmark_workers_self[38]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[38]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[38]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[38]
    // ************* Instance ProdConsBenchmark.workers[39] of class Worker
    prodconsbenchmark_workers_self[39] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[39]
    prodconsbenchmark_workers_self[39]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[39]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[39]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[39]
    // ************* Instance ProdConsBenchmark.workers[40] of class Worker
    prodconsbenchmark_workers_self[40] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[40]
    prodconsbenchmark_workers_self[40]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[40]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[40]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[40]
    // ************* Instance ProdConsBenchmark.workers[41] of class Worker
    prodconsbenchmark_workers_self[41] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[41]
    prodconsbenchmark_workers_self[41]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[41]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[41]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[41]
    // ************* Instance ProdConsBenchmark.workers[42] of class Worker
    prodconsbenchmark_workers_self[42] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[42]
    prodconsbenchmark_workers_self[42]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[42]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[42]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[42]
    // ************* Instance ProdConsBenchmark.workers[43] of class Worker
    prodconsbenchmark_workers_self[43] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[43]
    prodconsbenchmark_workers_self[43]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[43]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[43]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[43]
    // ************* Instance ProdConsBenchmark.workers[44] of class Worker
    prodconsbenchmark_workers_self[44] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[44]
    prodconsbenchmark_workers_self[44]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[44]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[44]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[44]
    // ************* Instance ProdConsBenchmark.workers[45] of class Worker
    prodconsbenchmark_workers_self[45] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[45]
    prodconsbenchmark_workers_self[45]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[45]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[45]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[45]
    // ************* Instance ProdConsBenchmark.workers[46] of class Worker
    prodconsbenchmark_workers_self[46] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[46]
    prodconsbenchmark_workers_self[46]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[46]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[46]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[46]
    // ************* Instance ProdConsBenchmark.workers[47] of class Worker
    prodconsbenchmark_workers_self[47] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[47]
    prodconsbenchmark_workers_self[47]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[47]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[47]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[47]
    // ************* Instance ProdConsBenchmark.workers[48] of class Worker
    prodconsbenchmark_workers_self[48] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[48]
    prodconsbenchmark_workers_self[48]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[48]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[48]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[48]
    // ************* Instance ProdConsBenchmark.workers[49] of class Worker
    prodconsbenchmark_workers_self[49] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[49]
    prodconsbenchmark_workers_self[49]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[49]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[49]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[49]
    // ************* Instance ProdConsBenchmark.workers[50] of class Worker
    prodconsbenchmark_workers_self[50] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[50]
    prodconsbenchmark_workers_self[50]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[50]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[50]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[50]
    // ************* Instance ProdConsBenchmark.workers[51] of class Worker
    prodconsbenchmark_workers_self[51] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[51]
    prodconsbenchmark_workers_self[51]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[51]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[51]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[51]
    // ************* Instance ProdConsBenchmark.workers[52] of class Worker
    prodconsbenchmark_workers_self[52] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[52]
    prodconsbenchmark_workers_self[52]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[52]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[52]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[52]
    // ************* Instance ProdConsBenchmark.workers[53] of class Worker
    prodconsbenchmark_workers_self[53] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[53]
    prodconsbenchmark_workers_self[53]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[53]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[53]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[53]
    // ************* Instance ProdConsBenchmark.workers[54] of class Worker
    prodconsbenchmark_workers_self[54] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[54]
    prodconsbenchmark_workers_self[54]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[54]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[54]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[54]
    // ************* Instance ProdConsBenchmark.workers[55] of class Worker
    prodconsbenchmark_workers_self[55] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[55]
    prodconsbenchmark_workers_self[55]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[55]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[55]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[55]
    // ************* Instance ProdConsBenchmark.workers[56] of class Worker
    prodconsbenchmark_workers_self[56] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[56]
    prodconsbenchmark_workers_self[56]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[56]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[56]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[56]
    // ************* Instance ProdConsBenchmark.workers[57] of class Worker
    prodconsbenchmark_workers_self[57] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[57]
    prodconsbenchmark_workers_self[57]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[57]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[57]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[57]
    // ************* Instance ProdConsBenchmark.workers[58] of class Worker
    prodconsbenchmark_workers_self[58] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[58]
    prodconsbenchmark_workers_self[58]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[58]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[58]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[58]
    // ************* Instance ProdConsBenchmark.workers[59] of class Worker
    prodconsbenchmark_workers_self[59] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[59]
    prodconsbenchmark_workers_self[59]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[59]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[59]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[59]
    // ************* Instance ProdConsBenchmark.workers[60] of class Worker
    prodconsbenchmark_workers_self[60] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[60]
    prodconsbenchmark_workers_self[60]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[60]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[60]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[60]
    // ************* Instance ProdConsBenchmark.workers[61] of class Worker
    prodconsbenchmark_workers_self[61] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[61]
    prodconsbenchmark_workers_self[61]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[61]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[61]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[61]
    // ************* Instance ProdConsBenchmark.workers[62] of class Worker
    prodconsbenchmark_workers_self[62] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[62]
    prodconsbenchmark_workers_self[62]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[62]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[62]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[62]
    // ************* Instance ProdConsBenchmark.workers[63] of class Worker
    prodconsbenchmark_workers_self[63] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[63]
    prodconsbenchmark_workers_self[63]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[63]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[63]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[63]
    // ************* Instance ProdConsBenchmark.workers[64] of class Worker
    prodconsbenchmark_workers_self[64] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[64]
    prodconsbenchmark_workers_self[64]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[64]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[64]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[64]
    // ************* Instance ProdConsBenchmark.workers[65] of class Worker
    prodconsbenchmark_workers_self[65] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[65]
    prodconsbenchmark_workers_self[65]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[65]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[65]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[65]
    // ************* Instance ProdConsBenchmark.workers[66] of class Worker
    prodconsbenchmark_workers_self[66] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[66]
    prodconsbenchmark_workers_self[66]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[66]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[66]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[66]
    // ************* Instance ProdConsBenchmark.workers[67] of class Worker
    prodconsbenchmark_workers_self[67] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[67]
    prodconsbenchmark_workers_self[67]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[67]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[67]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[67]
    // ************* Instance ProdConsBenchmark.workers[68] of class Worker
    prodconsbenchmark_workers_self[68] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[68]
    prodconsbenchmark_workers_self[68]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[68]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[68]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[68]
    // ************* Instance ProdConsBenchmark.workers[69] of class Worker
    prodconsbenchmark_workers_self[69] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[69]
    prodconsbenchmark_workers_self[69]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[69]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[69]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[69]
    // ************* Instance ProdConsBenchmark.workers[70] of class Worker
    prodconsbenchmark_workers_self[70] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[70]
    prodconsbenchmark_workers_self[70]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[70]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[70]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[70]
    // ************* Instance ProdConsBenchmark.workers[71] of class Worker
    prodconsbenchmark_workers_self[71] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[71]
    prodconsbenchmark_workers_self[71]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[71]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[71]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[71]
    // ************* Instance ProdConsBenchmark.workers[72] of class Worker
    prodconsbenchmark_workers_self[72] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[72]
    prodconsbenchmark_workers_self[72]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[72]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[72]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[72]
    // ************* Instance ProdConsBenchmark.workers[73] of class Worker
    prodconsbenchmark_workers_self[73] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[73]
    prodconsbenchmark_workers_self[73]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[73]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[73]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[73]
    // ************* Instance ProdConsBenchmark.workers[74] of class Worker
    prodconsbenchmark_workers_self[74] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[74]
    prodconsbenchmark_workers_self[74]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[74]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[74]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[74]
    // ************* Instance ProdConsBenchmark.workers[75] of class Worker
    prodconsbenchmark_workers_self[75] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[75]
    prodconsbenchmark_workers_self[75]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[75]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[75]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[75]
    // ************* Instance ProdConsBenchmark.workers[76] of class Worker
    prodconsbenchmark_workers_self[76] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[76]
    prodconsbenchmark_workers_self[76]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[76]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[76]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[76]
    // ************* Instance ProdConsBenchmark.workers[77] of class Worker
    prodconsbenchmark_workers_self[77] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[77]
    prodconsbenchmark_workers_self[77]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[77]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[77]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[77]
    // ************* Instance ProdConsBenchmark.workers[78] of class Worker
    prodconsbenchmark_workers_self[78] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[78]
    prodconsbenchmark_workers_self[78]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[78]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[78]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[78]
    // ************* Instance ProdConsBenchmark.workers[79] of class Worker
    prodconsbenchmark_workers_self[79] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[79]
    prodconsbenchmark_workers_self[79]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[79]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[79]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[79]
    // ************* Instance ProdConsBenchmark.workers[80] of class Worker
    prodconsbenchmark_workers_self[80] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[80]
    prodconsbenchmark_workers_self[80]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[80]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[80]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[80]
    // ************* Instance ProdConsBenchmark.workers[81] of class Worker
    prodconsbenchmark_workers_self[81] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[81]
    prodconsbenchmark_workers_self[81]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[81]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[81]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[81]
    // ************* Instance ProdConsBenchmark.workers[82] of class Worker
    prodconsbenchmark_workers_self[82] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[82]
    prodconsbenchmark_workers_self[82]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[82]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[82]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[82]
    // ************* Instance ProdConsBenchmark.workers[83] of class Worker
    prodconsbenchmark_workers_self[83] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[83]
    prodconsbenchmark_workers_self[83]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[83]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[83]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[83]
    // ************* Instance ProdConsBenchmark.workers[84] of class Worker
    prodconsbenchmark_workers_self[84] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[84]
    prodconsbenchmark_workers_self[84]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[84]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[84]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[84]
    // ************* Instance ProdConsBenchmark.workers[85] of class Worker
    prodconsbenchmark_workers_self[85] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[85]
    prodconsbenchmark_workers_self[85]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[85]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[85]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[85]
    // ************* Instance ProdConsBenchmark.workers[86] of class Worker
    prodconsbenchmark_workers_self[86] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[86]
    prodconsbenchmark_workers_self[86]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[86]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[86]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[86]
    // ************* Instance ProdConsBenchmark.workers[87] of class Worker
    prodconsbenchmark_workers_self[87] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[87]
    prodconsbenchmark_workers_self[87]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[87]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[87]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[87]
    // ************* Instance ProdConsBenchmark.workers[88] of class Worker
    prodconsbenchmark_workers_self[88] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[88]
    prodconsbenchmark_workers_self[88]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[88]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[88]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[88]
    // ************* Instance ProdConsBenchmark.workers[89] of class Worker
    prodconsbenchmark_workers_self[89] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[89]
    prodconsbenchmark_workers_self[89]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[89]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[89]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[89]
    // ************* Instance ProdConsBenchmark.workers[90] of class Worker
    prodconsbenchmark_workers_self[90] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[90]
    prodconsbenchmark_workers_self[90]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[90]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[90]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[90]
    // ************* Instance ProdConsBenchmark.workers[91] of class Worker
    prodconsbenchmark_workers_self[91] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[91]
    prodconsbenchmark_workers_self[91]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[91]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[91]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[91]
    // ************* Instance ProdConsBenchmark.workers[92] of class Worker
    prodconsbenchmark_workers_self[92] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[92]
    prodconsbenchmark_workers_self[92]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[92]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[92]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[92]
    // ************* Instance ProdConsBenchmark.workers[93] of class Worker
    prodconsbenchmark_workers_self[93] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[93]
    prodconsbenchmark_workers_self[93]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[93]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[93]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[93]
    // ************* Instance ProdConsBenchmark.workers[94] of class Worker
    prodconsbenchmark_workers_self[94] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[94]
    prodconsbenchmark_workers_self[94]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[94]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[94]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[94]
    // ************* Instance ProdConsBenchmark.workers[95] of class Worker
    prodconsbenchmark_workers_self[95] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[95]
    prodconsbenchmark_workers_self[95]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[95]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[95]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[95]
    // ************* Instance ProdConsBenchmark.workers[96] of class Worker
    prodconsbenchmark_workers_self[96] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[96]
    prodconsbenchmark_workers_self[96]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[96]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[96]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[96]
    // ************* Instance ProdConsBenchmark.workers[97] of class Worker
    prodconsbenchmark_workers_self[97] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[97]
    prodconsbenchmark_workers_self[97]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[97]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[97]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[97]
    // ************* Instance ProdConsBenchmark.workers[98] of class Worker
    prodconsbenchmark_workers_self[98] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[98]
    prodconsbenchmark_workers_self[98]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[98]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[98]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[98]
    // ************* Instance ProdConsBenchmark.workers[99] of class Worker
    prodconsbenchmark_workers_self[99] = new_Worker();
    //***** Start initializing ProdConsBenchmark.workers[99]
    prodconsbenchmark_workers_self[99]->instance = 0; 
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[99]->__outMaster__width = -2;
    // width of -2 indicates that it is not a multiport.
    prodconsbenchmark_workers_self[99]->__inMaster__width = -2;
    //***** End initializing ProdConsBenchmark.workers[99]
    //***** End initializing ProdConsBenchmark
    // Populate arrays of trigger pointers.
    prodconsbenchmark_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_self->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_self->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_self->___reaction_0.num_outputs);
        prodconsbenchmark_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_self->___reaction_0.num_outputs);
        prodconsbenchmark_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_self->___reaction_0.output_produced[0]
    = &prodconsbenchmark_self->__runner.inStart.is_present
    ;
    // Reaction 0 of ProdConsBenchmark does not depend on one maximal upstream reaction.
    prodconsbenchmark_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProdConsBenchmark triggers 1 downstream reactions through port ProdConsBenchmark.runner.inStart.
    prodconsbenchmark_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.runner.inStart
    trigger_t** prodconsbenchmark_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_self->___reaction_0.triggers[0] = prodconsbenchmark_0_0;
    // Point to destination port ProdConsBenchmark.runner.inStart's trigger struct.
    prodconsbenchmark_0_0[0] = &prodconsbenchmark_runner_self->___inStart;
    prodconsbenchmark_self->__runner.inStart.
    num_destinations = 1;
    prodconsbenchmark_master_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_master_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_master_self->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_master_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_master_self->___reaction_0.num_outputs);
        prodconsbenchmark_master_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_master_self->___reaction_0.num_outputs);
        prodconsbenchmark_master_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_master_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_master_self->__outWorkers__width = prodconsbenchmark_master_self->numWorkers;
    // Allocate memory to store output of reaction.
    prodconsbenchmark_master_self->__outWorkers = (master_outWorkers_t*)malloc(sizeof(master_outWorkers_t) 
        * prodconsbenchmark_master_self->__outWorkers__width); 
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_master_self->___reaction_1.num_outputs = 0 + prodconsbenchmark_master_self->numWorkers;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_master_self->___reaction_1.num_outputs > 0) {
        prodconsbenchmark_master_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_master_self->___reaction_1.num_outputs);
        prodconsbenchmark_master_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_master_self->___reaction_1.num_outputs);
        prodconsbenchmark_master_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_master_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    for (int i = 0; i < prodconsbenchmark_master_self->numWorkers; i++) {
        prodconsbenchmark_master_self->___reaction_1.output_produced[0 + i]
                = &prodconsbenchmark_master_self->__outWorkers[i].is_present
                ;
    }
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_master_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_master_self->___reaction_2.num_outputs > 0) {
        prodconsbenchmark_master_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_master_self->___reaction_2.num_outputs);
        prodconsbenchmark_master_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_master_self->___reaction_2.num_outputs);
        prodconsbenchmark_master_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_master_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_master_self->___reaction_2.output_produced[0]
    = &prodconsbenchmark_master_self->__outFinished.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.master depends on one maximal upstream reaction.
    prodconsbenchmark_master_self->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_6);
    // Reaction 1 of ProdConsBenchmark.master depends on one maximal upstream reaction.
    prodconsbenchmark_master_self->___reaction_1.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_0);
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[0].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[0]
    trigger_t** prodconsbenchmark_master_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[0] = prodconsbenchmark_master_1_0;
    // Point to destination port ProdConsBenchmark.workers[0].inMaster's trigger struct.
    prodconsbenchmark_master_1_0[0] = &prodconsbenchmark_workers_self[0]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[1].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[1] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[1]
    trigger_t** prodconsbenchmark_master_1_1 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[1] = prodconsbenchmark_master_1_1;
    // Point to destination port ProdConsBenchmark.workers[1].inMaster's trigger struct.
    prodconsbenchmark_master_1_1[0] = &prodconsbenchmark_workers_self[1]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[2].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[2] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[2]
    trigger_t** prodconsbenchmark_master_1_2 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[2] = prodconsbenchmark_master_1_2;
    // Point to destination port ProdConsBenchmark.workers[2].inMaster's trigger struct.
    prodconsbenchmark_master_1_2[0] = &prodconsbenchmark_workers_self[2]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[3].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[3] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[3]
    trigger_t** prodconsbenchmark_master_1_3 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[3] = prodconsbenchmark_master_1_3;
    // Point to destination port ProdConsBenchmark.workers[3].inMaster's trigger struct.
    prodconsbenchmark_master_1_3[0] = &prodconsbenchmark_workers_self[3]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[4].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[4] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[4]
    trigger_t** prodconsbenchmark_master_1_4 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[4] = prodconsbenchmark_master_1_4;
    // Point to destination port ProdConsBenchmark.workers[4].inMaster's trigger struct.
    prodconsbenchmark_master_1_4[0] = &prodconsbenchmark_workers_self[4]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[5].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[5] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[5]
    trigger_t** prodconsbenchmark_master_1_5 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[5] = prodconsbenchmark_master_1_5;
    // Point to destination port ProdConsBenchmark.workers[5].inMaster's trigger struct.
    prodconsbenchmark_master_1_5[0] = &prodconsbenchmark_workers_self[5]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[6].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[6] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[6]
    trigger_t** prodconsbenchmark_master_1_6 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[6] = prodconsbenchmark_master_1_6;
    // Point to destination port ProdConsBenchmark.workers[6].inMaster's trigger struct.
    prodconsbenchmark_master_1_6[0] = &prodconsbenchmark_workers_self[6]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[7].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[7] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[7]
    trigger_t** prodconsbenchmark_master_1_7 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[7] = prodconsbenchmark_master_1_7;
    // Point to destination port ProdConsBenchmark.workers[7].inMaster's trigger struct.
    prodconsbenchmark_master_1_7[0] = &prodconsbenchmark_workers_self[7]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[8].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[8] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[8]
    trigger_t** prodconsbenchmark_master_1_8 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[8] = prodconsbenchmark_master_1_8;
    // Point to destination port ProdConsBenchmark.workers[8].inMaster's trigger struct.
    prodconsbenchmark_master_1_8[0] = &prodconsbenchmark_workers_self[8]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[9].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[9] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[9]
    trigger_t** prodconsbenchmark_master_1_9 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[9] = prodconsbenchmark_master_1_9;
    // Point to destination port ProdConsBenchmark.workers[9].inMaster's trigger struct.
    prodconsbenchmark_master_1_9[0] = &prodconsbenchmark_workers_self[9]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[10].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[10] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[10]
    trigger_t** prodconsbenchmark_master_1_10 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[10] = prodconsbenchmark_master_1_10;
    // Point to destination port ProdConsBenchmark.workers[10].inMaster's trigger struct.
    prodconsbenchmark_master_1_10[0] = &prodconsbenchmark_workers_self[10]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[11].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[11] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[11]
    trigger_t** prodconsbenchmark_master_1_11 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[11] = prodconsbenchmark_master_1_11;
    // Point to destination port ProdConsBenchmark.workers[11].inMaster's trigger struct.
    prodconsbenchmark_master_1_11[0] = &prodconsbenchmark_workers_self[11]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[12].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[12] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[12]
    trigger_t** prodconsbenchmark_master_1_12 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[12] = prodconsbenchmark_master_1_12;
    // Point to destination port ProdConsBenchmark.workers[12].inMaster's trigger struct.
    prodconsbenchmark_master_1_12[0] = &prodconsbenchmark_workers_self[12]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[13].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[13] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[13]
    trigger_t** prodconsbenchmark_master_1_13 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[13] = prodconsbenchmark_master_1_13;
    // Point to destination port ProdConsBenchmark.workers[13].inMaster's trigger struct.
    prodconsbenchmark_master_1_13[0] = &prodconsbenchmark_workers_self[13]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[14].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[14] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[14]
    trigger_t** prodconsbenchmark_master_1_14 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[14] = prodconsbenchmark_master_1_14;
    // Point to destination port ProdConsBenchmark.workers[14].inMaster's trigger struct.
    prodconsbenchmark_master_1_14[0] = &prodconsbenchmark_workers_self[14]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[15].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[15] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[15]
    trigger_t** prodconsbenchmark_master_1_15 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[15] = prodconsbenchmark_master_1_15;
    // Point to destination port ProdConsBenchmark.workers[15].inMaster's trigger struct.
    prodconsbenchmark_master_1_15[0] = &prodconsbenchmark_workers_self[15]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[16].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[16] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[16]
    trigger_t** prodconsbenchmark_master_1_16 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[16] = prodconsbenchmark_master_1_16;
    // Point to destination port ProdConsBenchmark.workers[16].inMaster's trigger struct.
    prodconsbenchmark_master_1_16[0] = &prodconsbenchmark_workers_self[16]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[17].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[17] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[17]
    trigger_t** prodconsbenchmark_master_1_17 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[17] = prodconsbenchmark_master_1_17;
    // Point to destination port ProdConsBenchmark.workers[17].inMaster's trigger struct.
    prodconsbenchmark_master_1_17[0] = &prodconsbenchmark_workers_self[17]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[18].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[18] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[18]
    trigger_t** prodconsbenchmark_master_1_18 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[18] = prodconsbenchmark_master_1_18;
    // Point to destination port ProdConsBenchmark.workers[18].inMaster's trigger struct.
    prodconsbenchmark_master_1_18[0] = &prodconsbenchmark_workers_self[18]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[19].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[19] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[19]
    trigger_t** prodconsbenchmark_master_1_19 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[19] = prodconsbenchmark_master_1_19;
    // Point to destination port ProdConsBenchmark.workers[19].inMaster's trigger struct.
    prodconsbenchmark_master_1_19[0] = &prodconsbenchmark_workers_self[19]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[20].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[20] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[20]
    trigger_t** prodconsbenchmark_master_1_20 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[20] = prodconsbenchmark_master_1_20;
    // Point to destination port ProdConsBenchmark.workers[20].inMaster's trigger struct.
    prodconsbenchmark_master_1_20[0] = &prodconsbenchmark_workers_self[20]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[21].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[21] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[21]
    trigger_t** prodconsbenchmark_master_1_21 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[21] = prodconsbenchmark_master_1_21;
    // Point to destination port ProdConsBenchmark.workers[21].inMaster's trigger struct.
    prodconsbenchmark_master_1_21[0] = &prodconsbenchmark_workers_self[21]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[22].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[22] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[22]
    trigger_t** prodconsbenchmark_master_1_22 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[22] = prodconsbenchmark_master_1_22;
    // Point to destination port ProdConsBenchmark.workers[22].inMaster's trigger struct.
    prodconsbenchmark_master_1_22[0] = &prodconsbenchmark_workers_self[22]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[23].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[23] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[23]
    trigger_t** prodconsbenchmark_master_1_23 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[23] = prodconsbenchmark_master_1_23;
    // Point to destination port ProdConsBenchmark.workers[23].inMaster's trigger struct.
    prodconsbenchmark_master_1_23[0] = &prodconsbenchmark_workers_self[23]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[24].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[24] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[24]
    trigger_t** prodconsbenchmark_master_1_24 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[24] = prodconsbenchmark_master_1_24;
    // Point to destination port ProdConsBenchmark.workers[24].inMaster's trigger struct.
    prodconsbenchmark_master_1_24[0] = &prodconsbenchmark_workers_self[24]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[25].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[25] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[25]
    trigger_t** prodconsbenchmark_master_1_25 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[25] = prodconsbenchmark_master_1_25;
    // Point to destination port ProdConsBenchmark.workers[25].inMaster's trigger struct.
    prodconsbenchmark_master_1_25[0] = &prodconsbenchmark_workers_self[25]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[26].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[26] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[26]
    trigger_t** prodconsbenchmark_master_1_26 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[26] = prodconsbenchmark_master_1_26;
    // Point to destination port ProdConsBenchmark.workers[26].inMaster's trigger struct.
    prodconsbenchmark_master_1_26[0] = &prodconsbenchmark_workers_self[26]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[27].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[27] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[27]
    trigger_t** prodconsbenchmark_master_1_27 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[27] = prodconsbenchmark_master_1_27;
    // Point to destination port ProdConsBenchmark.workers[27].inMaster's trigger struct.
    prodconsbenchmark_master_1_27[0] = &prodconsbenchmark_workers_self[27]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[28].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[28] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[28]
    trigger_t** prodconsbenchmark_master_1_28 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[28] = prodconsbenchmark_master_1_28;
    // Point to destination port ProdConsBenchmark.workers[28].inMaster's trigger struct.
    prodconsbenchmark_master_1_28[0] = &prodconsbenchmark_workers_self[28]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[29].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[29] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[29]
    trigger_t** prodconsbenchmark_master_1_29 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[29] = prodconsbenchmark_master_1_29;
    // Point to destination port ProdConsBenchmark.workers[29].inMaster's trigger struct.
    prodconsbenchmark_master_1_29[0] = &prodconsbenchmark_workers_self[29]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[30].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[30] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[30]
    trigger_t** prodconsbenchmark_master_1_30 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[30] = prodconsbenchmark_master_1_30;
    // Point to destination port ProdConsBenchmark.workers[30].inMaster's trigger struct.
    prodconsbenchmark_master_1_30[0] = &prodconsbenchmark_workers_self[30]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[31].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[31] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[31]
    trigger_t** prodconsbenchmark_master_1_31 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[31] = prodconsbenchmark_master_1_31;
    // Point to destination port ProdConsBenchmark.workers[31].inMaster's trigger struct.
    prodconsbenchmark_master_1_31[0] = &prodconsbenchmark_workers_self[31]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[32].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[32] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[32]
    trigger_t** prodconsbenchmark_master_1_32 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[32] = prodconsbenchmark_master_1_32;
    // Point to destination port ProdConsBenchmark.workers[32].inMaster's trigger struct.
    prodconsbenchmark_master_1_32[0] = &prodconsbenchmark_workers_self[32]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[33].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[33] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[33]
    trigger_t** prodconsbenchmark_master_1_33 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[33] = prodconsbenchmark_master_1_33;
    // Point to destination port ProdConsBenchmark.workers[33].inMaster's trigger struct.
    prodconsbenchmark_master_1_33[0] = &prodconsbenchmark_workers_self[33]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[34].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[34] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[34]
    trigger_t** prodconsbenchmark_master_1_34 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[34] = prodconsbenchmark_master_1_34;
    // Point to destination port ProdConsBenchmark.workers[34].inMaster's trigger struct.
    prodconsbenchmark_master_1_34[0] = &prodconsbenchmark_workers_self[34]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[35].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[35] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[35]
    trigger_t** prodconsbenchmark_master_1_35 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[35] = prodconsbenchmark_master_1_35;
    // Point to destination port ProdConsBenchmark.workers[35].inMaster's trigger struct.
    prodconsbenchmark_master_1_35[0] = &prodconsbenchmark_workers_self[35]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[36].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[36] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[36]
    trigger_t** prodconsbenchmark_master_1_36 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[36] = prodconsbenchmark_master_1_36;
    // Point to destination port ProdConsBenchmark.workers[36].inMaster's trigger struct.
    prodconsbenchmark_master_1_36[0] = &prodconsbenchmark_workers_self[36]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[37].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[37] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[37]
    trigger_t** prodconsbenchmark_master_1_37 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[37] = prodconsbenchmark_master_1_37;
    // Point to destination port ProdConsBenchmark.workers[37].inMaster's trigger struct.
    prodconsbenchmark_master_1_37[0] = &prodconsbenchmark_workers_self[37]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[38].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[38] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[38]
    trigger_t** prodconsbenchmark_master_1_38 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[38] = prodconsbenchmark_master_1_38;
    // Point to destination port ProdConsBenchmark.workers[38].inMaster's trigger struct.
    prodconsbenchmark_master_1_38[0] = &prodconsbenchmark_workers_self[38]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[39].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[39] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[39]
    trigger_t** prodconsbenchmark_master_1_39 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[39] = prodconsbenchmark_master_1_39;
    // Point to destination port ProdConsBenchmark.workers[39].inMaster's trigger struct.
    prodconsbenchmark_master_1_39[0] = &prodconsbenchmark_workers_self[39]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[40].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[40] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[40]
    trigger_t** prodconsbenchmark_master_1_40 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[40] = prodconsbenchmark_master_1_40;
    // Point to destination port ProdConsBenchmark.workers[40].inMaster's trigger struct.
    prodconsbenchmark_master_1_40[0] = &prodconsbenchmark_workers_self[40]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[41].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[41] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[41]
    trigger_t** prodconsbenchmark_master_1_41 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[41] = prodconsbenchmark_master_1_41;
    // Point to destination port ProdConsBenchmark.workers[41].inMaster's trigger struct.
    prodconsbenchmark_master_1_41[0] = &prodconsbenchmark_workers_self[41]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[42].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[42] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[42]
    trigger_t** prodconsbenchmark_master_1_42 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[42] = prodconsbenchmark_master_1_42;
    // Point to destination port ProdConsBenchmark.workers[42].inMaster's trigger struct.
    prodconsbenchmark_master_1_42[0] = &prodconsbenchmark_workers_self[42]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[43].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[43] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[43]
    trigger_t** prodconsbenchmark_master_1_43 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[43] = prodconsbenchmark_master_1_43;
    // Point to destination port ProdConsBenchmark.workers[43].inMaster's trigger struct.
    prodconsbenchmark_master_1_43[0] = &prodconsbenchmark_workers_self[43]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[44].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[44] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[44]
    trigger_t** prodconsbenchmark_master_1_44 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[44] = prodconsbenchmark_master_1_44;
    // Point to destination port ProdConsBenchmark.workers[44].inMaster's trigger struct.
    prodconsbenchmark_master_1_44[0] = &prodconsbenchmark_workers_self[44]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[45].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[45] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[45]
    trigger_t** prodconsbenchmark_master_1_45 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[45] = prodconsbenchmark_master_1_45;
    // Point to destination port ProdConsBenchmark.workers[45].inMaster's trigger struct.
    prodconsbenchmark_master_1_45[0] = &prodconsbenchmark_workers_self[45]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[46].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[46] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[46]
    trigger_t** prodconsbenchmark_master_1_46 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[46] = prodconsbenchmark_master_1_46;
    // Point to destination port ProdConsBenchmark.workers[46].inMaster's trigger struct.
    prodconsbenchmark_master_1_46[0] = &prodconsbenchmark_workers_self[46]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[47].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[47] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[47]
    trigger_t** prodconsbenchmark_master_1_47 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[47] = prodconsbenchmark_master_1_47;
    // Point to destination port ProdConsBenchmark.workers[47].inMaster's trigger struct.
    prodconsbenchmark_master_1_47[0] = &prodconsbenchmark_workers_self[47]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[48].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[48] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[48]
    trigger_t** prodconsbenchmark_master_1_48 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[48] = prodconsbenchmark_master_1_48;
    // Point to destination port ProdConsBenchmark.workers[48].inMaster's trigger struct.
    prodconsbenchmark_master_1_48[0] = &prodconsbenchmark_workers_self[48]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[49].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[49] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[49]
    trigger_t** prodconsbenchmark_master_1_49 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[49] = prodconsbenchmark_master_1_49;
    // Point to destination port ProdConsBenchmark.workers[49].inMaster's trigger struct.
    prodconsbenchmark_master_1_49[0] = &prodconsbenchmark_workers_self[49]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[50].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[50] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[50]
    trigger_t** prodconsbenchmark_master_1_50 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[50] = prodconsbenchmark_master_1_50;
    // Point to destination port ProdConsBenchmark.workers[50].inMaster's trigger struct.
    prodconsbenchmark_master_1_50[0] = &prodconsbenchmark_workers_self[50]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[51].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[51] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[51]
    trigger_t** prodconsbenchmark_master_1_51 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[51] = prodconsbenchmark_master_1_51;
    // Point to destination port ProdConsBenchmark.workers[51].inMaster's trigger struct.
    prodconsbenchmark_master_1_51[0] = &prodconsbenchmark_workers_self[51]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[52].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[52] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[52]
    trigger_t** prodconsbenchmark_master_1_52 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[52] = prodconsbenchmark_master_1_52;
    // Point to destination port ProdConsBenchmark.workers[52].inMaster's trigger struct.
    prodconsbenchmark_master_1_52[0] = &prodconsbenchmark_workers_self[52]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[53].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[53] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[53]
    trigger_t** prodconsbenchmark_master_1_53 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[53] = prodconsbenchmark_master_1_53;
    // Point to destination port ProdConsBenchmark.workers[53].inMaster's trigger struct.
    prodconsbenchmark_master_1_53[0] = &prodconsbenchmark_workers_self[53]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[54].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[54] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[54]
    trigger_t** prodconsbenchmark_master_1_54 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[54] = prodconsbenchmark_master_1_54;
    // Point to destination port ProdConsBenchmark.workers[54].inMaster's trigger struct.
    prodconsbenchmark_master_1_54[0] = &prodconsbenchmark_workers_self[54]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[55].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[55] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[55]
    trigger_t** prodconsbenchmark_master_1_55 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[55] = prodconsbenchmark_master_1_55;
    // Point to destination port ProdConsBenchmark.workers[55].inMaster's trigger struct.
    prodconsbenchmark_master_1_55[0] = &prodconsbenchmark_workers_self[55]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[56].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[56] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[56]
    trigger_t** prodconsbenchmark_master_1_56 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[56] = prodconsbenchmark_master_1_56;
    // Point to destination port ProdConsBenchmark.workers[56].inMaster's trigger struct.
    prodconsbenchmark_master_1_56[0] = &prodconsbenchmark_workers_self[56]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[57].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[57] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[57]
    trigger_t** prodconsbenchmark_master_1_57 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[57] = prodconsbenchmark_master_1_57;
    // Point to destination port ProdConsBenchmark.workers[57].inMaster's trigger struct.
    prodconsbenchmark_master_1_57[0] = &prodconsbenchmark_workers_self[57]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[58].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[58] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[58]
    trigger_t** prodconsbenchmark_master_1_58 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[58] = prodconsbenchmark_master_1_58;
    // Point to destination port ProdConsBenchmark.workers[58].inMaster's trigger struct.
    prodconsbenchmark_master_1_58[0] = &prodconsbenchmark_workers_self[58]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[59].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[59] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[59]
    trigger_t** prodconsbenchmark_master_1_59 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[59] = prodconsbenchmark_master_1_59;
    // Point to destination port ProdConsBenchmark.workers[59].inMaster's trigger struct.
    prodconsbenchmark_master_1_59[0] = &prodconsbenchmark_workers_self[59]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[60].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[60] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[60]
    trigger_t** prodconsbenchmark_master_1_60 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[60] = prodconsbenchmark_master_1_60;
    // Point to destination port ProdConsBenchmark.workers[60].inMaster's trigger struct.
    prodconsbenchmark_master_1_60[0] = &prodconsbenchmark_workers_self[60]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[61].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[61] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[61]
    trigger_t** prodconsbenchmark_master_1_61 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[61] = prodconsbenchmark_master_1_61;
    // Point to destination port ProdConsBenchmark.workers[61].inMaster's trigger struct.
    prodconsbenchmark_master_1_61[0] = &prodconsbenchmark_workers_self[61]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[62].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[62] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[62]
    trigger_t** prodconsbenchmark_master_1_62 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[62] = prodconsbenchmark_master_1_62;
    // Point to destination port ProdConsBenchmark.workers[62].inMaster's trigger struct.
    prodconsbenchmark_master_1_62[0] = &prodconsbenchmark_workers_self[62]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[63].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[63] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[63]
    trigger_t** prodconsbenchmark_master_1_63 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[63] = prodconsbenchmark_master_1_63;
    // Point to destination port ProdConsBenchmark.workers[63].inMaster's trigger struct.
    prodconsbenchmark_master_1_63[0] = &prodconsbenchmark_workers_self[63]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[64].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[64] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[64]
    trigger_t** prodconsbenchmark_master_1_64 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[64] = prodconsbenchmark_master_1_64;
    // Point to destination port ProdConsBenchmark.workers[64].inMaster's trigger struct.
    prodconsbenchmark_master_1_64[0] = &prodconsbenchmark_workers_self[64]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[65].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[65] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[65]
    trigger_t** prodconsbenchmark_master_1_65 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[65] = prodconsbenchmark_master_1_65;
    // Point to destination port ProdConsBenchmark.workers[65].inMaster's trigger struct.
    prodconsbenchmark_master_1_65[0] = &prodconsbenchmark_workers_self[65]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[66].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[66] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[66]
    trigger_t** prodconsbenchmark_master_1_66 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[66] = prodconsbenchmark_master_1_66;
    // Point to destination port ProdConsBenchmark.workers[66].inMaster's trigger struct.
    prodconsbenchmark_master_1_66[0] = &prodconsbenchmark_workers_self[66]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[67].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[67] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[67]
    trigger_t** prodconsbenchmark_master_1_67 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[67] = prodconsbenchmark_master_1_67;
    // Point to destination port ProdConsBenchmark.workers[67].inMaster's trigger struct.
    prodconsbenchmark_master_1_67[0] = &prodconsbenchmark_workers_self[67]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[68].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[68] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[68]
    trigger_t** prodconsbenchmark_master_1_68 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[68] = prodconsbenchmark_master_1_68;
    // Point to destination port ProdConsBenchmark.workers[68].inMaster's trigger struct.
    prodconsbenchmark_master_1_68[0] = &prodconsbenchmark_workers_self[68]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[69].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[69] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[69]
    trigger_t** prodconsbenchmark_master_1_69 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[69] = prodconsbenchmark_master_1_69;
    // Point to destination port ProdConsBenchmark.workers[69].inMaster's trigger struct.
    prodconsbenchmark_master_1_69[0] = &prodconsbenchmark_workers_self[69]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[70].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[70] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[70]
    trigger_t** prodconsbenchmark_master_1_70 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[70] = prodconsbenchmark_master_1_70;
    // Point to destination port ProdConsBenchmark.workers[70].inMaster's trigger struct.
    prodconsbenchmark_master_1_70[0] = &prodconsbenchmark_workers_self[70]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[71].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[71] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[71]
    trigger_t** prodconsbenchmark_master_1_71 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[71] = prodconsbenchmark_master_1_71;
    // Point to destination port ProdConsBenchmark.workers[71].inMaster's trigger struct.
    prodconsbenchmark_master_1_71[0] = &prodconsbenchmark_workers_self[71]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[72].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[72] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[72]
    trigger_t** prodconsbenchmark_master_1_72 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[72] = prodconsbenchmark_master_1_72;
    // Point to destination port ProdConsBenchmark.workers[72].inMaster's trigger struct.
    prodconsbenchmark_master_1_72[0] = &prodconsbenchmark_workers_self[72]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[73].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[73] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[73]
    trigger_t** prodconsbenchmark_master_1_73 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[73] = prodconsbenchmark_master_1_73;
    // Point to destination port ProdConsBenchmark.workers[73].inMaster's trigger struct.
    prodconsbenchmark_master_1_73[0] = &prodconsbenchmark_workers_self[73]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[74].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[74] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[74]
    trigger_t** prodconsbenchmark_master_1_74 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[74] = prodconsbenchmark_master_1_74;
    // Point to destination port ProdConsBenchmark.workers[74].inMaster's trigger struct.
    prodconsbenchmark_master_1_74[0] = &prodconsbenchmark_workers_self[74]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[75].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[75] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[75]
    trigger_t** prodconsbenchmark_master_1_75 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[75] = prodconsbenchmark_master_1_75;
    // Point to destination port ProdConsBenchmark.workers[75].inMaster's trigger struct.
    prodconsbenchmark_master_1_75[0] = &prodconsbenchmark_workers_self[75]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[76].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[76] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[76]
    trigger_t** prodconsbenchmark_master_1_76 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[76] = prodconsbenchmark_master_1_76;
    // Point to destination port ProdConsBenchmark.workers[76].inMaster's trigger struct.
    prodconsbenchmark_master_1_76[0] = &prodconsbenchmark_workers_self[76]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[77].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[77] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[77]
    trigger_t** prodconsbenchmark_master_1_77 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[77] = prodconsbenchmark_master_1_77;
    // Point to destination port ProdConsBenchmark.workers[77].inMaster's trigger struct.
    prodconsbenchmark_master_1_77[0] = &prodconsbenchmark_workers_self[77]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[78].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[78] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[78]
    trigger_t** prodconsbenchmark_master_1_78 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[78] = prodconsbenchmark_master_1_78;
    // Point to destination port ProdConsBenchmark.workers[78].inMaster's trigger struct.
    prodconsbenchmark_master_1_78[0] = &prodconsbenchmark_workers_self[78]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[79].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[79] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[79]
    trigger_t** prodconsbenchmark_master_1_79 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[79] = prodconsbenchmark_master_1_79;
    // Point to destination port ProdConsBenchmark.workers[79].inMaster's trigger struct.
    prodconsbenchmark_master_1_79[0] = &prodconsbenchmark_workers_self[79]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[80].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[80] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[80]
    trigger_t** prodconsbenchmark_master_1_80 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[80] = prodconsbenchmark_master_1_80;
    // Point to destination port ProdConsBenchmark.workers[80].inMaster's trigger struct.
    prodconsbenchmark_master_1_80[0] = &prodconsbenchmark_workers_self[80]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[81].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[81] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[81]
    trigger_t** prodconsbenchmark_master_1_81 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[81] = prodconsbenchmark_master_1_81;
    // Point to destination port ProdConsBenchmark.workers[81].inMaster's trigger struct.
    prodconsbenchmark_master_1_81[0] = &prodconsbenchmark_workers_self[81]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[82].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[82] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[82]
    trigger_t** prodconsbenchmark_master_1_82 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[82] = prodconsbenchmark_master_1_82;
    // Point to destination port ProdConsBenchmark.workers[82].inMaster's trigger struct.
    prodconsbenchmark_master_1_82[0] = &prodconsbenchmark_workers_self[82]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[83].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[83] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[83]
    trigger_t** prodconsbenchmark_master_1_83 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[83] = prodconsbenchmark_master_1_83;
    // Point to destination port ProdConsBenchmark.workers[83].inMaster's trigger struct.
    prodconsbenchmark_master_1_83[0] = &prodconsbenchmark_workers_self[83]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[84].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[84] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[84]
    trigger_t** prodconsbenchmark_master_1_84 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[84] = prodconsbenchmark_master_1_84;
    // Point to destination port ProdConsBenchmark.workers[84].inMaster's trigger struct.
    prodconsbenchmark_master_1_84[0] = &prodconsbenchmark_workers_self[84]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[85].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[85] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[85]
    trigger_t** prodconsbenchmark_master_1_85 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[85] = prodconsbenchmark_master_1_85;
    // Point to destination port ProdConsBenchmark.workers[85].inMaster's trigger struct.
    prodconsbenchmark_master_1_85[0] = &prodconsbenchmark_workers_self[85]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[86].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[86] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[86]
    trigger_t** prodconsbenchmark_master_1_86 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[86] = prodconsbenchmark_master_1_86;
    // Point to destination port ProdConsBenchmark.workers[86].inMaster's trigger struct.
    prodconsbenchmark_master_1_86[0] = &prodconsbenchmark_workers_self[86]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[87].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[87] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[87]
    trigger_t** prodconsbenchmark_master_1_87 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[87] = prodconsbenchmark_master_1_87;
    // Point to destination port ProdConsBenchmark.workers[87].inMaster's trigger struct.
    prodconsbenchmark_master_1_87[0] = &prodconsbenchmark_workers_self[87]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[88].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[88] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[88]
    trigger_t** prodconsbenchmark_master_1_88 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[88] = prodconsbenchmark_master_1_88;
    // Point to destination port ProdConsBenchmark.workers[88].inMaster's trigger struct.
    prodconsbenchmark_master_1_88[0] = &prodconsbenchmark_workers_self[88]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[89].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[89] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[89]
    trigger_t** prodconsbenchmark_master_1_89 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[89] = prodconsbenchmark_master_1_89;
    // Point to destination port ProdConsBenchmark.workers[89].inMaster's trigger struct.
    prodconsbenchmark_master_1_89[0] = &prodconsbenchmark_workers_self[89]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[90].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[90] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[90]
    trigger_t** prodconsbenchmark_master_1_90 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[90] = prodconsbenchmark_master_1_90;
    // Point to destination port ProdConsBenchmark.workers[90].inMaster's trigger struct.
    prodconsbenchmark_master_1_90[0] = &prodconsbenchmark_workers_self[90]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[91].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[91] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[91]
    trigger_t** prodconsbenchmark_master_1_91 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[91] = prodconsbenchmark_master_1_91;
    // Point to destination port ProdConsBenchmark.workers[91].inMaster's trigger struct.
    prodconsbenchmark_master_1_91[0] = &prodconsbenchmark_workers_self[91]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[92].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[92] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[92]
    trigger_t** prodconsbenchmark_master_1_92 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[92] = prodconsbenchmark_master_1_92;
    // Point to destination port ProdConsBenchmark.workers[92].inMaster's trigger struct.
    prodconsbenchmark_master_1_92[0] = &prodconsbenchmark_workers_self[92]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[93].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[93] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[93]
    trigger_t** prodconsbenchmark_master_1_93 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[93] = prodconsbenchmark_master_1_93;
    // Point to destination port ProdConsBenchmark.workers[93].inMaster's trigger struct.
    prodconsbenchmark_master_1_93[0] = &prodconsbenchmark_workers_self[93]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[94].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[94] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[94]
    trigger_t** prodconsbenchmark_master_1_94 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[94] = prodconsbenchmark_master_1_94;
    // Point to destination port ProdConsBenchmark.workers[94].inMaster's trigger struct.
    prodconsbenchmark_master_1_94[0] = &prodconsbenchmark_workers_self[94]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[95].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[95] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[95]
    trigger_t** prodconsbenchmark_master_1_95 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[95] = prodconsbenchmark_master_1_95;
    // Point to destination port ProdConsBenchmark.workers[95].inMaster's trigger struct.
    prodconsbenchmark_master_1_95[0] = &prodconsbenchmark_workers_self[95]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[96].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[96] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[96]
    trigger_t** prodconsbenchmark_master_1_96 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[96] = prodconsbenchmark_master_1_96;
    // Point to destination port ProdConsBenchmark.workers[96].inMaster's trigger struct.
    prodconsbenchmark_master_1_96[0] = &prodconsbenchmark_workers_self[96]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[97].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[97] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[97]
    trigger_t** prodconsbenchmark_master_1_97 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[97] = prodconsbenchmark_master_1_97;
    // Point to destination port ProdConsBenchmark.workers[97].inMaster's trigger struct.
    prodconsbenchmark_master_1_97[0] = &prodconsbenchmark_workers_self[97]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[98].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[98] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[98]
    trigger_t** prodconsbenchmark_master_1_98 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[98] = prodconsbenchmark_master_1_98;
    // Point to destination port ProdConsBenchmark.workers[98].inMaster's trigger struct.
    prodconsbenchmark_master_1_98[0] = &prodconsbenchmark_workers_self[98]->___inMaster;
    // Reaction 1 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outWorkers[99].
    prodconsbenchmark_master_self->___reaction_1.triggered_sizes[99] = 1;
    // For reaction 1 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outWorkers[99]
    trigger_t** prodconsbenchmark_master_1_99 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_1.triggers[99] = prodconsbenchmark_master_1_99;
    // Point to destination port ProdConsBenchmark.workers[99].inMaster's trigger struct.
    prodconsbenchmark_master_1_99[0] = &prodconsbenchmark_workers_self[99]->___inMaster;
    // Reaction 2 of ProdConsBenchmark.master does not depend on one maximal upstream reaction.
    prodconsbenchmark_master_self->___reaction_2.last_enabling_reaction = NULL;
    // Reaction 2 of ProdConsBenchmark.master triggers 1 downstream reactions through port ProdConsBenchmark.master.outFinished.
    prodconsbenchmark_master_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of ProdConsBenchmark.master, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.master.outFinished
    trigger_t** prodconsbenchmark_master_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_master_self->___reaction_2.triggers[0] = prodconsbenchmark_master_2_0;
    // Point to destination port ProdConsBenchmark.runner.inIterationFinish's trigger struct.
    prodconsbenchmark_master_2_0[0] = &prodconsbenchmark_runner_self->___inIterationFinish;
    prodconsbenchmark_master_self->__outFinished.num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[0].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[1].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[2].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[3].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[4].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[5].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[6].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[7].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[8].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[9].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[10].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[11].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[12].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[13].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[14].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[15].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[16].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[17].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[18].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[19].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[20].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[21].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[22].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[23].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[24].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[25].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[26].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[27].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[28].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[29].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[30].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[31].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[32].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[33].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[34].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[35].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[36].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[37].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[38].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[39].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[40].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[41].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[42].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[43].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[44].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[45].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[46].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[47].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[48].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[49].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[50].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[51].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[52].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[53].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[54].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[55].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[56].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[57].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[58].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[59].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[60].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[61].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[62].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[63].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[64].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[65].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[66].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[67].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[68].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[69].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[70].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[71].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[72].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[73].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[74].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[75].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[76].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[77].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[78].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[79].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[80].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[81].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[82].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[83].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[84].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[85].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[86].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[87].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[88].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[89].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[90].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[91].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[92].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[93].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[94].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[95].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[96].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[97].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[98].num_destinations
    = 1;
    prodconsbenchmark_master_self->__outWorkers[99].num_destinations
    = 1;
    prodconsbenchmark_runner_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_0.num_outputs);
        prodconsbenchmark_runner_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_0.num_outputs);
        prodconsbenchmark_runner_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_1.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_1.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_1.num_outputs);
        prodconsbenchmark_runner_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_1.num_outputs);
        prodconsbenchmark_runner_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_2.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_2.num_outputs);
        prodconsbenchmark_runner_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_2.num_outputs);
        prodconsbenchmark_runner_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_runner_self->___reaction_2.output_produced[0]
    = &prodconsbenchmark_runner_self->__outInitializeStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_3.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_3.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_3.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_3.num_outputs);
        prodconsbenchmark_runner_self->___reaction_3.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_3.num_outputs);
        prodconsbenchmark_runner_self->___reaction_3.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_3.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_4.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_4.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_4.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_4.num_outputs);
        prodconsbenchmark_runner_self->___reaction_4.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_4.num_outputs);
        prodconsbenchmark_runner_self->___reaction_4.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_4.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_runner_self->___reaction_4.output_produced[0]
    = &prodconsbenchmark_runner_self->__outCleanupIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_5.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_5.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_5.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_5.num_outputs);
        prodconsbenchmark_runner_self->___reaction_5.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_5.num_outputs);
        prodconsbenchmark_runner_self->___reaction_5.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_5.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_6.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_6.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_6.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_6.num_outputs);
        prodconsbenchmark_runner_self->___reaction_6.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_6.num_outputs);
        prodconsbenchmark_runner_self->___reaction_6.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_6.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_runner_self->___reaction_6.output_produced[0]
    = &prodconsbenchmark_runner_self->__outIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_7.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_7.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_7.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_7.num_outputs);
        prodconsbenchmark_runner_self->___reaction_7.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_7.num_outputs);
        prodconsbenchmark_runner_self->___reaction_7.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_7.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_runner_self->___reaction_8.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_runner_self->___reaction_8.num_outputs > 0) {
        prodconsbenchmark_runner_self->___reaction_8.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_runner_self->___reaction_8.num_outputs);
        prodconsbenchmark_runner_self->___reaction_8.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_runner_self->___reaction_8.num_outputs);
        prodconsbenchmark_runner_self->___reaction_8.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_runner_self->___reaction_8.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProdConsBenchmark.runner does not depend on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of ProdConsBenchmark.runner does not depend on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 2 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_2.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_1);
    // Reaction 2 of ProdConsBenchmark.runner triggers 0 downstream reactions through port ProdConsBenchmark.runner.outInitializeStart.
    prodconsbenchmark_runner_self->___reaction_2.triggered_sizes[0] = 0;
    // Reaction 3 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_3.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_2);
    // Reaction 4 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_4.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_3);
    // Reaction 4 of ProdConsBenchmark.runner triggers 0 downstream reactions through port ProdConsBenchmark.runner.outCleanupIterationStart.
    prodconsbenchmark_runner_self->___reaction_4.triggered_sizes[0] = 0;
    // Reaction 5 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_5.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_4);
    // Reaction 6 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_6.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_5);
    // Reaction 6 of ProdConsBenchmark.runner triggers 1 downstream reactions through port ProdConsBenchmark.runner.outIterationStart.
    prodconsbenchmark_runner_self->___reaction_6.triggered_sizes[0] = 1;
    // For reaction 6 of ProdConsBenchmark.runner, allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.runner.outIterationStart
    trigger_t** prodconsbenchmark_runner_6_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_runner_self->___reaction_6.triggers[0] = prodconsbenchmark_runner_6_0;
    // Point to destination port ProdConsBenchmark.master.inStart's trigger struct.
    prodconsbenchmark_runner_6_0[0] = &prodconsbenchmark_master_self->___inStart;
    // Reaction 7 of ProdConsBenchmark.runner does not depend on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_7.last_enabling_reaction = NULL;
    // Reaction 8 of ProdConsBenchmark.runner depends on one maximal upstream reaction.
    prodconsbenchmark_runner_self->___reaction_8.last_enabling_reaction = &(prodconsbenchmark_runner_self->___reaction_7);
    prodconsbenchmark_runner_self->__outIterationStart.num_destinations
    = 1;
    prodconsbenchmark_runner_self->__outInitializeStart.num_destinations
    = 0;
    prodconsbenchmark_runner_self->__outCleanupIterationStart.num_destinations
    = 0;
    prodconsbenchmark_workers_self[0]->bank_index = 0;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[0]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[0]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[0]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[0]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[0]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[0]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[0]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[0]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[0]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[0]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[0] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[0]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[0] triggers 1 downstream reactions through port ProdConsBenchmark.workers[0].outMaster.
    prodconsbenchmark_workers_self[0]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[0], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[0].outMaster
    trigger_t** prodconsbenchmark_workers_0__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[0]->___reaction_0.triggers[0] = prodconsbenchmark_workers_0__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[0]'s trigger struct.
    prodconsbenchmark_workers_0__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[0]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[1]->bank_index = 1;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[1]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[1]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[1]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[1]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[1]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[1]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[1]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[1]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[1]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[1]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[1] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[1]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[1] triggers 1 downstream reactions through port ProdConsBenchmark.workers[1].outMaster.
    prodconsbenchmark_workers_self[1]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[1], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[1].outMaster
    trigger_t** prodconsbenchmark_workers_1__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[1]->___reaction_0.triggers[0] = prodconsbenchmark_workers_1__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[1]'s trigger struct.
    prodconsbenchmark_workers_1__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[1]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[2]->bank_index = 2;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[2]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[2]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[2]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[2]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[2]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[2]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[2]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[2]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[2]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[2]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[2] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[2]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[2] triggers 1 downstream reactions through port ProdConsBenchmark.workers[2].outMaster.
    prodconsbenchmark_workers_self[2]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[2], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[2].outMaster
    trigger_t** prodconsbenchmark_workers_2__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[2]->___reaction_0.triggers[0] = prodconsbenchmark_workers_2__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[2]'s trigger struct.
    prodconsbenchmark_workers_2__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[2]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[3]->bank_index = 3;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[3]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[3]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[3]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[3]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[3]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[3]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[3]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[3]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[3]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[3]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[3] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[3]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[3] triggers 1 downstream reactions through port ProdConsBenchmark.workers[3].outMaster.
    prodconsbenchmark_workers_self[3]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[3], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[3].outMaster
    trigger_t** prodconsbenchmark_workers_3__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[3]->___reaction_0.triggers[0] = prodconsbenchmark_workers_3__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[3]'s trigger struct.
    prodconsbenchmark_workers_3__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[3]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[4]->bank_index = 4;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[4]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[4]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[4]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[4]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[4]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[4]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[4]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[4]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[4]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[4]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[4] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[4]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[4] triggers 1 downstream reactions through port ProdConsBenchmark.workers[4].outMaster.
    prodconsbenchmark_workers_self[4]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[4], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[4].outMaster
    trigger_t** prodconsbenchmark_workers_4__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[4]->___reaction_0.triggers[0] = prodconsbenchmark_workers_4__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[4]'s trigger struct.
    prodconsbenchmark_workers_4__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[4]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[5]->bank_index = 5;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[5]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[5]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[5]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[5]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[5]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[5]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[5]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[5]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[5]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[5]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[5] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[5]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[5] triggers 1 downstream reactions through port ProdConsBenchmark.workers[5].outMaster.
    prodconsbenchmark_workers_self[5]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[5], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[5].outMaster
    trigger_t** prodconsbenchmark_workers_5__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[5]->___reaction_0.triggers[0] = prodconsbenchmark_workers_5__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[5]'s trigger struct.
    prodconsbenchmark_workers_5__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[5]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[6]->bank_index = 6;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[6]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[6]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[6]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[6]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[6]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[6]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[6]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[6]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[6]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[6]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[6] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[6]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[6] triggers 1 downstream reactions through port ProdConsBenchmark.workers[6].outMaster.
    prodconsbenchmark_workers_self[6]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[6], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[6].outMaster
    trigger_t** prodconsbenchmark_workers_6__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[6]->___reaction_0.triggers[0] = prodconsbenchmark_workers_6__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[6]'s trigger struct.
    prodconsbenchmark_workers_6__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[6]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[7]->bank_index = 7;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[7]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[7]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[7]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[7]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[7]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[7]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[7]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[7]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[7]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[7]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[7] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[7]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[7] triggers 1 downstream reactions through port ProdConsBenchmark.workers[7].outMaster.
    prodconsbenchmark_workers_self[7]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[7], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[7].outMaster
    trigger_t** prodconsbenchmark_workers_7__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[7]->___reaction_0.triggers[0] = prodconsbenchmark_workers_7__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[7]'s trigger struct.
    prodconsbenchmark_workers_7__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[7]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[8]->bank_index = 8;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[8]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[8]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[8]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[8]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[8]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[8]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[8]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[8]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[8]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[8]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[8] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[8]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[8] triggers 1 downstream reactions through port ProdConsBenchmark.workers[8].outMaster.
    prodconsbenchmark_workers_self[8]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[8], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[8].outMaster
    trigger_t** prodconsbenchmark_workers_8__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[8]->___reaction_0.triggers[0] = prodconsbenchmark_workers_8__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[8]'s trigger struct.
    prodconsbenchmark_workers_8__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[8]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[9]->bank_index = 9;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[9]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[9]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[9]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[9]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[9]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[9]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[9]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[9]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[9]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[9]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[9] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[9]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[9] triggers 1 downstream reactions through port ProdConsBenchmark.workers[9].outMaster.
    prodconsbenchmark_workers_self[9]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[9], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[9].outMaster
    trigger_t** prodconsbenchmark_workers_9__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[9]->___reaction_0.triggers[0] = prodconsbenchmark_workers_9__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[9]'s trigger struct.
    prodconsbenchmark_workers_9__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[9]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[10]->bank_index = 10;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[10]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[10]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[10]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[10]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[10]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[10]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[10]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[10]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[10]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[10]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[10] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[10]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[10] triggers 1 downstream reactions through port ProdConsBenchmark.workers[10].outMaster.
    prodconsbenchmark_workers_self[10]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[10], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[10].outMaster
    trigger_t** prodconsbenchmark_workers_10__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[10]->___reaction_0.triggers[0] = prodconsbenchmark_workers_10__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[10]'s trigger struct.
    prodconsbenchmark_workers_10__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[10]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[11]->bank_index = 11;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[11]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[11]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[11]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[11]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[11]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[11]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[11]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[11]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[11]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[11]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[11] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[11]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[11] triggers 1 downstream reactions through port ProdConsBenchmark.workers[11].outMaster.
    prodconsbenchmark_workers_self[11]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[11], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[11].outMaster
    trigger_t** prodconsbenchmark_workers_11__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[11]->___reaction_0.triggers[0] = prodconsbenchmark_workers_11__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[11]'s trigger struct.
    prodconsbenchmark_workers_11__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[11]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[12]->bank_index = 12;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[12]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[12]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[12]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[12]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[12]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[12]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[12]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[12]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[12]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[12]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[12] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[12]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[12] triggers 1 downstream reactions through port ProdConsBenchmark.workers[12].outMaster.
    prodconsbenchmark_workers_self[12]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[12], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[12].outMaster
    trigger_t** prodconsbenchmark_workers_12__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[12]->___reaction_0.triggers[0] = prodconsbenchmark_workers_12__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[12]'s trigger struct.
    prodconsbenchmark_workers_12__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[12]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[13]->bank_index = 13;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[13]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[13]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[13]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[13]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[13]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[13]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[13]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[13]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[13]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[13]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[13] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[13]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[13] triggers 1 downstream reactions through port ProdConsBenchmark.workers[13].outMaster.
    prodconsbenchmark_workers_self[13]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[13], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[13].outMaster
    trigger_t** prodconsbenchmark_workers_13__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[13]->___reaction_0.triggers[0] = prodconsbenchmark_workers_13__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[13]'s trigger struct.
    prodconsbenchmark_workers_13__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[13]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[14]->bank_index = 14;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[14]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[14]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[14]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[14]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[14]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[14]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[14]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[14]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[14]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[14]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[14] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[14]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[14] triggers 1 downstream reactions through port ProdConsBenchmark.workers[14].outMaster.
    prodconsbenchmark_workers_self[14]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[14], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[14].outMaster
    trigger_t** prodconsbenchmark_workers_14__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[14]->___reaction_0.triggers[0] = prodconsbenchmark_workers_14__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[14]'s trigger struct.
    prodconsbenchmark_workers_14__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[14]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[15]->bank_index = 15;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[15]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[15]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[15]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[15]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[15]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[15]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[15]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[15]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[15]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[15]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[15] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[15]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[15] triggers 1 downstream reactions through port ProdConsBenchmark.workers[15].outMaster.
    prodconsbenchmark_workers_self[15]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[15], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[15].outMaster
    trigger_t** prodconsbenchmark_workers_15__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[15]->___reaction_0.triggers[0] = prodconsbenchmark_workers_15__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[15]'s trigger struct.
    prodconsbenchmark_workers_15__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[15]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[16]->bank_index = 16;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[16]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[16]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[16]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[16]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[16]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[16]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[16]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[16]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[16]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[16]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[16] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[16]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[16] triggers 1 downstream reactions through port ProdConsBenchmark.workers[16].outMaster.
    prodconsbenchmark_workers_self[16]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[16], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[16].outMaster
    trigger_t** prodconsbenchmark_workers_16__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[16]->___reaction_0.triggers[0] = prodconsbenchmark_workers_16__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[16]'s trigger struct.
    prodconsbenchmark_workers_16__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[16]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[17]->bank_index = 17;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[17]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[17]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[17]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[17]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[17]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[17]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[17]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[17]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[17]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[17]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[17] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[17]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[17] triggers 1 downstream reactions through port ProdConsBenchmark.workers[17].outMaster.
    prodconsbenchmark_workers_self[17]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[17], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[17].outMaster
    trigger_t** prodconsbenchmark_workers_17__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[17]->___reaction_0.triggers[0] = prodconsbenchmark_workers_17__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[17]'s trigger struct.
    prodconsbenchmark_workers_17__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[17]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[18]->bank_index = 18;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[18]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[18]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[18]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[18]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[18]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[18]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[18]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[18]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[18]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[18]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[18] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[18]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[18] triggers 1 downstream reactions through port ProdConsBenchmark.workers[18].outMaster.
    prodconsbenchmark_workers_self[18]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[18], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[18].outMaster
    trigger_t** prodconsbenchmark_workers_18__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[18]->___reaction_0.triggers[0] = prodconsbenchmark_workers_18__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[18]'s trigger struct.
    prodconsbenchmark_workers_18__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[18]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[19]->bank_index = 19;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[19]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[19]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[19]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[19]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[19]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[19]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[19]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[19]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[19]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[19]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[19] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[19]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[19] triggers 1 downstream reactions through port ProdConsBenchmark.workers[19].outMaster.
    prodconsbenchmark_workers_self[19]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[19], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[19].outMaster
    trigger_t** prodconsbenchmark_workers_19__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[19]->___reaction_0.triggers[0] = prodconsbenchmark_workers_19__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[19]'s trigger struct.
    prodconsbenchmark_workers_19__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[19]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[20]->bank_index = 20;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[20]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[20]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[20]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[20]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[20]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[20]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[20]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[20]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[20]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[20]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[20] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[20]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[20] triggers 1 downstream reactions through port ProdConsBenchmark.workers[20].outMaster.
    prodconsbenchmark_workers_self[20]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[20], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[20].outMaster
    trigger_t** prodconsbenchmark_workers_20__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[20]->___reaction_0.triggers[0] = prodconsbenchmark_workers_20__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[20]'s trigger struct.
    prodconsbenchmark_workers_20__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[20]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[21]->bank_index = 21;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[21]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[21]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[21]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[21]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[21]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[21]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[21]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[21]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[21]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[21]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[21] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[21]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[21] triggers 1 downstream reactions through port ProdConsBenchmark.workers[21].outMaster.
    prodconsbenchmark_workers_self[21]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[21], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[21].outMaster
    trigger_t** prodconsbenchmark_workers_21__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[21]->___reaction_0.triggers[0] = prodconsbenchmark_workers_21__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[21]'s trigger struct.
    prodconsbenchmark_workers_21__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[21]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[22]->bank_index = 22;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[22]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[22]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[22]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[22]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[22]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[22]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[22]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[22]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[22]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[22]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[22] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[22]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[22] triggers 1 downstream reactions through port ProdConsBenchmark.workers[22].outMaster.
    prodconsbenchmark_workers_self[22]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[22], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[22].outMaster
    trigger_t** prodconsbenchmark_workers_22__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[22]->___reaction_0.triggers[0] = prodconsbenchmark_workers_22__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[22]'s trigger struct.
    prodconsbenchmark_workers_22__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[22]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[23]->bank_index = 23;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[23]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[23]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[23]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[23]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[23]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[23]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[23]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[23]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[23]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[23]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[23] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[23]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[23] triggers 1 downstream reactions through port ProdConsBenchmark.workers[23].outMaster.
    prodconsbenchmark_workers_self[23]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[23], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[23].outMaster
    trigger_t** prodconsbenchmark_workers_23__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[23]->___reaction_0.triggers[0] = prodconsbenchmark_workers_23__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[23]'s trigger struct.
    prodconsbenchmark_workers_23__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[23]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[24]->bank_index = 24;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[24]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[24]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[24]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[24]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[24]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[24]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[24]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[24]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[24]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[24]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[24] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[24]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[24] triggers 1 downstream reactions through port ProdConsBenchmark.workers[24].outMaster.
    prodconsbenchmark_workers_self[24]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[24], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[24].outMaster
    trigger_t** prodconsbenchmark_workers_24__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[24]->___reaction_0.triggers[0] = prodconsbenchmark_workers_24__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[24]'s trigger struct.
    prodconsbenchmark_workers_24__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[24]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[25]->bank_index = 25;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[25]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[25]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[25]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[25]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[25]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[25]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[25]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[25]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[25]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[25]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[25] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[25]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[25] triggers 1 downstream reactions through port ProdConsBenchmark.workers[25].outMaster.
    prodconsbenchmark_workers_self[25]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[25], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[25].outMaster
    trigger_t** prodconsbenchmark_workers_25__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[25]->___reaction_0.triggers[0] = prodconsbenchmark_workers_25__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[25]'s trigger struct.
    prodconsbenchmark_workers_25__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[25]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[26]->bank_index = 26;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[26]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[26]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[26]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[26]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[26]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[26]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[26]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[26]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[26]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[26]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[26] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[26]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[26] triggers 1 downstream reactions through port ProdConsBenchmark.workers[26].outMaster.
    prodconsbenchmark_workers_self[26]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[26], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[26].outMaster
    trigger_t** prodconsbenchmark_workers_26__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[26]->___reaction_0.triggers[0] = prodconsbenchmark_workers_26__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[26]'s trigger struct.
    prodconsbenchmark_workers_26__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[26]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[27]->bank_index = 27;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[27]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[27]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[27]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[27]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[27]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[27]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[27]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[27]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[27]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[27]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[27] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[27]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[27] triggers 1 downstream reactions through port ProdConsBenchmark.workers[27].outMaster.
    prodconsbenchmark_workers_self[27]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[27], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[27].outMaster
    trigger_t** prodconsbenchmark_workers_27__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[27]->___reaction_0.triggers[0] = prodconsbenchmark_workers_27__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[27]'s trigger struct.
    prodconsbenchmark_workers_27__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[27]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[28]->bank_index = 28;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[28]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[28]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[28]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[28]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[28]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[28]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[28]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[28]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[28]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[28]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[28] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[28]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[28] triggers 1 downstream reactions through port ProdConsBenchmark.workers[28].outMaster.
    prodconsbenchmark_workers_self[28]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[28], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[28].outMaster
    trigger_t** prodconsbenchmark_workers_28__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[28]->___reaction_0.triggers[0] = prodconsbenchmark_workers_28__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[28]'s trigger struct.
    prodconsbenchmark_workers_28__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[28]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[29]->bank_index = 29;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[29]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[29]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[29]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[29]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[29]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[29]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[29]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[29]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[29]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[29]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[29] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[29]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[29] triggers 1 downstream reactions through port ProdConsBenchmark.workers[29].outMaster.
    prodconsbenchmark_workers_self[29]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[29], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[29].outMaster
    trigger_t** prodconsbenchmark_workers_29__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[29]->___reaction_0.triggers[0] = prodconsbenchmark_workers_29__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[29]'s trigger struct.
    prodconsbenchmark_workers_29__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[29]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[30]->bank_index = 30;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[30]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[30]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[30]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[30]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[30]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[30]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[30]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[30]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[30]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[30]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[30] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[30]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[30] triggers 1 downstream reactions through port ProdConsBenchmark.workers[30].outMaster.
    prodconsbenchmark_workers_self[30]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[30], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[30].outMaster
    trigger_t** prodconsbenchmark_workers_30__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[30]->___reaction_0.triggers[0] = prodconsbenchmark_workers_30__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[30]'s trigger struct.
    prodconsbenchmark_workers_30__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[30]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[31]->bank_index = 31;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[31]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[31]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[31]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[31]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[31]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[31]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[31]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[31]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[31]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[31]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[31] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[31]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[31] triggers 1 downstream reactions through port ProdConsBenchmark.workers[31].outMaster.
    prodconsbenchmark_workers_self[31]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[31], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[31].outMaster
    trigger_t** prodconsbenchmark_workers_31__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[31]->___reaction_0.triggers[0] = prodconsbenchmark_workers_31__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[31]'s trigger struct.
    prodconsbenchmark_workers_31__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[31]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[32]->bank_index = 32;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[32]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[32]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[32]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[32]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[32]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[32]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[32]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[32]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[32]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[32]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[32] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[32]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[32] triggers 1 downstream reactions through port ProdConsBenchmark.workers[32].outMaster.
    prodconsbenchmark_workers_self[32]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[32], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[32].outMaster
    trigger_t** prodconsbenchmark_workers_32__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[32]->___reaction_0.triggers[0] = prodconsbenchmark_workers_32__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[32]'s trigger struct.
    prodconsbenchmark_workers_32__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[32]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[33]->bank_index = 33;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[33]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[33]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[33]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[33]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[33]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[33]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[33]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[33]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[33]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[33]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[33] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[33]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[33] triggers 1 downstream reactions through port ProdConsBenchmark.workers[33].outMaster.
    prodconsbenchmark_workers_self[33]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[33], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[33].outMaster
    trigger_t** prodconsbenchmark_workers_33__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[33]->___reaction_0.triggers[0] = prodconsbenchmark_workers_33__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[33]'s trigger struct.
    prodconsbenchmark_workers_33__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[33]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[34]->bank_index = 34;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[34]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[34]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[34]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[34]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[34]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[34]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[34]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[34]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[34]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[34]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[34] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[34]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[34] triggers 1 downstream reactions through port ProdConsBenchmark.workers[34].outMaster.
    prodconsbenchmark_workers_self[34]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[34], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[34].outMaster
    trigger_t** prodconsbenchmark_workers_34__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[34]->___reaction_0.triggers[0] = prodconsbenchmark_workers_34__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[34]'s trigger struct.
    prodconsbenchmark_workers_34__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[34]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[35]->bank_index = 35;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[35]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[35]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[35]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[35]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[35]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[35]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[35]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[35]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[35]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[35]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[35] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[35]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[35] triggers 1 downstream reactions through port ProdConsBenchmark.workers[35].outMaster.
    prodconsbenchmark_workers_self[35]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[35], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[35].outMaster
    trigger_t** prodconsbenchmark_workers_35__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[35]->___reaction_0.triggers[0] = prodconsbenchmark_workers_35__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[35]'s trigger struct.
    prodconsbenchmark_workers_35__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[35]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[36]->bank_index = 36;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[36]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[36]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[36]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[36]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[36]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[36]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[36]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[36]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[36]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[36]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[36] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[36]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[36] triggers 1 downstream reactions through port ProdConsBenchmark.workers[36].outMaster.
    prodconsbenchmark_workers_self[36]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[36], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[36].outMaster
    trigger_t** prodconsbenchmark_workers_36__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[36]->___reaction_0.triggers[0] = prodconsbenchmark_workers_36__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[36]'s trigger struct.
    prodconsbenchmark_workers_36__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[36]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[37]->bank_index = 37;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[37]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[37]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[37]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[37]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[37]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[37]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[37]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[37]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[37]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[37]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[37] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[37]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[37] triggers 1 downstream reactions through port ProdConsBenchmark.workers[37].outMaster.
    prodconsbenchmark_workers_self[37]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[37], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[37].outMaster
    trigger_t** prodconsbenchmark_workers_37__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[37]->___reaction_0.triggers[0] = prodconsbenchmark_workers_37__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[37]'s trigger struct.
    prodconsbenchmark_workers_37__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[37]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[38]->bank_index = 38;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[38]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[38]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[38]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[38]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[38]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[38]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[38]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[38]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[38]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[38]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[38] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[38]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[38] triggers 1 downstream reactions through port ProdConsBenchmark.workers[38].outMaster.
    prodconsbenchmark_workers_self[38]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[38], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[38].outMaster
    trigger_t** prodconsbenchmark_workers_38__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[38]->___reaction_0.triggers[0] = prodconsbenchmark_workers_38__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[38]'s trigger struct.
    prodconsbenchmark_workers_38__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[38]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[39]->bank_index = 39;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[39]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[39]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[39]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[39]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[39]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[39]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[39]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[39]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[39]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[39]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[39] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[39]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[39] triggers 1 downstream reactions through port ProdConsBenchmark.workers[39].outMaster.
    prodconsbenchmark_workers_self[39]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[39], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[39].outMaster
    trigger_t** prodconsbenchmark_workers_39__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[39]->___reaction_0.triggers[0] = prodconsbenchmark_workers_39__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[39]'s trigger struct.
    prodconsbenchmark_workers_39__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[39]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[40]->bank_index = 40;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[40]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[40]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[40]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[40]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[40]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[40]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[40]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[40]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[40]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[40]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[40] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[40]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[40] triggers 1 downstream reactions through port ProdConsBenchmark.workers[40].outMaster.
    prodconsbenchmark_workers_self[40]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[40], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[40].outMaster
    trigger_t** prodconsbenchmark_workers_40__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[40]->___reaction_0.triggers[0] = prodconsbenchmark_workers_40__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[40]'s trigger struct.
    prodconsbenchmark_workers_40__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[40]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[41]->bank_index = 41;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[41]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[41]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[41]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[41]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[41]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[41]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[41]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[41]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[41]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[41]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[41] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[41]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[41] triggers 1 downstream reactions through port ProdConsBenchmark.workers[41].outMaster.
    prodconsbenchmark_workers_self[41]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[41], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[41].outMaster
    trigger_t** prodconsbenchmark_workers_41__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[41]->___reaction_0.triggers[0] = prodconsbenchmark_workers_41__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[41]'s trigger struct.
    prodconsbenchmark_workers_41__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[41]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[42]->bank_index = 42;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[42]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[42]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[42]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[42]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[42]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[42]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[42]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[42]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[42]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[42]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[42] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[42]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[42] triggers 1 downstream reactions through port ProdConsBenchmark.workers[42].outMaster.
    prodconsbenchmark_workers_self[42]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[42], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[42].outMaster
    trigger_t** prodconsbenchmark_workers_42__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[42]->___reaction_0.triggers[0] = prodconsbenchmark_workers_42__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[42]'s trigger struct.
    prodconsbenchmark_workers_42__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[42]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[43]->bank_index = 43;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[43]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[43]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[43]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[43]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[43]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[43]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[43]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[43]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[43]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[43]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[43] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[43]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[43] triggers 1 downstream reactions through port ProdConsBenchmark.workers[43].outMaster.
    prodconsbenchmark_workers_self[43]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[43], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[43].outMaster
    trigger_t** prodconsbenchmark_workers_43__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[43]->___reaction_0.triggers[0] = prodconsbenchmark_workers_43__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[43]'s trigger struct.
    prodconsbenchmark_workers_43__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[43]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[44]->bank_index = 44;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[44]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[44]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[44]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[44]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[44]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[44]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[44]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[44]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[44]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[44]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[44] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[44]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[44] triggers 1 downstream reactions through port ProdConsBenchmark.workers[44].outMaster.
    prodconsbenchmark_workers_self[44]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[44], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[44].outMaster
    trigger_t** prodconsbenchmark_workers_44__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[44]->___reaction_0.triggers[0] = prodconsbenchmark_workers_44__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[44]'s trigger struct.
    prodconsbenchmark_workers_44__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[44]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[45]->bank_index = 45;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[45]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[45]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[45]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[45]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[45]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[45]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[45]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[45]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[45]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[45]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[45] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[45]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[45] triggers 1 downstream reactions through port ProdConsBenchmark.workers[45].outMaster.
    prodconsbenchmark_workers_self[45]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[45], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[45].outMaster
    trigger_t** prodconsbenchmark_workers_45__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[45]->___reaction_0.triggers[0] = prodconsbenchmark_workers_45__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[45]'s trigger struct.
    prodconsbenchmark_workers_45__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[45]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[46]->bank_index = 46;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[46]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[46]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[46]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[46]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[46]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[46]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[46]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[46]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[46]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[46]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[46] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[46]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[46] triggers 1 downstream reactions through port ProdConsBenchmark.workers[46].outMaster.
    prodconsbenchmark_workers_self[46]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[46], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[46].outMaster
    trigger_t** prodconsbenchmark_workers_46__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[46]->___reaction_0.triggers[0] = prodconsbenchmark_workers_46__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[46]'s trigger struct.
    prodconsbenchmark_workers_46__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[46]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[47]->bank_index = 47;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[47]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[47]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[47]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[47]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[47]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[47]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[47]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[47]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[47]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[47]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[47] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[47]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[47] triggers 1 downstream reactions through port ProdConsBenchmark.workers[47].outMaster.
    prodconsbenchmark_workers_self[47]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[47], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[47].outMaster
    trigger_t** prodconsbenchmark_workers_47__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[47]->___reaction_0.triggers[0] = prodconsbenchmark_workers_47__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[47]'s trigger struct.
    prodconsbenchmark_workers_47__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[47]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[48]->bank_index = 48;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[48]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[48]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[48]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[48]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[48]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[48]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[48]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[48]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[48]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[48]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[48] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[48]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[48] triggers 1 downstream reactions through port ProdConsBenchmark.workers[48].outMaster.
    prodconsbenchmark_workers_self[48]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[48], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[48].outMaster
    trigger_t** prodconsbenchmark_workers_48__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[48]->___reaction_0.triggers[0] = prodconsbenchmark_workers_48__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[48]'s trigger struct.
    prodconsbenchmark_workers_48__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[48]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[49]->bank_index = 49;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[49]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[49]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[49]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[49]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[49]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[49]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[49]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[49]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[49]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[49]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[49] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[49]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[49] triggers 1 downstream reactions through port ProdConsBenchmark.workers[49].outMaster.
    prodconsbenchmark_workers_self[49]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[49], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[49].outMaster
    trigger_t** prodconsbenchmark_workers_49__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[49]->___reaction_0.triggers[0] = prodconsbenchmark_workers_49__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[49]'s trigger struct.
    prodconsbenchmark_workers_49__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[49]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[50]->bank_index = 50;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[50]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[50]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[50]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[50]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[50]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[50]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[50]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[50]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[50]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[50]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[50] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[50]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[50] triggers 1 downstream reactions through port ProdConsBenchmark.workers[50].outMaster.
    prodconsbenchmark_workers_self[50]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[50], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[50].outMaster
    trigger_t** prodconsbenchmark_workers_50__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[50]->___reaction_0.triggers[0] = prodconsbenchmark_workers_50__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[50]'s trigger struct.
    prodconsbenchmark_workers_50__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[50]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[51]->bank_index = 51;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[51]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[51]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[51]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[51]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[51]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[51]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[51]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[51]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[51]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[51]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[51] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[51]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[51] triggers 1 downstream reactions through port ProdConsBenchmark.workers[51].outMaster.
    prodconsbenchmark_workers_self[51]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[51], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[51].outMaster
    trigger_t** prodconsbenchmark_workers_51__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[51]->___reaction_0.triggers[0] = prodconsbenchmark_workers_51__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[51]'s trigger struct.
    prodconsbenchmark_workers_51__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[51]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[52]->bank_index = 52;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[52]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[52]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[52]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[52]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[52]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[52]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[52]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[52]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[52]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[52]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[52] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[52]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[52] triggers 1 downstream reactions through port ProdConsBenchmark.workers[52].outMaster.
    prodconsbenchmark_workers_self[52]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[52], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[52].outMaster
    trigger_t** prodconsbenchmark_workers_52__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[52]->___reaction_0.triggers[0] = prodconsbenchmark_workers_52__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[52]'s trigger struct.
    prodconsbenchmark_workers_52__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[52]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[53]->bank_index = 53;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[53]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[53]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[53]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[53]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[53]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[53]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[53]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[53]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[53]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[53]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[53] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[53]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[53] triggers 1 downstream reactions through port ProdConsBenchmark.workers[53].outMaster.
    prodconsbenchmark_workers_self[53]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[53], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[53].outMaster
    trigger_t** prodconsbenchmark_workers_53__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[53]->___reaction_0.triggers[0] = prodconsbenchmark_workers_53__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[53]'s trigger struct.
    prodconsbenchmark_workers_53__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[53]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[54]->bank_index = 54;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[54]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[54]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[54]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[54]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[54]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[54]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[54]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[54]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[54]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[54]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[54] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[54]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[54] triggers 1 downstream reactions through port ProdConsBenchmark.workers[54].outMaster.
    prodconsbenchmark_workers_self[54]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[54], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[54].outMaster
    trigger_t** prodconsbenchmark_workers_54__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[54]->___reaction_0.triggers[0] = prodconsbenchmark_workers_54__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[54]'s trigger struct.
    prodconsbenchmark_workers_54__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[54]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[55]->bank_index = 55;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[55]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[55]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[55]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[55]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[55]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[55]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[55]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[55]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[55]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[55]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[55] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[55]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[55] triggers 1 downstream reactions through port ProdConsBenchmark.workers[55].outMaster.
    prodconsbenchmark_workers_self[55]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[55], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[55].outMaster
    trigger_t** prodconsbenchmark_workers_55__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[55]->___reaction_0.triggers[0] = prodconsbenchmark_workers_55__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[55]'s trigger struct.
    prodconsbenchmark_workers_55__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[55]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[56]->bank_index = 56;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[56]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[56]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[56]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[56]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[56]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[56]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[56]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[56]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[56]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[56]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[56] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[56]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[56] triggers 1 downstream reactions through port ProdConsBenchmark.workers[56].outMaster.
    prodconsbenchmark_workers_self[56]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[56], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[56].outMaster
    trigger_t** prodconsbenchmark_workers_56__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[56]->___reaction_0.triggers[0] = prodconsbenchmark_workers_56__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[56]'s trigger struct.
    prodconsbenchmark_workers_56__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[56]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[57]->bank_index = 57;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[57]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[57]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[57]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[57]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[57]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[57]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[57]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[57]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[57]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[57]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[57] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[57]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[57] triggers 1 downstream reactions through port ProdConsBenchmark.workers[57].outMaster.
    prodconsbenchmark_workers_self[57]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[57], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[57].outMaster
    trigger_t** prodconsbenchmark_workers_57__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[57]->___reaction_0.triggers[0] = prodconsbenchmark_workers_57__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[57]'s trigger struct.
    prodconsbenchmark_workers_57__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[57]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[58]->bank_index = 58;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[58]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[58]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[58]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[58]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[58]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[58]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[58]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[58]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[58]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[58]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[58] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[58]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[58] triggers 1 downstream reactions through port ProdConsBenchmark.workers[58].outMaster.
    prodconsbenchmark_workers_self[58]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[58], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[58].outMaster
    trigger_t** prodconsbenchmark_workers_58__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[58]->___reaction_0.triggers[0] = prodconsbenchmark_workers_58__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[58]'s trigger struct.
    prodconsbenchmark_workers_58__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[58]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[59]->bank_index = 59;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[59]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[59]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[59]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[59]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[59]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[59]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[59]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[59]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[59]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[59]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[59] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[59]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[59] triggers 1 downstream reactions through port ProdConsBenchmark.workers[59].outMaster.
    prodconsbenchmark_workers_self[59]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[59], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[59].outMaster
    trigger_t** prodconsbenchmark_workers_59__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[59]->___reaction_0.triggers[0] = prodconsbenchmark_workers_59__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[59]'s trigger struct.
    prodconsbenchmark_workers_59__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[59]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[60]->bank_index = 60;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[60]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[60]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[60]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[60]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[60]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[60]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[60]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[60]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[60]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[60]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[60] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[60]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[60] triggers 1 downstream reactions through port ProdConsBenchmark.workers[60].outMaster.
    prodconsbenchmark_workers_self[60]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[60], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[60].outMaster
    trigger_t** prodconsbenchmark_workers_60__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[60]->___reaction_0.triggers[0] = prodconsbenchmark_workers_60__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[60]'s trigger struct.
    prodconsbenchmark_workers_60__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[60]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[61]->bank_index = 61;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[61]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[61]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[61]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[61]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[61]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[61]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[61]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[61]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[61]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[61]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[61] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[61]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[61] triggers 1 downstream reactions through port ProdConsBenchmark.workers[61].outMaster.
    prodconsbenchmark_workers_self[61]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[61], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[61].outMaster
    trigger_t** prodconsbenchmark_workers_61__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[61]->___reaction_0.triggers[0] = prodconsbenchmark_workers_61__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[61]'s trigger struct.
    prodconsbenchmark_workers_61__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[61]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[62]->bank_index = 62;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[62]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[62]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[62]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[62]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[62]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[62]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[62]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[62]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[62]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[62]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[62] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[62]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[62] triggers 1 downstream reactions through port ProdConsBenchmark.workers[62].outMaster.
    prodconsbenchmark_workers_self[62]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[62], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[62].outMaster
    trigger_t** prodconsbenchmark_workers_62__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[62]->___reaction_0.triggers[0] = prodconsbenchmark_workers_62__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[62]'s trigger struct.
    prodconsbenchmark_workers_62__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[62]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[63]->bank_index = 63;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[63]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[63]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[63]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[63]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[63]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[63]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[63]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[63]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[63]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[63]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[63] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[63]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[63] triggers 1 downstream reactions through port ProdConsBenchmark.workers[63].outMaster.
    prodconsbenchmark_workers_self[63]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[63], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[63].outMaster
    trigger_t** prodconsbenchmark_workers_63__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[63]->___reaction_0.triggers[0] = prodconsbenchmark_workers_63__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[63]'s trigger struct.
    prodconsbenchmark_workers_63__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[63]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[64]->bank_index = 64;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[64]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[64]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[64]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[64]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[64]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[64]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[64]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[64]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[64]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[64]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[64] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[64]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[64] triggers 1 downstream reactions through port ProdConsBenchmark.workers[64].outMaster.
    prodconsbenchmark_workers_self[64]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[64], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[64].outMaster
    trigger_t** prodconsbenchmark_workers_64__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[64]->___reaction_0.triggers[0] = prodconsbenchmark_workers_64__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[64]'s trigger struct.
    prodconsbenchmark_workers_64__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[64]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[65]->bank_index = 65;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[65]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[65]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[65]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[65]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[65]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[65]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[65]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[65]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[65]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[65]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[65] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[65]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[65] triggers 1 downstream reactions through port ProdConsBenchmark.workers[65].outMaster.
    prodconsbenchmark_workers_self[65]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[65], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[65].outMaster
    trigger_t** prodconsbenchmark_workers_65__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[65]->___reaction_0.triggers[0] = prodconsbenchmark_workers_65__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[65]'s trigger struct.
    prodconsbenchmark_workers_65__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[65]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[66]->bank_index = 66;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[66]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[66]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[66]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[66]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[66]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[66]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[66]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[66]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[66]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[66]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[66] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[66]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[66] triggers 1 downstream reactions through port ProdConsBenchmark.workers[66].outMaster.
    prodconsbenchmark_workers_self[66]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[66], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[66].outMaster
    trigger_t** prodconsbenchmark_workers_66__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[66]->___reaction_0.triggers[0] = prodconsbenchmark_workers_66__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[66]'s trigger struct.
    prodconsbenchmark_workers_66__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[66]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[67]->bank_index = 67;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[67]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[67]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[67]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[67]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[67]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[67]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[67]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[67]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[67]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[67]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[67] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[67]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[67] triggers 1 downstream reactions through port ProdConsBenchmark.workers[67].outMaster.
    prodconsbenchmark_workers_self[67]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[67], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[67].outMaster
    trigger_t** prodconsbenchmark_workers_67__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[67]->___reaction_0.triggers[0] = prodconsbenchmark_workers_67__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[67]'s trigger struct.
    prodconsbenchmark_workers_67__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[67]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[68]->bank_index = 68;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[68]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[68]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[68]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[68]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[68]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[68]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[68]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[68]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[68]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[68]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[68] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[68]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[68] triggers 1 downstream reactions through port ProdConsBenchmark.workers[68].outMaster.
    prodconsbenchmark_workers_self[68]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[68], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[68].outMaster
    trigger_t** prodconsbenchmark_workers_68__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[68]->___reaction_0.triggers[0] = prodconsbenchmark_workers_68__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[68]'s trigger struct.
    prodconsbenchmark_workers_68__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[68]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[69]->bank_index = 69;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[69]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[69]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[69]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[69]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[69]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[69]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[69]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[69]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[69]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[69]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[69] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[69]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[69] triggers 1 downstream reactions through port ProdConsBenchmark.workers[69].outMaster.
    prodconsbenchmark_workers_self[69]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[69], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[69].outMaster
    trigger_t** prodconsbenchmark_workers_69__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[69]->___reaction_0.triggers[0] = prodconsbenchmark_workers_69__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[69]'s trigger struct.
    prodconsbenchmark_workers_69__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[69]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[70]->bank_index = 70;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[70]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[70]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[70]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[70]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[70]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[70]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[70]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[70]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[70]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[70]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[70] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[70]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[70] triggers 1 downstream reactions through port ProdConsBenchmark.workers[70].outMaster.
    prodconsbenchmark_workers_self[70]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[70], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[70].outMaster
    trigger_t** prodconsbenchmark_workers_70__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[70]->___reaction_0.triggers[0] = prodconsbenchmark_workers_70__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[70]'s trigger struct.
    prodconsbenchmark_workers_70__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[70]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[71]->bank_index = 71;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[71]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[71]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[71]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[71]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[71]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[71]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[71]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[71]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[71]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[71]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[71] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[71]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[71] triggers 1 downstream reactions through port ProdConsBenchmark.workers[71].outMaster.
    prodconsbenchmark_workers_self[71]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[71], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[71].outMaster
    trigger_t** prodconsbenchmark_workers_71__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[71]->___reaction_0.triggers[0] = prodconsbenchmark_workers_71__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[71]'s trigger struct.
    prodconsbenchmark_workers_71__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[71]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[72]->bank_index = 72;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[72]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[72]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[72]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[72]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[72]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[72]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[72]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[72]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[72]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[72]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[72] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[72]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[72] triggers 1 downstream reactions through port ProdConsBenchmark.workers[72].outMaster.
    prodconsbenchmark_workers_self[72]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[72], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[72].outMaster
    trigger_t** prodconsbenchmark_workers_72__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[72]->___reaction_0.triggers[0] = prodconsbenchmark_workers_72__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[72]'s trigger struct.
    prodconsbenchmark_workers_72__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[72]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[73]->bank_index = 73;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[73]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[73]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[73]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[73]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[73]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[73]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[73]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[73]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[73]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[73]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[73] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[73]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[73] triggers 1 downstream reactions through port ProdConsBenchmark.workers[73].outMaster.
    prodconsbenchmark_workers_self[73]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[73], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[73].outMaster
    trigger_t** prodconsbenchmark_workers_73__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[73]->___reaction_0.triggers[0] = prodconsbenchmark_workers_73__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[73]'s trigger struct.
    prodconsbenchmark_workers_73__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[73]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[74]->bank_index = 74;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[74]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[74]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[74]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[74]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[74]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[74]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[74]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[74]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[74]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[74]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[74] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[74]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[74] triggers 1 downstream reactions through port ProdConsBenchmark.workers[74].outMaster.
    prodconsbenchmark_workers_self[74]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[74], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[74].outMaster
    trigger_t** prodconsbenchmark_workers_74__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[74]->___reaction_0.triggers[0] = prodconsbenchmark_workers_74__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[74]'s trigger struct.
    prodconsbenchmark_workers_74__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[74]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[75]->bank_index = 75;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[75]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[75]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[75]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[75]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[75]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[75]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[75]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[75]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[75]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[75]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[75] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[75]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[75] triggers 1 downstream reactions through port ProdConsBenchmark.workers[75].outMaster.
    prodconsbenchmark_workers_self[75]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[75], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[75].outMaster
    trigger_t** prodconsbenchmark_workers_75__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[75]->___reaction_0.triggers[0] = prodconsbenchmark_workers_75__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[75]'s trigger struct.
    prodconsbenchmark_workers_75__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[75]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[76]->bank_index = 76;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[76]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[76]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[76]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[76]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[76]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[76]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[76]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[76]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[76]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[76]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[76] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[76]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[76] triggers 1 downstream reactions through port ProdConsBenchmark.workers[76].outMaster.
    prodconsbenchmark_workers_self[76]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[76], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[76].outMaster
    trigger_t** prodconsbenchmark_workers_76__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[76]->___reaction_0.triggers[0] = prodconsbenchmark_workers_76__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[76]'s trigger struct.
    prodconsbenchmark_workers_76__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[76]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[77]->bank_index = 77;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[77]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[77]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[77]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[77]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[77]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[77]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[77]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[77]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[77]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[77]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[77] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[77]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[77] triggers 1 downstream reactions through port ProdConsBenchmark.workers[77].outMaster.
    prodconsbenchmark_workers_self[77]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[77], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[77].outMaster
    trigger_t** prodconsbenchmark_workers_77__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[77]->___reaction_0.triggers[0] = prodconsbenchmark_workers_77__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[77]'s trigger struct.
    prodconsbenchmark_workers_77__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[77]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[78]->bank_index = 78;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[78]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[78]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[78]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[78]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[78]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[78]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[78]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[78]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[78]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[78]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[78] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[78]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[78] triggers 1 downstream reactions through port ProdConsBenchmark.workers[78].outMaster.
    prodconsbenchmark_workers_self[78]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[78], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[78].outMaster
    trigger_t** prodconsbenchmark_workers_78__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[78]->___reaction_0.triggers[0] = prodconsbenchmark_workers_78__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[78]'s trigger struct.
    prodconsbenchmark_workers_78__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[78]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[79]->bank_index = 79;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[79]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[79]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[79]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[79]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[79]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[79]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[79]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[79]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[79]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[79]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[79] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[79]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[79] triggers 1 downstream reactions through port ProdConsBenchmark.workers[79].outMaster.
    prodconsbenchmark_workers_self[79]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[79], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[79].outMaster
    trigger_t** prodconsbenchmark_workers_79__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[79]->___reaction_0.triggers[0] = prodconsbenchmark_workers_79__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[79]'s trigger struct.
    prodconsbenchmark_workers_79__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[79]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[80]->bank_index = 80;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[80]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[80]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[80]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[80]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[80]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[80]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[80]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[80]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[80]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[80]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[80] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[80]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[80] triggers 1 downstream reactions through port ProdConsBenchmark.workers[80].outMaster.
    prodconsbenchmark_workers_self[80]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[80], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[80].outMaster
    trigger_t** prodconsbenchmark_workers_80__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[80]->___reaction_0.triggers[0] = prodconsbenchmark_workers_80__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[80]'s trigger struct.
    prodconsbenchmark_workers_80__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[80]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[81]->bank_index = 81;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[81]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[81]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[81]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[81]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[81]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[81]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[81]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[81]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[81]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[81]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[81] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[81]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[81] triggers 1 downstream reactions through port ProdConsBenchmark.workers[81].outMaster.
    prodconsbenchmark_workers_self[81]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[81], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[81].outMaster
    trigger_t** prodconsbenchmark_workers_81__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[81]->___reaction_0.triggers[0] = prodconsbenchmark_workers_81__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[81]'s trigger struct.
    prodconsbenchmark_workers_81__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[81]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[82]->bank_index = 82;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[82]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[82]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[82]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[82]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[82]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[82]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[82]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[82]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[82]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[82]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[82] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[82]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[82] triggers 1 downstream reactions through port ProdConsBenchmark.workers[82].outMaster.
    prodconsbenchmark_workers_self[82]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[82], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[82].outMaster
    trigger_t** prodconsbenchmark_workers_82__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[82]->___reaction_0.triggers[0] = prodconsbenchmark_workers_82__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[82]'s trigger struct.
    prodconsbenchmark_workers_82__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[82]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[83]->bank_index = 83;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[83]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[83]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[83]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[83]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[83]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[83]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[83]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[83]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[83]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[83]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[83] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[83]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[83] triggers 1 downstream reactions through port ProdConsBenchmark.workers[83].outMaster.
    prodconsbenchmark_workers_self[83]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[83], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[83].outMaster
    trigger_t** prodconsbenchmark_workers_83__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[83]->___reaction_0.triggers[0] = prodconsbenchmark_workers_83__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[83]'s trigger struct.
    prodconsbenchmark_workers_83__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[83]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[84]->bank_index = 84;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[84]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[84]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[84]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[84]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[84]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[84]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[84]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[84]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[84]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[84]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[84] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[84]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[84] triggers 1 downstream reactions through port ProdConsBenchmark.workers[84].outMaster.
    prodconsbenchmark_workers_self[84]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[84], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[84].outMaster
    trigger_t** prodconsbenchmark_workers_84__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[84]->___reaction_0.triggers[0] = prodconsbenchmark_workers_84__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[84]'s trigger struct.
    prodconsbenchmark_workers_84__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[84]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[85]->bank_index = 85;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[85]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[85]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[85]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[85]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[85]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[85]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[85]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[85]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[85]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[85]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[85] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[85]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[85] triggers 1 downstream reactions through port ProdConsBenchmark.workers[85].outMaster.
    prodconsbenchmark_workers_self[85]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[85], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[85].outMaster
    trigger_t** prodconsbenchmark_workers_85__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[85]->___reaction_0.triggers[0] = prodconsbenchmark_workers_85__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[85]'s trigger struct.
    prodconsbenchmark_workers_85__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[85]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[86]->bank_index = 86;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[86]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[86]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[86]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[86]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[86]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[86]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[86]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[86]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[86]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[86]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[86] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[86]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[86] triggers 1 downstream reactions through port ProdConsBenchmark.workers[86].outMaster.
    prodconsbenchmark_workers_self[86]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[86], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[86].outMaster
    trigger_t** prodconsbenchmark_workers_86__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[86]->___reaction_0.triggers[0] = prodconsbenchmark_workers_86__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[86]'s trigger struct.
    prodconsbenchmark_workers_86__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[86]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[87]->bank_index = 87;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[87]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[87]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[87]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[87]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[87]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[87]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[87]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[87]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[87]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[87]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[87] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[87]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[87] triggers 1 downstream reactions through port ProdConsBenchmark.workers[87].outMaster.
    prodconsbenchmark_workers_self[87]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[87], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[87].outMaster
    trigger_t** prodconsbenchmark_workers_87__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[87]->___reaction_0.triggers[0] = prodconsbenchmark_workers_87__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[87]'s trigger struct.
    prodconsbenchmark_workers_87__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[87]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[88]->bank_index = 88;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[88]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[88]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[88]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[88]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[88]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[88]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[88]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[88]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[88]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[88]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[88] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[88]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[88] triggers 1 downstream reactions through port ProdConsBenchmark.workers[88].outMaster.
    prodconsbenchmark_workers_self[88]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[88], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[88].outMaster
    trigger_t** prodconsbenchmark_workers_88__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[88]->___reaction_0.triggers[0] = prodconsbenchmark_workers_88__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[88]'s trigger struct.
    prodconsbenchmark_workers_88__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[88]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[89]->bank_index = 89;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[89]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[89]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[89]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[89]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[89]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[89]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[89]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[89]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[89]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[89]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[89] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[89]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[89] triggers 1 downstream reactions through port ProdConsBenchmark.workers[89].outMaster.
    prodconsbenchmark_workers_self[89]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[89], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[89].outMaster
    trigger_t** prodconsbenchmark_workers_89__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[89]->___reaction_0.triggers[0] = prodconsbenchmark_workers_89__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[89]'s trigger struct.
    prodconsbenchmark_workers_89__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[89]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[90]->bank_index = 90;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[90]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[90]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[90]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[90]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[90]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[90]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[90]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[90]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[90]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[90]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[90] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[90]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[90] triggers 1 downstream reactions through port ProdConsBenchmark.workers[90].outMaster.
    prodconsbenchmark_workers_self[90]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[90], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[90].outMaster
    trigger_t** prodconsbenchmark_workers_90__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[90]->___reaction_0.triggers[0] = prodconsbenchmark_workers_90__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[90]'s trigger struct.
    prodconsbenchmark_workers_90__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[90]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[91]->bank_index = 91;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[91]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[91]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[91]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[91]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[91]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[91]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[91]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[91]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[91]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[91]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[91] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[91]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[91] triggers 1 downstream reactions through port ProdConsBenchmark.workers[91].outMaster.
    prodconsbenchmark_workers_self[91]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[91], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[91].outMaster
    trigger_t** prodconsbenchmark_workers_91__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[91]->___reaction_0.triggers[0] = prodconsbenchmark_workers_91__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[91]'s trigger struct.
    prodconsbenchmark_workers_91__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[91]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[92]->bank_index = 92;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[92]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[92]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[92]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[92]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[92]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[92]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[92]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[92]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[92]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[92]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[92] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[92]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[92] triggers 1 downstream reactions through port ProdConsBenchmark.workers[92].outMaster.
    prodconsbenchmark_workers_self[92]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[92], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[92].outMaster
    trigger_t** prodconsbenchmark_workers_92__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[92]->___reaction_0.triggers[0] = prodconsbenchmark_workers_92__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[92]'s trigger struct.
    prodconsbenchmark_workers_92__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[92]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[93]->bank_index = 93;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[93]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[93]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[93]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[93]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[93]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[93]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[93]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[93]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[93]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[93]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[93] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[93]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[93] triggers 1 downstream reactions through port ProdConsBenchmark.workers[93].outMaster.
    prodconsbenchmark_workers_self[93]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[93], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[93].outMaster
    trigger_t** prodconsbenchmark_workers_93__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[93]->___reaction_0.triggers[0] = prodconsbenchmark_workers_93__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[93]'s trigger struct.
    prodconsbenchmark_workers_93__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[93]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[94]->bank_index = 94;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[94]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[94]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[94]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[94]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[94]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[94]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[94]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[94]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[94]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[94]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[94] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[94]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[94] triggers 1 downstream reactions through port ProdConsBenchmark.workers[94].outMaster.
    prodconsbenchmark_workers_self[94]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[94], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[94].outMaster
    trigger_t** prodconsbenchmark_workers_94__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[94]->___reaction_0.triggers[0] = prodconsbenchmark_workers_94__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[94]'s trigger struct.
    prodconsbenchmark_workers_94__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[94]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[95]->bank_index = 95;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[95]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[95]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[95]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[95]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[95]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[95]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[95]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[95]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[95]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[95]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[95] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[95]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[95] triggers 1 downstream reactions through port ProdConsBenchmark.workers[95].outMaster.
    prodconsbenchmark_workers_self[95]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[95], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[95].outMaster
    trigger_t** prodconsbenchmark_workers_95__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[95]->___reaction_0.triggers[0] = prodconsbenchmark_workers_95__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[95]'s trigger struct.
    prodconsbenchmark_workers_95__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[95]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[96]->bank_index = 96;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[96]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[96]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[96]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[96]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[96]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[96]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[96]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[96]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[96]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[96]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[96] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[96]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[96] triggers 1 downstream reactions through port ProdConsBenchmark.workers[96].outMaster.
    prodconsbenchmark_workers_self[96]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[96], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[96].outMaster
    trigger_t** prodconsbenchmark_workers_96__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[96]->___reaction_0.triggers[0] = prodconsbenchmark_workers_96__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[96]'s trigger struct.
    prodconsbenchmark_workers_96__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[96]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[97]->bank_index = 97;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[97]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[97]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[97]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[97]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[97]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[97]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[97]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[97]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[97]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[97]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[97] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[97]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[97] triggers 1 downstream reactions through port ProdConsBenchmark.workers[97].outMaster.
    prodconsbenchmark_workers_self[97]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[97], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[97].outMaster
    trigger_t** prodconsbenchmark_workers_97__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[97]->___reaction_0.triggers[0] = prodconsbenchmark_workers_97__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[97]'s trigger struct.
    prodconsbenchmark_workers_97__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[97]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[98]->bank_index = 98;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[98]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[98]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[98]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[98]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[98]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[98]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[98]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[98]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[98]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[98]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[98] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[98]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[98] triggers 1 downstream reactions through port ProdConsBenchmark.workers[98].outMaster.
    prodconsbenchmark_workers_self[98]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[98], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[98].outMaster
    trigger_t** prodconsbenchmark_workers_98__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[98]->___reaction_0.triggers[0] = prodconsbenchmark_workers_98__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[98]'s trigger struct.
    prodconsbenchmark_workers_98__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[98]->__outMaster.num_destinations
    = 1;
    prodconsbenchmark_workers_self[99]->bank_index = 99;
    // Total number of outputs produced by the reaction.
    prodconsbenchmark_workers_self[99]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (prodconsbenchmark_workers_self[99]->___reaction_0.num_outputs > 0) {
        prodconsbenchmark_workers_self[99]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * prodconsbenchmark_workers_self[99]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[99]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * prodconsbenchmark_workers_self[99]->___reaction_0.num_outputs);
        prodconsbenchmark_workers_self[99]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * prodconsbenchmark_workers_self[99]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    prodconsbenchmark_workers_self[99]->___reaction_0.output_produced[0]
    = &prodconsbenchmark_workers_self[99]->__outMaster.is_present
    ;
    // Reaction 0 of ProdConsBenchmark.workers[99] depends on one maximal upstream reaction.
    prodconsbenchmark_workers_self[99]->___reaction_0.last_enabling_reaction = &(prodconsbenchmark_master_self->___reaction_1);
    // Reaction 0 of ProdConsBenchmark.workers[99] triggers 1 downstream reactions through port ProdConsBenchmark.workers[99].outMaster.
    prodconsbenchmark_workers_self[99]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProdConsBenchmark.workers[99], allocate an
    // array of trigger pointers for downstream reactions through port ProdConsBenchmark.workers[99].outMaster
    trigger_t** prodconsbenchmark_workers_99__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    prodconsbenchmark_workers_self[99]->___reaction_0.triggers[0] = prodconsbenchmark_workers_99__0_0;
    // Point to destination port ProdConsBenchmark.master.inWorkers[99]'s trigger struct.
    prodconsbenchmark_workers_99__0_0[0] = &prodconsbenchmark_master_self->___inWorkers;
    prodconsbenchmark_workers_self[99]->__outMaster.num_destinations
    = 1;
    // doDeferredInitialize
    // Connect inputs and outputs for reactor ProdConsBenchmark.
    // Connect ProdConsBenchmark.runner.outIterationStart to input port ProdConsBenchmark.master.inStart
    prodconsbenchmark_master_self->__inStart = (master_inStart_t*)&prodconsbenchmark_runner_self->__outIterationStart;
    // Connect ProdConsBenchmark.master.outFinished to input port ProdConsBenchmark.runner.inIterationFinish
    prodconsbenchmark_runner_self->__inIterationFinish = (benchmarkrunner_inIterationFinish_t*)&prodconsbenchmark_master_self->__outFinished;
    // Connect ProdConsBenchmark.workers[0].outMaster to input port ProdConsBenchmark.master.inWorkers[0]
    prodconsbenchmark_master_self->__inWorkers[0] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[0]->__outMaster;
    // Connect ProdConsBenchmark.workers[1].outMaster to input port ProdConsBenchmark.master.inWorkers[1]
    prodconsbenchmark_master_self->__inWorkers[1] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[1]->__outMaster;
    // Connect ProdConsBenchmark.workers[2].outMaster to input port ProdConsBenchmark.master.inWorkers[2]
    prodconsbenchmark_master_self->__inWorkers[2] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[2]->__outMaster;
    // Connect ProdConsBenchmark.workers[3].outMaster to input port ProdConsBenchmark.master.inWorkers[3]
    prodconsbenchmark_master_self->__inWorkers[3] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[3]->__outMaster;
    // Connect ProdConsBenchmark.workers[4].outMaster to input port ProdConsBenchmark.master.inWorkers[4]
    prodconsbenchmark_master_self->__inWorkers[4] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[4]->__outMaster;
    // Connect ProdConsBenchmark.workers[5].outMaster to input port ProdConsBenchmark.master.inWorkers[5]
    prodconsbenchmark_master_self->__inWorkers[5] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[5]->__outMaster;
    // Connect ProdConsBenchmark.workers[6].outMaster to input port ProdConsBenchmark.master.inWorkers[6]
    prodconsbenchmark_master_self->__inWorkers[6] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[6]->__outMaster;
    // Connect ProdConsBenchmark.workers[7].outMaster to input port ProdConsBenchmark.master.inWorkers[7]
    prodconsbenchmark_master_self->__inWorkers[7] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[7]->__outMaster;
    // Connect ProdConsBenchmark.workers[8].outMaster to input port ProdConsBenchmark.master.inWorkers[8]
    prodconsbenchmark_master_self->__inWorkers[8] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[8]->__outMaster;
    // Connect ProdConsBenchmark.workers[9].outMaster to input port ProdConsBenchmark.master.inWorkers[9]
    prodconsbenchmark_master_self->__inWorkers[9] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[9]->__outMaster;
    // Connect ProdConsBenchmark.workers[10].outMaster to input port ProdConsBenchmark.master.inWorkers[10]
    prodconsbenchmark_master_self->__inWorkers[10] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[10]->__outMaster;
    // Connect ProdConsBenchmark.workers[11].outMaster to input port ProdConsBenchmark.master.inWorkers[11]
    prodconsbenchmark_master_self->__inWorkers[11] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[11]->__outMaster;
    // Connect ProdConsBenchmark.workers[12].outMaster to input port ProdConsBenchmark.master.inWorkers[12]
    prodconsbenchmark_master_self->__inWorkers[12] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[12]->__outMaster;
    // Connect ProdConsBenchmark.workers[13].outMaster to input port ProdConsBenchmark.master.inWorkers[13]
    prodconsbenchmark_master_self->__inWorkers[13] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[13]->__outMaster;
    // Connect ProdConsBenchmark.workers[14].outMaster to input port ProdConsBenchmark.master.inWorkers[14]
    prodconsbenchmark_master_self->__inWorkers[14] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[14]->__outMaster;
    // Connect ProdConsBenchmark.workers[15].outMaster to input port ProdConsBenchmark.master.inWorkers[15]
    prodconsbenchmark_master_self->__inWorkers[15] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[15]->__outMaster;
    // Connect ProdConsBenchmark.workers[16].outMaster to input port ProdConsBenchmark.master.inWorkers[16]
    prodconsbenchmark_master_self->__inWorkers[16] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[16]->__outMaster;
    // Connect ProdConsBenchmark.workers[17].outMaster to input port ProdConsBenchmark.master.inWorkers[17]
    prodconsbenchmark_master_self->__inWorkers[17] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[17]->__outMaster;
    // Connect ProdConsBenchmark.workers[18].outMaster to input port ProdConsBenchmark.master.inWorkers[18]
    prodconsbenchmark_master_self->__inWorkers[18] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[18]->__outMaster;
    // Connect ProdConsBenchmark.workers[19].outMaster to input port ProdConsBenchmark.master.inWorkers[19]
    prodconsbenchmark_master_self->__inWorkers[19] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[19]->__outMaster;
    // Connect ProdConsBenchmark.workers[20].outMaster to input port ProdConsBenchmark.master.inWorkers[20]
    prodconsbenchmark_master_self->__inWorkers[20] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[20]->__outMaster;
    // Connect ProdConsBenchmark.workers[21].outMaster to input port ProdConsBenchmark.master.inWorkers[21]
    prodconsbenchmark_master_self->__inWorkers[21] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[21]->__outMaster;
    // Connect ProdConsBenchmark.workers[22].outMaster to input port ProdConsBenchmark.master.inWorkers[22]
    prodconsbenchmark_master_self->__inWorkers[22] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[22]->__outMaster;
    // Connect ProdConsBenchmark.workers[23].outMaster to input port ProdConsBenchmark.master.inWorkers[23]
    prodconsbenchmark_master_self->__inWorkers[23] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[23]->__outMaster;
    // Connect ProdConsBenchmark.workers[24].outMaster to input port ProdConsBenchmark.master.inWorkers[24]
    prodconsbenchmark_master_self->__inWorkers[24] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[24]->__outMaster;
    // Connect ProdConsBenchmark.workers[25].outMaster to input port ProdConsBenchmark.master.inWorkers[25]
    prodconsbenchmark_master_self->__inWorkers[25] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[25]->__outMaster;
    // Connect ProdConsBenchmark.workers[26].outMaster to input port ProdConsBenchmark.master.inWorkers[26]
    prodconsbenchmark_master_self->__inWorkers[26] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[26]->__outMaster;
    // Connect ProdConsBenchmark.workers[27].outMaster to input port ProdConsBenchmark.master.inWorkers[27]
    prodconsbenchmark_master_self->__inWorkers[27] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[27]->__outMaster;
    // Connect ProdConsBenchmark.workers[28].outMaster to input port ProdConsBenchmark.master.inWorkers[28]
    prodconsbenchmark_master_self->__inWorkers[28] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[28]->__outMaster;
    // Connect ProdConsBenchmark.workers[29].outMaster to input port ProdConsBenchmark.master.inWorkers[29]
    prodconsbenchmark_master_self->__inWorkers[29] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[29]->__outMaster;
    // Connect ProdConsBenchmark.workers[30].outMaster to input port ProdConsBenchmark.master.inWorkers[30]
    prodconsbenchmark_master_self->__inWorkers[30] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[30]->__outMaster;
    // Connect ProdConsBenchmark.workers[31].outMaster to input port ProdConsBenchmark.master.inWorkers[31]
    prodconsbenchmark_master_self->__inWorkers[31] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[31]->__outMaster;
    // Connect ProdConsBenchmark.workers[32].outMaster to input port ProdConsBenchmark.master.inWorkers[32]
    prodconsbenchmark_master_self->__inWorkers[32] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[32]->__outMaster;
    // Connect ProdConsBenchmark.workers[33].outMaster to input port ProdConsBenchmark.master.inWorkers[33]
    prodconsbenchmark_master_self->__inWorkers[33] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[33]->__outMaster;
    // Connect ProdConsBenchmark.workers[34].outMaster to input port ProdConsBenchmark.master.inWorkers[34]
    prodconsbenchmark_master_self->__inWorkers[34] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[34]->__outMaster;
    // Connect ProdConsBenchmark.workers[35].outMaster to input port ProdConsBenchmark.master.inWorkers[35]
    prodconsbenchmark_master_self->__inWorkers[35] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[35]->__outMaster;
    // Connect ProdConsBenchmark.workers[36].outMaster to input port ProdConsBenchmark.master.inWorkers[36]
    prodconsbenchmark_master_self->__inWorkers[36] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[36]->__outMaster;
    // Connect ProdConsBenchmark.workers[37].outMaster to input port ProdConsBenchmark.master.inWorkers[37]
    prodconsbenchmark_master_self->__inWorkers[37] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[37]->__outMaster;
    // Connect ProdConsBenchmark.workers[38].outMaster to input port ProdConsBenchmark.master.inWorkers[38]
    prodconsbenchmark_master_self->__inWorkers[38] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[38]->__outMaster;
    // Connect ProdConsBenchmark.workers[39].outMaster to input port ProdConsBenchmark.master.inWorkers[39]
    prodconsbenchmark_master_self->__inWorkers[39] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[39]->__outMaster;
    // Connect ProdConsBenchmark.workers[40].outMaster to input port ProdConsBenchmark.master.inWorkers[40]
    prodconsbenchmark_master_self->__inWorkers[40] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[40]->__outMaster;
    // Connect ProdConsBenchmark.workers[41].outMaster to input port ProdConsBenchmark.master.inWorkers[41]
    prodconsbenchmark_master_self->__inWorkers[41] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[41]->__outMaster;
    // Connect ProdConsBenchmark.workers[42].outMaster to input port ProdConsBenchmark.master.inWorkers[42]
    prodconsbenchmark_master_self->__inWorkers[42] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[42]->__outMaster;
    // Connect ProdConsBenchmark.workers[43].outMaster to input port ProdConsBenchmark.master.inWorkers[43]
    prodconsbenchmark_master_self->__inWorkers[43] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[43]->__outMaster;
    // Connect ProdConsBenchmark.workers[44].outMaster to input port ProdConsBenchmark.master.inWorkers[44]
    prodconsbenchmark_master_self->__inWorkers[44] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[44]->__outMaster;
    // Connect ProdConsBenchmark.workers[45].outMaster to input port ProdConsBenchmark.master.inWorkers[45]
    prodconsbenchmark_master_self->__inWorkers[45] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[45]->__outMaster;
    // Connect ProdConsBenchmark.workers[46].outMaster to input port ProdConsBenchmark.master.inWorkers[46]
    prodconsbenchmark_master_self->__inWorkers[46] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[46]->__outMaster;
    // Connect ProdConsBenchmark.workers[47].outMaster to input port ProdConsBenchmark.master.inWorkers[47]
    prodconsbenchmark_master_self->__inWorkers[47] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[47]->__outMaster;
    // Connect ProdConsBenchmark.workers[48].outMaster to input port ProdConsBenchmark.master.inWorkers[48]
    prodconsbenchmark_master_self->__inWorkers[48] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[48]->__outMaster;
    // Connect ProdConsBenchmark.workers[49].outMaster to input port ProdConsBenchmark.master.inWorkers[49]
    prodconsbenchmark_master_self->__inWorkers[49] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[49]->__outMaster;
    // Connect ProdConsBenchmark.workers[50].outMaster to input port ProdConsBenchmark.master.inWorkers[50]
    prodconsbenchmark_master_self->__inWorkers[50] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[50]->__outMaster;
    // Connect ProdConsBenchmark.workers[51].outMaster to input port ProdConsBenchmark.master.inWorkers[51]
    prodconsbenchmark_master_self->__inWorkers[51] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[51]->__outMaster;
    // Connect ProdConsBenchmark.workers[52].outMaster to input port ProdConsBenchmark.master.inWorkers[52]
    prodconsbenchmark_master_self->__inWorkers[52] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[52]->__outMaster;
    // Connect ProdConsBenchmark.workers[53].outMaster to input port ProdConsBenchmark.master.inWorkers[53]
    prodconsbenchmark_master_self->__inWorkers[53] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[53]->__outMaster;
    // Connect ProdConsBenchmark.workers[54].outMaster to input port ProdConsBenchmark.master.inWorkers[54]
    prodconsbenchmark_master_self->__inWorkers[54] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[54]->__outMaster;
    // Connect ProdConsBenchmark.workers[55].outMaster to input port ProdConsBenchmark.master.inWorkers[55]
    prodconsbenchmark_master_self->__inWorkers[55] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[55]->__outMaster;
    // Connect ProdConsBenchmark.workers[56].outMaster to input port ProdConsBenchmark.master.inWorkers[56]
    prodconsbenchmark_master_self->__inWorkers[56] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[56]->__outMaster;
    // Connect ProdConsBenchmark.workers[57].outMaster to input port ProdConsBenchmark.master.inWorkers[57]
    prodconsbenchmark_master_self->__inWorkers[57] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[57]->__outMaster;
    // Connect ProdConsBenchmark.workers[58].outMaster to input port ProdConsBenchmark.master.inWorkers[58]
    prodconsbenchmark_master_self->__inWorkers[58] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[58]->__outMaster;
    // Connect ProdConsBenchmark.workers[59].outMaster to input port ProdConsBenchmark.master.inWorkers[59]
    prodconsbenchmark_master_self->__inWorkers[59] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[59]->__outMaster;
    // Connect ProdConsBenchmark.workers[60].outMaster to input port ProdConsBenchmark.master.inWorkers[60]
    prodconsbenchmark_master_self->__inWorkers[60] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[60]->__outMaster;
    // Connect ProdConsBenchmark.workers[61].outMaster to input port ProdConsBenchmark.master.inWorkers[61]
    prodconsbenchmark_master_self->__inWorkers[61] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[61]->__outMaster;
    // Connect ProdConsBenchmark.workers[62].outMaster to input port ProdConsBenchmark.master.inWorkers[62]
    prodconsbenchmark_master_self->__inWorkers[62] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[62]->__outMaster;
    // Connect ProdConsBenchmark.workers[63].outMaster to input port ProdConsBenchmark.master.inWorkers[63]
    prodconsbenchmark_master_self->__inWorkers[63] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[63]->__outMaster;
    // Connect ProdConsBenchmark.workers[64].outMaster to input port ProdConsBenchmark.master.inWorkers[64]
    prodconsbenchmark_master_self->__inWorkers[64] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[64]->__outMaster;
    // Connect ProdConsBenchmark.workers[65].outMaster to input port ProdConsBenchmark.master.inWorkers[65]
    prodconsbenchmark_master_self->__inWorkers[65] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[65]->__outMaster;
    // Connect ProdConsBenchmark.workers[66].outMaster to input port ProdConsBenchmark.master.inWorkers[66]
    prodconsbenchmark_master_self->__inWorkers[66] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[66]->__outMaster;
    // Connect ProdConsBenchmark.workers[67].outMaster to input port ProdConsBenchmark.master.inWorkers[67]
    prodconsbenchmark_master_self->__inWorkers[67] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[67]->__outMaster;
    // Connect ProdConsBenchmark.workers[68].outMaster to input port ProdConsBenchmark.master.inWorkers[68]
    prodconsbenchmark_master_self->__inWorkers[68] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[68]->__outMaster;
    // Connect ProdConsBenchmark.workers[69].outMaster to input port ProdConsBenchmark.master.inWorkers[69]
    prodconsbenchmark_master_self->__inWorkers[69] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[69]->__outMaster;
    // Connect ProdConsBenchmark.workers[70].outMaster to input port ProdConsBenchmark.master.inWorkers[70]
    prodconsbenchmark_master_self->__inWorkers[70] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[70]->__outMaster;
    // Connect ProdConsBenchmark.workers[71].outMaster to input port ProdConsBenchmark.master.inWorkers[71]
    prodconsbenchmark_master_self->__inWorkers[71] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[71]->__outMaster;
    // Connect ProdConsBenchmark.workers[72].outMaster to input port ProdConsBenchmark.master.inWorkers[72]
    prodconsbenchmark_master_self->__inWorkers[72] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[72]->__outMaster;
    // Connect ProdConsBenchmark.workers[73].outMaster to input port ProdConsBenchmark.master.inWorkers[73]
    prodconsbenchmark_master_self->__inWorkers[73] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[73]->__outMaster;
    // Connect ProdConsBenchmark.workers[74].outMaster to input port ProdConsBenchmark.master.inWorkers[74]
    prodconsbenchmark_master_self->__inWorkers[74] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[74]->__outMaster;
    // Connect ProdConsBenchmark.workers[75].outMaster to input port ProdConsBenchmark.master.inWorkers[75]
    prodconsbenchmark_master_self->__inWorkers[75] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[75]->__outMaster;
    // Connect ProdConsBenchmark.workers[76].outMaster to input port ProdConsBenchmark.master.inWorkers[76]
    prodconsbenchmark_master_self->__inWorkers[76] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[76]->__outMaster;
    // Connect ProdConsBenchmark.workers[77].outMaster to input port ProdConsBenchmark.master.inWorkers[77]
    prodconsbenchmark_master_self->__inWorkers[77] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[77]->__outMaster;
    // Connect ProdConsBenchmark.workers[78].outMaster to input port ProdConsBenchmark.master.inWorkers[78]
    prodconsbenchmark_master_self->__inWorkers[78] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[78]->__outMaster;
    // Connect ProdConsBenchmark.workers[79].outMaster to input port ProdConsBenchmark.master.inWorkers[79]
    prodconsbenchmark_master_self->__inWorkers[79] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[79]->__outMaster;
    // Connect ProdConsBenchmark.workers[80].outMaster to input port ProdConsBenchmark.master.inWorkers[80]
    prodconsbenchmark_master_self->__inWorkers[80] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[80]->__outMaster;
    // Connect ProdConsBenchmark.workers[81].outMaster to input port ProdConsBenchmark.master.inWorkers[81]
    prodconsbenchmark_master_self->__inWorkers[81] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[81]->__outMaster;
    // Connect ProdConsBenchmark.workers[82].outMaster to input port ProdConsBenchmark.master.inWorkers[82]
    prodconsbenchmark_master_self->__inWorkers[82] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[82]->__outMaster;
    // Connect ProdConsBenchmark.workers[83].outMaster to input port ProdConsBenchmark.master.inWorkers[83]
    prodconsbenchmark_master_self->__inWorkers[83] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[83]->__outMaster;
    // Connect ProdConsBenchmark.workers[84].outMaster to input port ProdConsBenchmark.master.inWorkers[84]
    prodconsbenchmark_master_self->__inWorkers[84] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[84]->__outMaster;
    // Connect ProdConsBenchmark.workers[85].outMaster to input port ProdConsBenchmark.master.inWorkers[85]
    prodconsbenchmark_master_self->__inWorkers[85] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[85]->__outMaster;
    // Connect ProdConsBenchmark.workers[86].outMaster to input port ProdConsBenchmark.master.inWorkers[86]
    prodconsbenchmark_master_self->__inWorkers[86] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[86]->__outMaster;
    // Connect ProdConsBenchmark.workers[87].outMaster to input port ProdConsBenchmark.master.inWorkers[87]
    prodconsbenchmark_master_self->__inWorkers[87] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[87]->__outMaster;
    // Connect ProdConsBenchmark.workers[88].outMaster to input port ProdConsBenchmark.master.inWorkers[88]
    prodconsbenchmark_master_self->__inWorkers[88] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[88]->__outMaster;
    // Connect ProdConsBenchmark.workers[89].outMaster to input port ProdConsBenchmark.master.inWorkers[89]
    prodconsbenchmark_master_self->__inWorkers[89] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[89]->__outMaster;
    // Connect ProdConsBenchmark.workers[90].outMaster to input port ProdConsBenchmark.master.inWorkers[90]
    prodconsbenchmark_master_self->__inWorkers[90] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[90]->__outMaster;
    // Connect ProdConsBenchmark.workers[91].outMaster to input port ProdConsBenchmark.master.inWorkers[91]
    prodconsbenchmark_master_self->__inWorkers[91] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[91]->__outMaster;
    // Connect ProdConsBenchmark.workers[92].outMaster to input port ProdConsBenchmark.master.inWorkers[92]
    prodconsbenchmark_master_self->__inWorkers[92] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[92]->__outMaster;
    // Connect ProdConsBenchmark.workers[93].outMaster to input port ProdConsBenchmark.master.inWorkers[93]
    prodconsbenchmark_master_self->__inWorkers[93] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[93]->__outMaster;
    // Connect ProdConsBenchmark.workers[94].outMaster to input port ProdConsBenchmark.master.inWorkers[94]
    prodconsbenchmark_master_self->__inWorkers[94] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[94]->__outMaster;
    // Connect ProdConsBenchmark.workers[95].outMaster to input port ProdConsBenchmark.master.inWorkers[95]
    prodconsbenchmark_master_self->__inWorkers[95] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[95]->__outMaster;
    // Connect ProdConsBenchmark.workers[96].outMaster to input port ProdConsBenchmark.master.inWorkers[96]
    prodconsbenchmark_master_self->__inWorkers[96] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[96]->__outMaster;
    // Connect ProdConsBenchmark.workers[97].outMaster to input port ProdConsBenchmark.master.inWorkers[97]
    prodconsbenchmark_master_self->__inWorkers[97] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[97]->__outMaster;
    // Connect ProdConsBenchmark.workers[98].outMaster to input port ProdConsBenchmark.master.inWorkers[98]
    prodconsbenchmark_master_self->__inWorkers[98] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[98]->__outMaster;
    // Connect ProdConsBenchmark.workers[99].outMaster to input port ProdConsBenchmark.master.inWorkers[99]
    prodconsbenchmark_master_self->__inWorkers[99] = (master_inWorkers_t*)&prodconsbenchmark_workers_self[99]->__outMaster;
    // Connect ProdConsBenchmark.master.outWorkers[0] to input port ProdConsBenchmark.workers[0].inMaster
    prodconsbenchmark_workers_self[0]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[0];
    // Connect ProdConsBenchmark.master.outWorkers[1] to input port ProdConsBenchmark.workers[1].inMaster
    prodconsbenchmark_workers_self[1]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[1];
    // Connect ProdConsBenchmark.master.outWorkers[2] to input port ProdConsBenchmark.workers[2].inMaster
    prodconsbenchmark_workers_self[2]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[2];
    // Connect ProdConsBenchmark.master.outWorkers[3] to input port ProdConsBenchmark.workers[3].inMaster
    prodconsbenchmark_workers_self[3]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[3];
    // Connect ProdConsBenchmark.master.outWorkers[4] to input port ProdConsBenchmark.workers[4].inMaster
    prodconsbenchmark_workers_self[4]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[4];
    // Connect ProdConsBenchmark.master.outWorkers[5] to input port ProdConsBenchmark.workers[5].inMaster
    prodconsbenchmark_workers_self[5]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[5];
    // Connect ProdConsBenchmark.master.outWorkers[6] to input port ProdConsBenchmark.workers[6].inMaster
    prodconsbenchmark_workers_self[6]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[6];
    // Connect ProdConsBenchmark.master.outWorkers[7] to input port ProdConsBenchmark.workers[7].inMaster
    prodconsbenchmark_workers_self[7]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[7];
    // Connect ProdConsBenchmark.master.outWorkers[8] to input port ProdConsBenchmark.workers[8].inMaster
    prodconsbenchmark_workers_self[8]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[8];
    // Connect ProdConsBenchmark.master.outWorkers[9] to input port ProdConsBenchmark.workers[9].inMaster
    prodconsbenchmark_workers_self[9]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[9];
    // Connect ProdConsBenchmark.master.outWorkers[10] to input port ProdConsBenchmark.workers[10].inMaster
    prodconsbenchmark_workers_self[10]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[10];
    // Connect ProdConsBenchmark.master.outWorkers[11] to input port ProdConsBenchmark.workers[11].inMaster
    prodconsbenchmark_workers_self[11]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[11];
    // Connect ProdConsBenchmark.master.outWorkers[12] to input port ProdConsBenchmark.workers[12].inMaster
    prodconsbenchmark_workers_self[12]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[12];
    // Connect ProdConsBenchmark.master.outWorkers[13] to input port ProdConsBenchmark.workers[13].inMaster
    prodconsbenchmark_workers_self[13]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[13];
    // Connect ProdConsBenchmark.master.outWorkers[14] to input port ProdConsBenchmark.workers[14].inMaster
    prodconsbenchmark_workers_self[14]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[14];
    // Connect ProdConsBenchmark.master.outWorkers[15] to input port ProdConsBenchmark.workers[15].inMaster
    prodconsbenchmark_workers_self[15]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[15];
    // Connect ProdConsBenchmark.master.outWorkers[16] to input port ProdConsBenchmark.workers[16].inMaster
    prodconsbenchmark_workers_self[16]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[16];
    // Connect ProdConsBenchmark.master.outWorkers[17] to input port ProdConsBenchmark.workers[17].inMaster
    prodconsbenchmark_workers_self[17]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[17];
    // Connect ProdConsBenchmark.master.outWorkers[18] to input port ProdConsBenchmark.workers[18].inMaster
    prodconsbenchmark_workers_self[18]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[18];
    // Connect ProdConsBenchmark.master.outWorkers[19] to input port ProdConsBenchmark.workers[19].inMaster
    prodconsbenchmark_workers_self[19]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[19];
    // Connect ProdConsBenchmark.master.outWorkers[20] to input port ProdConsBenchmark.workers[20].inMaster
    prodconsbenchmark_workers_self[20]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[20];
    // Connect ProdConsBenchmark.master.outWorkers[21] to input port ProdConsBenchmark.workers[21].inMaster
    prodconsbenchmark_workers_self[21]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[21];
    // Connect ProdConsBenchmark.master.outWorkers[22] to input port ProdConsBenchmark.workers[22].inMaster
    prodconsbenchmark_workers_self[22]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[22];
    // Connect ProdConsBenchmark.master.outWorkers[23] to input port ProdConsBenchmark.workers[23].inMaster
    prodconsbenchmark_workers_self[23]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[23];
    // Connect ProdConsBenchmark.master.outWorkers[24] to input port ProdConsBenchmark.workers[24].inMaster
    prodconsbenchmark_workers_self[24]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[24];
    // Connect ProdConsBenchmark.master.outWorkers[25] to input port ProdConsBenchmark.workers[25].inMaster
    prodconsbenchmark_workers_self[25]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[25];
    // Connect ProdConsBenchmark.master.outWorkers[26] to input port ProdConsBenchmark.workers[26].inMaster
    prodconsbenchmark_workers_self[26]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[26];
    // Connect ProdConsBenchmark.master.outWorkers[27] to input port ProdConsBenchmark.workers[27].inMaster
    prodconsbenchmark_workers_self[27]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[27];
    // Connect ProdConsBenchmark.master.outWorkers[28] to input port ProdConsBenchmark.workers[28].inMaster
    prodconsbenchmark_workers_self[28]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[28];
    // Connect ProdConsBenchmark.master.outWorkers[29] to input port ProdConsBenchmark.workers[29].inMaster
    prodconsbenchmark_workers_self[29]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[29];
    // Connect ProdConsBenchmark.master.outWorkers[30] to input port ProdConsBenchmark.workers[30].inMaster
    prodconsbenchmark_workers_self[30]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[30];
    // Connect ProdConsBenchmark.master.outWorkers[31] to input port ProdConsBenchmark.workers[31].inMaster
    prodconsbenchmark_workers_self[31]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[31];
    // Connect ProdConsBenchmark.master.outWorkers[32] to input port ProdConsBenchmark.workers[32].inMaster
    prodconsbenchmark_workers_self[32]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[32];
    // Connect ProdConsBenchmark.master.outWorkers[33] to input port ProdConsBenchmark.workers[33].inMaster
    prodconsbenchmark_workers_self[33]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[33];
    // Connect ProdConsBenchmark.master.outWorkers[34] to input port ProdConsBenchmark.workers[34].inMaster
    prodconsbenchmark_workers_self[34]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[34];
    // Connect ProdConsBenchmark.master.outWorkers[35] to input port ProdConsBenchmark.workers[35].inMaster
    prodconsbenchmark_workers_self[35]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[35];
    // Connect ProdConsBenchmark.master.outWorkers[36] to input port ProdConsBenchmark.workers[36].inMaster
    prodconsbenchmark_workers_self[36]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[36];
    // Connect ProdConsBenchmark.master.outWorkers[37] to input port ProdConsBenchmark.workers[37].inMaster
    prodconsbenchmark_workers_self[37]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[37];
    // Connect ProdConsBenchmark.master.outWorkers[38] to input port ProdConsBenchmark.workers[38].inMaster
    prodconsbenchmark_workers_self[38]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[38];
    // Connect ProdConsBenchmark.master.outWorkers[39] to input port ProdConsBenchmark.workers[39].inMaster
    prodconsbenchmark_workers_self[39]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[39];
    // Connect ProdConsBenchmark.master.outWorkers[40] to input port ProdConsBenchmark.workers[40].inMaster
    prodconsbenchmark_workers_self[40]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[40];
    // Connect ProdConsBenchmark.master.outWorkers[41] to input port ProdConsBenchmark.workers[41].inMaster
    prodconsbenchmark_workers_self[41]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[41];
    // Connect ProdConsBenchmark.master.outWorkers[42] to input port ProdConsBenchmark.workers[42].inMaster
    prodconsbenchmark_workers_self[42]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[42];
    // Connect ProdConsBenchmark.master.outWorkers[43] to input port ProdConsBenchmark.workers[43].inMaster
    prodconsbenchmark_workers_self[43]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[43];
    // Connect ProdConsBenchmark.master.outWorkers[44] to input port ProdConsBenchmark.workers[44].inMaster
    prodconsbenchmark_workers_self[44]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[44];
    // Connect ProdConsBenchmark.master.outWorkers[45] to input port ProdConsBenchmark.workers[45].inMaster
    prodconsbenchmark_workers_self[45]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[45];
    // Connect ProdConsBenchmark.master.outWorkers[46] to input port ProdConsBenchmark.workers[46].inMaster
    prodconsbenchmark_workers_self[46]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[46];
    // Connect ProdConsBenchmark.master.outWorkers[47] to input port ProdConsBenchmark.workers[47].inMaster
    prodconsbenchmark_workers_self[47]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[47];
    // Connect ProdConsBenchmark.master.outWorkers[48] to input port ProdConsBenchmark.workers[48].inMaster
    prodconsbenchmark_workers_self[48]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[48];
    // Connect ProdConsBenchmark.master.outWorkers[49] to input port ProdConsBenchmark.workers[49].inMaster
    prodconsbenchmark_workers_self[49]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[49];
    // Connect ProdConsBenchmark.master.outWorkers[50] to input port ProdConsBenchmark.workers[50].inMaster
    prodconsbenchmark_workers_self[50]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[50];
    // Connect ProdConsBenchmark.master.outWorkers[51] to input port ProdConsBenchmark.workers[51].inMaster
    prodconsbenchmark_workers_self[51]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[51];
    // Connect ProdConsBenchmark.master.outWorkers[52] to input port ProdConsBenchmark.workers[52].inMaster
    prodconsbenchmark_workers_self[52]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[52];
    // Connect ProdConsBenchmark.master.outWorkers[53] to input port ProdConsBenchmark.workers[53].inMaster
    prodconsbenchmark_workers_self[53]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[53];
    // Connect ProdConsBenchmark.master.outWorkers[54] to input port ProdConsBenchmark.workers[54].inMaster
    prodconsbenchmark_workers_self[54]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[54];
    // Connect ProdConsBenchmark.master.outWorkers[55] to input port ProdConsBenchmark.workers[55].inMaster
    prodconsbenchmark_workers_self[55]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[55];
    // Connect ProdConsBenchmark.master.outWorkers[56] to input port ProdConsBenchmark.workers[56].inMaster
    prodconsbenchmark_workers_self[56]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[56];
    // Connect ProdConsBenchmark.master.outWorkers[57] to input port ProdConsBenchmark.workers[57].inMaster
    prodconsbenchmark_workers_self[57]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[57];
    // Connect ProdConsBenchmark.master.outWorkers[58] to input port ProdConsBenchmark.workers[58].inMaster
    prodconsbenchmark_workers_self[58]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[58];
    // Connect ProdConsBenchmark.master.outWorkers[59] to input port ProdConsBenchmark.workers[59].inMaster
    prodconsbenchmark_workers_self[59]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[59];
    // Connect ProdConsBenchmark.master.outWorkers[60] to input port ProdConsBenchmark.workers[60].inMaster
    prodconsbenchmark_workers_self[60]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[60];
    // Connect ProdConsBenchmark.master.outWorkers[61] to input port ProdConsBenchmark.workers[61].inMaster
    prodconsbenchmark_workers_self[61]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[61];
    // Connect ProdConsBenchmark.master.outWorkers[62] to input port ProdConsBenchmark.workers[62].inMaster
    prodconsbenchmark_workers_self[62]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[62];
    // Connect ProdConsBenchmark.master.outWorkers[63] to input port ProdConsBenchmark.workers[63].inMaster
    prodconsbenchmark_workers_self[63]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[63];
    // Connect ProdConsBenchmark.master.outWorkers[64] to input port ProdConsBenchmark.workers[64].inMaster
    prodconsbenchmark_workers_self[64]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[64];
    // Connect ProdConsBenchmark.master.outWorkers[65] to input port ProdConsBenchmark.workers[65].inMaster
    prodconsbenchmark_workers_self[65]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[65];
    // Connect ProdConsBenchmark.master.outWorkers[66] to input port ProdConsBenchmark.workers[66].inMaster
    prodconsbenchmark_workers_self[66]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[66];
    // Connect ProdConsBenchmark.master.outWorkers[67] to input port ProdConsBenchmark.workers[67].inMaster
    prodconsbenchmark_workers_self[67]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[67];
    // Connect ProdConsBenchmark.master.outWorkers[68] to input port ProdConsBenchmark.workers[68].inMaster
    prodconsbenchmark_workers_self[68]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[68];
    // Connect ProdConsBenchmark.master.outWorkers[69] to input port ProdConsBenchmark.workers[69].inMaster
    prodconsbenchmark_workers_self[69]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[69];
    // Connect ProdConsBenchmark.master.outWorkers[70] to input port ProdConsBenchmark.workers[70].inMaster
    prodconsbenchmark_workers_self[70]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[70];
    // Connect ProdConsBenchmark.master.outWorkers[71] to input port ProdConsBenchmark.workers[71].inMaster
    prodconsbenchmark_workers_self[71]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[71];
    // Connect ProdConsBenchmark.master.outWorkers[72] to input port ProdConsBenchmark.workers[72].inMaster
    prodconsbenchmark_workers_self[72]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[72];
    // Connect ProdConsBenchmark.master.outWorkers[73] to input port ProdConsBenchmark.workers[73].inMaster
    prodconsbenchmark_workers_self[73]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[73];
    // Connect ProdConsBenchmark.master.outWorkers[74] to input port ProdConsBenchmark.workers[74].inMaster
    prodconsbenchmark_workers_self[74]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[74];
    // Connect ProdConsBenchmark.master.outWorkers[75] to input port ProdConsBenchmark.workers[75].inMaster
    prodconsbenchmark_workers_self[75]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[75];
    // Connect ProdConsBenchmark.master.outWorkers[76] to input port ProdConsBenchmark.workers[76].inMaster
    prodconsbenchmark_workers_self[76]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[76];
    // Connect ProdConsBenchmark.master.outWorkers[77] to input port ProdConsBenchmark.workers[77].inMaster
    prodconsbenchmark_workers_self[77]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[77];
    // Connect ProdConsBenchmark.master.outWorkers[78] to input port ProdConsBenchmark.workers[78].inMaster
    prodconsbenchmark_workers_self[78]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[78];
    // Connect ProdConsBenchmark.master.outWorkers[79] to input port ProdConsBenchmark.workers[79].inMaster
    prodconsbenchmark_workers_self[79]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[79];
    // Connect ProdConsBenchmark.master.outWorkers[80] to input port ProdConsBenchmark.workers[80].inMaster
    prodconsbenchmark_workers_self[80]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[80];
    // Connect ProdConsBenchmark.master.outWorkers[81] to input port ProdConsBenchmark.workers[81].inMaster
    prodconsbenchmark_workers_self[81]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[81];
    // Connect ProdConsBenchmark.master.outWorkers[82] to input port ProdConsBenchmark.workers[82].inMaster
    prodconsbenchmark_workers_self[82]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[82];
    // Connect ProdConsBenchmark.master.outWorkers[83] to input port ProdConsBenchmark.workers[83].inMaster
    prodconsbenchmark_workers_self[83]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[83];
    // Connect ProdConsBenchmark.master.outWorkers[84] to input port ProdConsBenchmark.workers[84].inMaster
    prodconsbenchmark_workers_self[84]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[84];
    // Connect ProdConsBenchmark.master.outWorkers[85] to input port ProdConsBenchmark.workers[85].inMaster
    prodconsbenchmark_workers_self[85]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[85];
    // Connect ProdConsBenchmark.master.outWorkers[86] to input port ProdConsBenchmark.workers[86].inMaster
    prodconsbenchmark_workers_self[86]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[86];
    // Connect ProdConsBenchmark.master.outWorkers[87] to input port ProdConsBenchmark.workers[87].inMaster
    prodconsbenchmark_workers_self[87]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[87];
    // Connect ProdConsBenchmark.master.outWorkers[88] to input port ProdConsBenchmark.workers[88].inMaster
    prodconsbenchmark_workers_self[88]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[88];
    // Connect ProdConsBenchmark.master.outWorkers[89] to input port ProdConsBenchmark.workers[89].inMaster
    prodconsbenchmark_workers_self[89]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[89];
    // Connect ProdConsBenchmark.master.outWorkers[90] to input port ProdConsBenchmark.workers[90].inMaster
    prodconsbenchmark_workers_self[90]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[90];
    // Connect ProdConsBenchmark.master.outWorkers[91] to input port ProdConsBenchmark.workers[91].inMaster
    prodconsbenchmark_workers_self[91]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[91];
    // Connect ProdConsBenchmark.master.outWorkers[92] to input port ProdConsBenchmark.workers[92].inMaster
    prodconsbenchmark_workers_self[92]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[92];
    // Connect ProdConsBenchmark.master.outWorkers[93] to input port ProdConsBenchmark.workers[93].inMaster
    prodconsbenchmark_workers_self[93]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[93];
    // Connect ProdConsBenchmark.master.outWorkers[94] to input port ProdConsBenchmark.workers[94].inMaster
    prodconsbenchmark_workers_self[94]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[94];
    // Connect ProdConsBenchmark.master.outWorkers[95] to input port ProdConsBenchmark.workers[95].inMaster
    prodconsbenchmark_workers_self[95]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[95];
    // Connect ProdConsBenchmark.master.outWorkers[96] to input port ProdConsBenchmark.workers[96].inMaster
    prodconsbenchmark_workers_self[96]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[96];
    // Connect ProdConsBenchmark.master.outWorkers[97] to input port ProdConsBenchmark.workers[97].inMaster
    prodconsbenchmark_workers_self[97]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[97];
    // Connect ProdConsBenchmark.master.outWorkers[98] to input port ProdConsBenchmark.workers[98].inMaster
    prodconsbenchmark_workers_self[98]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[98];
    // Connect ProdConsBenchmark.master.outWorkers[99] to input port ProdConsBenchmark.workers[99].inMaster
    prodconsbenchmark_workers_self[99]->__inMaster = (worker_inMaster_t*)&prodconsbenchmark_master_self->__outWorkers[99];
    // Connect inputs and outputs for reactor ProdConsBenchmark.master.
    // END Connect inputs and outputs for reactor ProdConsBenchmark.master.
    // Connect inputs and outputs for reactor ProdConsBenchmark.runner.
    // END Connect inputs and outputs for reactor ProdConsBenchmark.runner.
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers.
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers.
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[0].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[0].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[1].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[1].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[2].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[2].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[3].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[3].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[4].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[4].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[5].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[5].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[6].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[6].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[7].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[7].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[8].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[8].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[9].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[9].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[10].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[10].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[11].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[11].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[12].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[12].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[13].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[13].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[14].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[14].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[15].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[15].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[16].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[16].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[17].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[17].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[18].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[18].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[19].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[19].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[20].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[20].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[21].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[21].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[22].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[22].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[23].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[23].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[24].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[24].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[25].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[25].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[26].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[26].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[27].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[27].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[28].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[28].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[29].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[29].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[30].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[30].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[31].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[31].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[32].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[32].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[33].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[33].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[34].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[34].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[35].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[35].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[36].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[36].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[37].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[37].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[38].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[38].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[39].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[39].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[40].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[40].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[41].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[41].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[42].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[42].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[43].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[43].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[44].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[44].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[45].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[45].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[46].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[46].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[47].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[47].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[48].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[48].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[49].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[49].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[50].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[50].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[51].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[51].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[52].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[52].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[53].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[53].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[54].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[54].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[55].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[55].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[56].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[56].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[57].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[57].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[58].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[58].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[59].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[59].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[60].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[60].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[61].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[61].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[62].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[62].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[63].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[63].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[64].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[64].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[65].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[65].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[66].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[66].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[67].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[67].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[68].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[68].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[69].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[69].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[70].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[70].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[71].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[71].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[72].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[72].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[73].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[73].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[74].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[74].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[75].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[75].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[76].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[76].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[77].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[77].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[78].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[78].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[79].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[79].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[80].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[80].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[81].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[81].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[82].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[82].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[83].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[83].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[84].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[84].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[85].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[85].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[86].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[86].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[87].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[87].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[88].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[88].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[89].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[89].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[90].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[90].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[91].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[91].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[92].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[92].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[93].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[93].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[94].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[94].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[95].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[95].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[96].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[96].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[97].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[97].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[98].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[98].
    // Connect inputs and outputs for reactor ProdConsBenchmark.workers[99].
    // END Connect inputs and outputs for reactor ProdConsBenchmark.workers[99].
    // Connect PortInstance ProdConsBenchmark.runner.inStart, which gets data from reaction 0
    // of ProdConsBenchmark, to ProdConsBenchmark.runner.inStart.
    prodconsbenchmark_runner_self->__inStart = (benchmarkrunner_inStart_t*)&prodconsbenchmark_self->__runner.inStart;
    // END Connect inputs and outputs for reactor ProdConsBenchmark.
    // Add action ProdConsBenchmark.master.sendWorkMessages to array of is_present fields.
    __is_present_fields[0] 
            = &prodconsbenchmark_master_self->__sendWorkMessages.is_present;
    // Add action ProdConsBenchmark.runner.initBenchmark to array of is_present fields.
    __is_present_fields[1] 
            = &prodconsbenchmark_runner_self->__initBenchmark.is_present;
    // Add action ProdConsBenchmark.runner.cleanupIteration to array of is_present fields.
    __is_present_fields[2] 
            = &prodconsbenchmark_runner_self->__cleanupIteration.is_present;
    // Add action ProdConsBenchmark.runner.nextIteration to array of is_present fields.
    __is_present_fields[3] 
            = &prodconsbenchmark_runner_self->__nextIteration.is_present;
    // Add action ProdConsBenchmark.runner.finish to array of is_present fields.
    __is_present_fields[4] 
            = &prodconsbenchmark_runner_self->__finish.is_present;
    // Add port ProdConsBenchmark.runner.inStart to array of is_present fields.
    __is_present_fields[5] 
            = &prodconsbenchmark_self->__runner.inStart.
            is_present;
    // Add port ProdConsBenchmark.master.outFinished to array of is_present fields.
    __is_present_fields[6] = &prodconsbenchmark_master_self->__outFinished.is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[7] = &prodconsbenchmark_master_self->__outWorkers[0].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[8] = &prodconsbenchmark_master_self->__outWorkers[1].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[9] = &prodconsbenchmark_master_self->__outWorkers[2].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[10] = &prodconsbenchmark_master_self->__outWorkers[3].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[11] = &prodconsbenchmark_master_self->__outWorkers[4].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[12] = &prodconsbenchmark_master_self->__outWorkers[5].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[13] = &prodconsbenchmark_master_self->__outWorkers[6].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[14] = &prodconsbenchmark_master_self->__outWorkers[7].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[15] = &prodconsbenchmark_master_self->__outWorkers[8].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[16] = &prodconsbenchmark_master_self->__outWorkers[9].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[17] = &prodconsbenchmark_master_self->__outWorkers[10].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[18] = &prodconsbenchmark_master_self->__outWorkers[11].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[19] = &prodconsbenchmark_master_self->__outWorkers[12].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[20] = &prodconsbenchmark_master_self->__outWorkers[13].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[21] = &prodconsbenchmark_master_self->__outWorkers[14].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[22] = &prodconsbenchmark_master_self->__outWorkers[15].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[23] = &prodconsbenchmark_master_self->__outWorkers[16].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[24] = &prodconsbenchmark_master_self->__outWorkers[17].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[25] = &prodconsbenchmark_master_self->__outWorkers[18].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[26] = &prodconsbenchmark_master_self->__outWorkers[19].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[27] = &prodconsbenchmark_master_self->__outWorkers[20].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[28] = &prodconsbenchmark_master_self->__outWorkers[21].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[29] = &prodconsbenchmark_master_self->__outWorkers[22].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[30] = &prodconsbenchmark_master_self->__outWorkers[23].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[31] = &prodconsbenchmark_master_self->__outWorkers[24].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[32] = &prodconsbenchmark_master_self->__outWorkers[25].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[33] = &prodconsbenchmark_master_self->__outWorkers[26].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[34] = &prodconsbenchmark_master_self->__outWorkers[27].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[35] = &prodconsbenchmark_master_self->__outWorkers[28].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[36] = &prodconsbenchmark_master_self->__outWorkers[29].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[37] = &prodconsbenchmark_master_self->__outWorkers[30].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[38] = &prodconsbenchmark_master_self->__outWorkers[31].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[39] = &prodconsbenchmark_master_self->__outWorkers[32].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[40] = &prodconsbenchmark_master_self->__outWorkers[33].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[41] = &prodconsbenchmark_master_self->__outWorkers[34].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[42] = &prodconsbenchmark_master_self->__outWorkers[35].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[43] = &prodconsbenchmark_master_self->__outWorkers[36].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[44] = &prodconsbenchmark_master_self->__outWorkers[37].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[45] = &prodconsbenchmark_master_self->__outWorkers[38].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[46] = &prodconsbenchmark_master_self->__outWorkers[39].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[47] = &prodconsbenchmark_master_self->__outWorkers[40].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[48] = &prodconsbenchmark_master_self->__outWorkers[41].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[49] = &prodconsbenchmark_master_self->__outWorkers[42].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[50] = &prodconsbenchmark_master_self->__outWorkers[43].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[51] = &prodconsbenchmark_master_self->__outWorkers[44].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[52] = &prodconsbenchmark_master_self->__outWorkers[45].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[53] = &prodconsbenchmark_master_self->__outWorkers[46].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[54] = &prodconsbenchmark_master_self->__outWorkers[47].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[55] = &prodconsbenchmark_master_self->__outWorkers[48].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[56] = &prodconsbenchmark_master_self->__outWorkers[49].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[57] = &prodconsbenchmark_master_self->__outWorkers[50].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[58] = &prodconsbenchmark_master_self->__outWorkers[51].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[59] = &prodconsbenchmark_master_self->__outWorkers[52].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[60] = &prodconsbenchmark_master_self->__outWorkers[53].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[61] = &prodconsbenchmark_master_self->__outWorkers[54].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[62] = &prodconsbenchmark_master_self->__outWorkers[55].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[63] = &prodconsbenchmark_master_self->__outWorkers[56].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[64] = &prodconsbenchmark_master_self->__outWorkers[57].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[65] = &prodconsbenchmark_master_self->__outWorkers[58].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[66] = &prodconsbenchmark_master_self->__outWorkers[59].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[67] = &prodconsbenchmark_master_self->__outWorkers[60].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[68] = &prodconsbenchmark_master_self->__outWorkers[61].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[69] = &prodconsbenchmark_master_self->__outWorkers[62].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[70] = &prodconsbenchmark_master_self->__outWorkers[63].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[71] = &prodconsbenchmark_master_self->__outWorkers[64].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[72] = &prodconsbenchmark_master_self->__outWorkers[65].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[73] = &prodconsbenchmark_master_self->__outWorkers[66].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[74] = &prodconsbenchmark_master_self->__outWorkers[67].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[75] = &prodconsbenchmark_master_self->__outWorkers[68].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[76] = &prodconsbenchmark_master_self->__outWorkers[69].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[77] = &prodconsbenchmark_master_self->__outWorkers[70].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[78] = &prodconsbenchmark_master_self->__outWorkers[71].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[79] = &prodconsbenchmark_master_self->__outWorkers[72].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[80] = &prodconsbenchmark_master_self->__outWorkers[73].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[81] = &prodconsbenchmark_master_self->__outWorkers[74].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[82] = &prodconsbenchmark_master_self->__outWorkers[75].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[83] = &prodconsbenchmark_master_self->__outWorkers[76].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[84] = &prodconsbenchmark_master_self->__outWorkers[77].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[85] = &prodconsbenchmark_master_self->__outWorkers[78].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[86] = &prodconsbenchmark_master_self->__outWorkers[79].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[87] = &prodconsbenchmark_master_self->__outWorkers[80].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[88] = &prodconsbenchmark_master_self->__outWorkers[81].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[89] = &prodconsbenchmark_master_self->__outWorkers[82].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[90] = &prodconsbenchmark_master_self->__outWorkers[83].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[91] = &prodconsbenchmark_master_self->__outWorkers[84].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[92] = &prodconsbenchmark_master_self->__outWorkers[85].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[93] = &prodconsbenchmark_master_self->__outWorkers[86].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[94] = &prodconsbenchmark_master_self->__outWorkers[87].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[95] = &prodconsbenchmark_master_self->__outWorkers[88].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[96] = &prodconsbenchmark_master_self->__outWorkers[89].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[97] = &prodconsbenchmark_master_self->__outWorkers[90].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[98] = &prodconsbenchmark_master_self->__outWorkers[91].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[99] = &prodconsbenchmark_master_self->__outWorkers[92].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[100] = &prodconsbenchmark_master_self->__outWorkers[93].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[101] = &prodconsbenchmark_master_self->__outWorkers[94].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[102] = &prodconsbenchmark_master_self->__outWorkers[95].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[103] = &prodconsbenchmark_master_self->__outWorkers[96].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[104] = &prodconsbenchmark_master_self->__outWorkers[97].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[105] = &prodconsbenchmark_master_self->__outWorkers[98].is_present
    ;
    // Add port ProdConsBenchmark.master.outWorkers to array of is_present fields.
    __is_present_fields[106] = &prodconsbenchmark_master_self->__outWorkers[99].is_present
    ;
    // Add port ProdConsBenchmark.runner.outIterationStart to array of is_present fields.
    __is_present_fields[107] = &prodconsbenchmark_runner_self->__outIterationStart.is_present
    ;
    // Add port ProdConsBenchmark.runner.outInitializeStart to array of is_present fields.
    __is_present_fields[108] = &prodconsbenchmark_runner_self->__outInitializeStart.is_present
    ;
    // Add port ProdConsBenchmark.runner.outCleanupIterationStart to array of is_present fields.
    __is_present_fields[109] = &prodconsbenchmark_runner_self->__outCleanupIterationStart.is_present
    ;
    // Add port ProdConsBenchmark.workers[0].outMaster to array of is_present fields.
    __is_present_fields[110] = &prodconsbenchmark_workers_self[0]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[1].outMaster to array of is_present fields.
    __is_present_fields[111] = &prodconsbenchmark_workers_self[1]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[2].outMaster to array of is_present fields.
    __is_present_fields[112] = &prodconsbenchmark_workers_self[2]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[3].outMaster to array of is_present fields.
    __is_present_fields[113] = &prodconsbenchmark_workers_self[3]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[4].outMaster to array of is_present fields.
    __is_present_fields[114] = &prodconsbenchmark_workers_self[4]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[5].outMaster to array of is_present fields.
    __is_present_fields[115] = &prodconsbenchmark_workers_self[5]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[6].outMaster to array of is_present fields.
    __is_present_fields[116] = &prodconsbenchmark_workers_self[6]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[7].outMaster to array of is_present fields.
    __is_present_fields[117] = &prodconsbenchmark_workers_self[7]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[8].outMaster to array of is_present fields.
    __is_present_fields[118] = &prodconsbenchmark_workers_self[8]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[9].outMaster to array of is_present fields.
    __is_present_fields[119] = &prodconsbenchmark_workers_self[9]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[10].outMaster to array of is_present fields.
    __is_present_fields[120] = &prodconsbenchmark_workers_self[10]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[11].outMaster to array of is_present fields.
    __is_present_fields[121] = &prodconsbenchmark_workers_self[11]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[12].outMaster to array of is_present fields.
    __is_present_fields[122] = &prodconsbenchmark_workers_self[12]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[13].outMaster to array of is_present fields.
    __is_present_fields[123] = &prodconsbenchmark_workers_self[13]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[14].outMaster to array of is_present fields.
    __is_present_fields[124] = &prodconsbenchmark_workers_self[14]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[15].outMaster to array of is_present fields.
    __is_present_fields[125] = &prodconsbenchmark_workers_self[15]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[16].outMaster to array of is_present fields.
    __is_present_fields[126] = &prodconsbenchmark_workers_self[16]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[17].outMaster to array of is_present fields.
    __is_present_fields[127] = &prodconsbenchmark_workers_self[17]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[18].outMaster to array of is_present fields.
    __is_present_fields[128] = &prodconsbenchmark_workers_self[18]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[19].outMaster to array of is_present fields.
    __is_present_fields[129] = &prodconsbenchmark_workers_self[19]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[20].outMaster to array of is_present fields.
    __is_present_fields[130] = &prodconsbenchmark_workers_self[20]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[21].outMaster to array of is_present fields.
    __is_present_fields[131] = &prodconsbenchmark_workers_self[21]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[22].outMaster to array of is_present fields.
    __is_present_fields[132] = &prodconsbenchmark_workers_self[22]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[23].outMaster to array of is_present fields.
    __is_present_fields[133] = &prodconsbenchmark_workers_self[23]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[24].outMaster to array of is_present fields.
    __is_present_fields[134] = &prodconsbenchmark_workers_self[24]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[25].outMaster to array of is_present fields.
    __is_present_fields[135] = &prodconsbenchmark_workers_self[25]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[26].outMaster to array of is_present fields.
    __is_present_fields[136] = &prodconsbenchmark_workers_self[26]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[27].outMaster to array of is_present fields.
    __is_present_fields[137] = &prodconsbenchmark_workers_self[27]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[28].outMaster to array of is_present fields.
    __is_present_fields[138] = &prodconsbenchmark_workers_self[28]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[29].outMaster to array of is_present fields.
    __is_present_fields[139] = &prodconsbenchmark_workers_self[29]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[30].outMaster to array of is_present fields.
    __is_present_fields[140] = &prodconsbenchmark_workers_self[30]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[31].outMaster to array of is_present fields.
    __is_present_fields[141] = &prodconsbenchmark_workers_self[31]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[32].outMaster to array of is_present fields.
    __is_present_fields[142] = &prodconsbenchmark_workers_self[32]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[33].outMaster to array of is_present fields.
    __is_present_fields[143] = &prodconsbenchmark_workers_self[33]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[34].outMaster to array of is_present fields.
    __is_present_fields[144] = &prodconsbenchmark_workers_self[34]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[35].outMaster to array of is_present fields.
    __is_present_fields[145] = &prodconsbenchmark_workers_self[35]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[36].outMaster to array of is_present fields.
    __is_present_fields[146] = &prodconsbenchmark_workers_self[36]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[37].outMaster to array of is_present fields.
    __is_present_fields[147] = &prodconsbenchmark_workers_self[37]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[38].outMaster to array of is_present fields.
    __is_present_fields[148] = &prodconsbenchmark_workers_self[38]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[39].outMaster to array of is_present fields.
    __is_present_fields[149] = &prodconsbenchmark_workers_self[39]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[40].outMaster to array of is_present fields.
    __is_present_fields[150] = &prodconsbenchmark_workers_self[40]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[41].outMaster to array of is_present fields.
    __is_present_fields[151] = &prodconsbenchmark_workers_self[41]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[42].outMaster to array of is_present fields.
    __is_present_fields[152] = &prodconsbenchmark_workers_self[42]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[43].outMaster to array of is_present fields.
    __is_present_fields[153] = &prodconsbenchmark_workers_self[43]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[44].outMaster to array of is_present fields.
    __is_present_fields[154] = &prodconsbenchmark_workers_self[44]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[45].outMaster to array of is_present fields.
    __is_present_fields[155] = &prodconsbenchmark_workers_self[45]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[46].outMaster to array of is_present fields.
    __is_present_fields[156] = &prodconsbenchmark_workers_self[46]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[47].outMaster to array of is_present fields.
    __is_present_fields[157] = &prodconsbenchmark_workers_self[47]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[48].outMaster to array of is_present fields.
    __is_present_fields[158] = &prodconsbenchmark_workers_self[48]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[49].outMaster to array of is_present fields.
    __is_present_fields[159] = &prodconsbenchmark_workers_self[49]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[50].outMaster to array of is_present fields.
    __is_present_fields[160] = &prodconsbenchmark_workers_self[50]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[51].outMaster to array of is_present fields.
    __is_present_fields[161] = &prodconsbenchmark_workers_self[51]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[52].outMaster to array of is_present fields.
    __is_present_fields[162] = &prodconsbenchmark_workers_self[52]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[53].outMaster to array of is_present fields.
    __is_present_fields[163] = &prodconsbenchmark_workers_self[53]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[54].outMaster to array of is_present fields.
    __is_present_fields[164] = &prodconsbenchmark_workers_self[54]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[55].outMaster to array of is_present fields.
    __is_present_fields[165] = &prodconsbenchmark_workers_self[55]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[56].outMaster to array of is_present fields.
    __is_present_fields[166] = &prodconsbenchmark_workers_self[56]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[57].outMaster to array of is_present fields.
    __is_present_fields[167] = &prodconsbenchmark_workers_self[57]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[58].outMaster to array of is_present fields.
    __is_present_fields[168] = &prodconsbenchmark_workers_self[58]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[59].outMaster to array of is_present fields.
    __is_present_fields[169] = &prodconsbenchmark_workers_self[59]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[60].outMaster to array of is_present fields.
    __is_present_fields[170] = &prodconsbenchmark_workers_self[60]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[61].outMaster to array of is_present fields.
    __is_present_fields[171] = &prodconsbenchmark_workers_self[61]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[62].outMaster to array of is_present fields.
    __is_present_fields[172] = &prodconsbenchmark_workers_self[62]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[63].outMaster to array of is_present fields.
    __is_present_fields[173] = &prodconsbenchmark_workers_self[63]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[64].outMaster to array of is_present fields.
    __is_present_fields[174] = &prodconsbenchmark_workers_self[64]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[65].outMaster to array of is_present fields.
    __is_present_fields[175] = &prodconsbenchmark_workers_self[65]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[66].outMaster to array of is_present fields.
    __is_present_fields[176] = &prodconsbenchmark_workers_self[66]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[67].outMaster to array of is_present fields.
    __is_present_fields[177] = &prodconsbenchmark_workers_self[67]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[68].outMaster to array of is_present fields.
    __is_present_fields[178] = &prodconsbenchmark_workers_self[68]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[69].outMaster to array of is_present fields.
    __is_present_fields[179] = &prodconsbenchmark_workers_self[69]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[70].outMaster to array of is_present fields.
    __is_present_fields[180] = &prodconsbenchmark_workers_self[70]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[71].outMaster to array of is_present fields.
    __is_present_fields[181] = &prodconsbenchmark_workers_self[71]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[72].outMaster to array of is_present fields.
    __is_present_fields[182] = &prodconsbenchmark_workers_self[72]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[73].outMaster to array of is_present fields.
    __is_present_fields[183] = &prodconsbenchmark_workers_self[73]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[74].outMaster to array of is_present fields.
    __is_present_fields[184] = &prodconsbenchmark_workers_self[74]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[75].outMaster to array of is_present fields.
    __is_present_fields[185] = &prodconsbenchmark_workers_self[75]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[76].outMaster to array of is_present fields.
    __is_present_fields[186] = &prodconsbenchmark_workers_self[76]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[77].outMaster to array of is_present fields.
    __is_present_fields[187] = &prodconsbenchmark_workers_self[77]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[78].outMaster to array of is_present fields.
    __is_present_fields[188] = &prodconsbenchmark_workers_self[78]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[79].outMaster to array of is_present fields.
    __is_present_fields[189] = &prodconsbenchmark_workers_self[79]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[80].outMaster to array of is_present fields.
    __is_present_fields[190] = &prodconsbenchmark_workers_self[80]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[81].outMaster to array of is_present fields.
    __is_present_fields[191] = &prodconsbenchmark_workers_self[81]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[82].outMaster to array of is_present fields.
    __is_present_fields[192] = &prodconsbenchmark_workers_self[82]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[83].outMaster to array of is_present fields.
    __is_present_fields[193] = &prodconsbenchmark_workers_self[83]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[84].outMaster to array of is_present fields.
    __is_present_fields[194] = &prodconsbenchmark_workers_self[84]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[85].outMaster to array of is_present fields.
    __is_present_fields[195] = &prodconsbenchmark_workers_self[85]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[86].outMaster to array of is_present fields.
    __is_present_fields[196] = &prodconsbenchmark_workers_self[86]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[87].outMaster to array of is_present fields.
    __is_present_fields[197] = &prodconsbenchmark_workers_self[87]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[88].outMaster to array of is_present fields.
    __is_present_fields[198] = &prodconsbenchmark_workers_self[88]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[89].outMaster to array of is_present fields.
    __is_present_fields[199] = &prodconsbenchmark_workers_self[89]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[90].outMaster to array of is_present fields.
    __is_present_fields[200] = &prodconsbenchmark_workers_self[90]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[91].outMaster to array of is_present fields.
    __is_present_fields[201] = &prodconsbenchmark_workers_self[91]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[92].outMaster to array of is_present fields.
    __is_present_fields[202] = &prodconsbenchmark_workers_self[92]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[93].outMaster to array of is_present fields.
    __is_present_fields[203] = &prodconsbenchmark_workers_self[93]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[94].outMaster to array of is_present fields.
    __is_present_fields[204] = &prodconsbenchmark_workers_self[94]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[95].outMaster to array of is_present fields.
    __is_present_fields[205] = &prodconsbenchmark_workers_self[95]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[96].outMaster to array of is_present fields.
    __is_present_fields[206] = &prodconsbenchmark_workers_self[96]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[97].outMaster to array of is_present fields.
    __is_present_fields[207] = &prodconsbenchmark_workers_self[97]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[98].outMaster to array of is_present fields.
    __is_present_fields[208] = &prodconsbenchmark_workers_self[98]->__outMaster.is_present
    ;
    // Add port ProdConsBenchmark.workers[99].outMaster to array of is_present fields.
    __is_present_fields[209] = &prodconsbenchmark_workers_self[99]->__outMaster.is_present
    ;
    prodconsbenchmark_self->___reaction_0.chain_id = -1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_self->___reaction_0.index = 0x7fffffffffff0000LL;
    prodconsbenchmark_master_self->___reaction_0.chain_id = -1;
    // index is the OR of level 7 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_master_self->___reaction_0.index = 0x7fffffffffff0007LL;
    prodconsbenchmark_master_self->___reaction_1.chain_id = -1;
    // index is the OR of level 8 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_master_self->___reaction_1.index = 0x7fffffffffff0008LL;
    prodconsbenchmark_master_self->___reaction_2.chain_id = -1;
    // index is the OR of level 10 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_master_self->___reaction_2.index = 0x7fffffffffff000aLL;
    prodconsbenchmark_runner_self->___reaction_0.chain_id = 64;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_0.index = 0x7fffffffffff0000LL;
    prodconsbenchmark_runner_self->___reaction_1.chain_id = -1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_1.index = 0x7fffffffffff0001LL;
    prodconsbenchmark_runner_self->___reaction_2.chain_id = -1;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_2.index = 0x7fffffffffff0002LL;
    prodconsbenchmark_runner_self->___reaction_3.chain_id = -1;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_3.index = 0x7fffffffffff0003LL;
    prodconsbenchmark_runner_self->___reaction_4.chain_id = -1;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_4.index = 0x7fffffffffff0004LL;
    prodconsbenchmark_runner_self->___reaction_5.chain_id = -1;
    // index is the OR of level 5 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_5.index = 0x7fffffffffff0005LL;
    prodconsbenchmark_runner_self->___reaction_6.chain_id = -1;
    // index is the OR of level 6 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_6.index = 0x7fffffffffff0006LL;
    prodconsbenchmark_runner_self->___reaction_7.chain_id = -1;
    // index is the OR of level 11 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_7.index = 0x7fffffffffff000bLL;
    prodconsbenchmark_runner_self->___reaction_8.chain_id = -1;
    // index is the OR of level 12 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_runner_self->___reaction_8.index = 0x7fffffffffff000cLL;
    prodconsbenchmark_workers_self[0]->___reaction_0.chain_id = 1;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[0]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[1]->___reaction_0.chain_id = 2;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[1]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[2]->___reaction_0.chain_id = 4;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[2]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[3]->___reaction_0.chain_id = 8;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[3]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[4]->___reaction_0.chain_id = 16;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[4]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[5]->___reaction_0.chain_id = 32;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[5]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[6]->___reaction_0.chain_id = 64;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[6]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[7]->___reaction_0.chain_id = 128;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[7]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[8]->___reaction_0.chain_id = 256;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[8]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[9]->___reaction_0.chain_id = 512;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[9]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[10]->___reaction_0.chain_id = 1024;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[10]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[11]->___reaction_0.chain_id = 2048;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[11]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[12]->___reaction_0.chain_id = 4096;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[12]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[13]->___reaction_0.chain_id = 8192;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[13]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[14]->___reaction_0.chain_id = 16384;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[14]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[15]->___reaction_0.chain_id = 32768;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[15]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[16]->___reaction_0.chain_id = 65536;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[16]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[17]->___reaction_0.chain_id = 131072;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[17]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[18]->___reaction_0.chain_id = 262144;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[18]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[19]->___reaction_0.chain_id = 524288;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[19]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[20]->___reaction_0.chain_id = 1048576;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[20]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[21]->___reaction_0.chain_id = 2097152;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[21]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[22]->___reaction_0.chain_id = 4194304;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[22]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[23]->___reaction_0.chain_id = 8388608;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[23]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[24]->___reaction_0.chain_id = 16777216;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[24]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[25]->___reaction_0.chain_id = 33554432;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[25]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[26]->___reaction_0.chain_id = 67108864;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[26]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[27]->___reaction_0.chain_id = 134217728;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[27]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[28]->___reaction_0.chain_id = 268435456;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[28]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[29]->___reaction_0.chain_id = 536870912;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[29]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[30]->___reaction_0.chain_id = 1073741824;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[30]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[31]->___reaction_0.chain_id = -2147483648;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[31]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[32]->___reaction_0.chain_id = 1;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[32]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[33]->___reaction_0.chain_id = 2;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[33]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[34]->___reaction_0.chain_id = 4;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[34]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[35]->___reaction_0.chain_id = 8;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[35]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[36]->___reaction_0.chain_id = 16;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[36]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[37]->___reaction_0.chain_id = 32;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[37]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[38]->___reaction_0.chain_id = 64;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[38]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[39]->___reaction_0.chain_id = 128;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[39]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[40]->___reaction_0.chain_id = 256;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[40]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[41]->___reaction_0.chain_id = 512;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[41]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[42]->___reaction_0.chain_id = 1024;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[42]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[43]->___reaction_0.chain_id = 2048;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[43]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[44]->___reaction_0.chain_id = 4096;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[44]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[45]->___reaction_0.chain_id = 8192;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[45]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[46]->___reaction_0.chain_id = 16384;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[46]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[47]->___reaction_0.chain_id = 32768;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[47]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[48]->___reaction_0.chain_id = 65536;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[48]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[49]->___reaction_0.chain_id = 131072;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[49]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[50]->___reaction_0.chain_id = 262144;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[50]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[51]->___reaction_0.chain_id = 524288;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[51]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[52]->___reaction_0.chain_id = 1048576;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[52]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[53]->___reaction_0.chain_id = 2097152;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[53]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[54]->___reaction_0.chain_id = 4194304;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[54]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[55]->___reaction_0.chain_id = 8388608;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[55]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[56]->___reaction_0.chain_id = 16777216;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[56]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[57]->___reaction_0.chain_id = 33554432;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[57]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[58]->___reaction_0.chain_id = 67108864;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[58]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[59]->___reaction_0.chain_id = 134217728;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[59]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[60]->___reaction_0.chain_id = 268435456;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[60]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[61]->___reaction_0.chain_id = 536870912;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[61]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[62]->___reaction_0.chain_id = 1073741824;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[62]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[63]->___reaction_0.chain_id = -2147483648;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[63]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[64]->___reaction_0.chain_id = 1;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[64]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[65]->___reaction_0.chain_id = 2;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[65]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[66]->___reaction_0.chain_id = 4;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[66]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[67]->___reaction_0.chain_id = 8;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[67]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[68]->___reaction_0.chain_id = 16;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[68]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[69]->___reaction_0.chain_id = 32;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[69]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[70]->___reaction_0.chain_id = 64;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[70]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[71]->___reaction_0.chain_id = 128;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[71]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[72]->___reaction_0.chain_id = 256;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[72]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[73]->___reaction_0.chain_id = 512;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[73]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[74]->___reaction_0.chain_id = 1024;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[74]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[75]->___reaction_0.chain_id = 2048;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[75]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[76]->___reaction_0.chain_id = 4096;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[76]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[77]->___reaction_0.chain_id = 8192;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[77]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[78]->___reaction_0.chain_id = 16384;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[78]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[79]->___reaction_0.chain_id = 32768;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[79]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[80]->___reaction_0.chain_id = 65536;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[80]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[81]->___reaction_0.chain_id = 131072;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[81]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[82]->___reaction_0.chain_id = 262144;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[82]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[83]->___reaction_0.chain_id = 524288;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[83]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[84]->___reaction_0.chain_id = 1048576;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[84]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[85]->___reaction_0.chain_id = 2097152;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[85]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[86]->___reaction_0.chain_id = 4194304;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[86]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[87]->___reaction_0.chain_id = 8388608;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[87]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[88]->___reaction_0.chain_id = 16777216;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[88]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[89]->___reaction_0.chain_id = 33554432;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[89]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[90]->___reaction_0.chain_id = 67108864;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[90]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[91]->___reaction_0.chain_id = 134217728;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[91]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[92]->___reaction_0.chain_id = 268435456;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[92]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[93]->___reaction_0.chain_id = 536870912;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[93]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[94]->___reaction_0.chain_id = 1073741824;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[94]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[95]->___reaction_0.chain_id = -2147483648;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[95]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[96]->___reaction_0.chain_id = 1;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[96]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[97]->___reaction_0.chain_id = 2;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[97]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[98]->___reaction_0.chain_id = 4;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[98]->___reaction_0.index = 0x7fffffffffff0009LL;
    prodconsbenchmark_workers_self[99]->___reaction_0.chain_id = 8;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    prodconsbenchmark_workers_self[99]->___reaction_0.index = 0x7fffffffffff0009LL;
    calculate_epoch_offset();
}
void __trigger_startup_reactions() {
    if (_lf_number_of_threads == 0) {
       _lf_number_of_threads = 24;
    }
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
}
void logical_tag_complete(tag_t tag_to_send) {
}
tag_t send_next_event_tag(tag_t tag, bool wait_for_reply) {
    return tag;
}
bool __trigger_shutdown_reactions() {                          
    for (int i = 0; i < __shutdown_reactions_size; i++) {
        if (__shutdown_reactions[i] != NULL) {
            _lf_enqueue_reaction(__shutdown_reactions[i]);
        }
    }
    // Return true if there are shutdown reactions.
    return (__shutdown_reactions_size > 0);
}
void __termination() {stop_trace();}


#define LOG_LEVEL 2
#include "ctarget.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor.c"
// Code generated by the Lingua Franca compiler from file:
// C:\Users\soyer\lingua-franca-master\git\lingua-franca\benchmark\C\Savina\radixSort\radixSortWitthRunner.lf
// =============== START reactor class SortActor
#line 69 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numValues;
    int radixIndex;
    long* orderingArray;
    int valuesSoFar;
    long radix;
    int pos;
    int sendPos;
    sortactor_sendBufferedValues_t __sendBufferedValues;
    sortactor_inValue_t* __inValue;
    // width of -2 indicates that it is not a multiport.
    int __inValue__width;
    // Default input (in case it does not get connected)
    sortactor_inValue_t __default__inValue;
    sortactor_outValue_t __outValue;
    int __outValue__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___sendBufferedValues;
    reaction_t* ___sendBufferedValues_reactions[1];
    trigger_t ___inValue;
    reaction_t* ___inValue_reactions[1];
} sortactor_self_t;
void sortactorreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    sortactor_self_t* self = (sortactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    self->orderingArray = calloc(self->numValues, sizeof(long));
        
}
void sortactorreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    sortactor_self_t* self = (sortactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    sortactor_inValue_t* inValue = self->__inValue;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inValue_width = self->__inValue__width;
    #pragma GCC diagnostic pop
    sortactor_outValue_t* outValue = &self->__outValue;
    sortactor_sendBufferedValues_t* sendBufferedValues = &self->__sendBufferedValues;
    self->valuesSoFar += 1;
    long current = inValue->value;
    if((current & self->radix) == 0) {
        // number with leading 0 (small) go through
        SET(outValue, current);
    } else {
        self->orderingArray[self->pos] = inValue->value;
        self->pos += 1;
    }
    
    if(self->valuesSoFar == self->numValues) {
        schedule(sendBufferedValues,0);
    }
        
}
void sortactorreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    sortactor_self_t* self = (sortactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    sortactor_outValue_t* outValue = &self->__outValue;
    if(self->sendPos < self->pos) {
        SET(outValue, self->orderingArray[self->sendPos]);
        self->sendPos += 1;
        schedule(sendBufferedValues,0);
    } else {
    
        // reset local state
        self->valuesSoFar = 0;
        self->pos = 0;
        self->sendPos = 0;
    }
        
}
sortactor_self_t* new_SortActor() {
    sortactor_self_t* self = (sortactor_self_t*)calloc(1, sizeof(sortactor_self_t));
    self->__sendBufferedValues.trigger = &self->___sendBufferedValues;
    // Set input by default to an always absent default input.
    self->__inValue = &self->__default__inValue;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = sortactorreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = sortactorreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = sortactorreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___sendBufferedValues.last = NULL;
    self->___sendBufferedValues_reactions[0] = &self->___reaction_2;
    self->___sendBufferedValues.reactions = &self->___sendBufferedValues_reactions[0];
    self->___sendBufferedValues.number_of_reactions = 1;
    self->___sendBufferedValues.is_physical = false;
    self->___sendBufferedValues.element_size = 0;
    self->___inValue.last = NULL;
    self->___inValue_reactions[0] = &self->___reaction_1;
    self->___inValue.reactions = &self->___inValue_reactions[0];
    self->___inValue.number_of_reactions = 1;
    self->___inValue.element_size = sizeof(long);
    return self;
}
void delete_SortActor(sortactor_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class SortActor

// =============== START reactor class BenchmarkRunner
// *********** From the preamble, verbatim:
#line 138 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
        
static double toMS(interval_t t) {
    return t / 1000000.0;
}

int comp (const void * elem1, const void * elem2) {
            int f = *((double*)elem1);
            int s = *((double*)elem2);
            if (f > s) return  1;
            if (f < s) return -1;
            return 0;
        }
        
        static double median(double* execTimes, int size) {
    if (size == 0) {
        return 0.0;
    }
    
    int middle = size / 2;
    if(size % 2 == 1) {
        return execTimes[middle];
    } else {
        return (execTimes[middle-1] + execTimes[middle]) / 2;
    }
}

static double* getMSMeasurements(interval_t* measured_times, int numIterations) {
    
    double* msMeasurements = calloc(numIterations, sizeof(double));
    for (int i = 0; i < numIterations; i++) {
        msMeasurements[i] = toMS(measured_times[i]);
    }
    
    return msMeasurements;
}
    

// *********** End of preamble.
// *********** From the preamble, verbatim:
#line 176 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
        
void printBenchmarkInfo(char* benchmarkId) {
    printf("Benchmark: %s\n", benchmarkId);
}

void printSystemInfo() {
    
    printf("System information\n"); 
    printf("O/S Name: ");
    
    #ifdef _WIN32
    printf("Windows 32-bit");
    #elif _WIN64
    printf("Windows 64-bit");
    #elif __APPLE__ || __MACH__
    printf("Mac OSX");
    #elif __linux__
    printf("Linux");
    #elif __FreeBSD__
    printf("FreeBSD");
    #elif __unix || __unix__
    printf("Unix");
    #else
    printf("Other");
    #endif
    
    printf("\n");
}
    

// *********** End of preamble.
#line 43 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numIterations;
    bool useInit;
    bool useCleanupIteration;
    unsigned count;
    instant_t startTime;
    interval_t* measuredTimes;
    benchmarkrunner_initBenchmark_t __initBenchmark;
    benchmarkrunner_cleanupIteration_t __cleanupIteration;
    benchmarkrunner_nextIteration_t __nextIteration;
    benchmarkrunner_finish_t __finish;
    benchmarkrunner_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inStart_t __default__inStart;
    benchmarkrunner_inIterationFinish_t* __inIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inIterationFinish_t __default__inIterationFinish;
    benchmarkrunner_inInitializeFinish_t* __inInitializeFinish;
    // width of -2 indicates that it is not a multiport.
    int __inInitializeFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inInitializeFinish_t __default__inInitializeFinish;
    benchmarkrunner_inCleanupIterationFinish_t* __inCleanupIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inCleanupIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inCleanupIterationFinish_t __default__inCleanupIterationFinish;
    benchmarkrunner_outIterationStart_t __outIterationStart;
    int __outIterationStart__width;
    benchmarkrunner_outInitializeStart_t __outInitializeStart;
    int __outInitializeStart__width;
    benchmarkrunner_outCleanupIterationStart_t __outCleanupIterationStart;
    int __outCleanupIterationStart__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    reaction_t ___reaction_3;
    reaction_t ___reaction_4;
    reaction_t ___reaction_5;
    reaction_t ___reaction_6;
    reaction_t ___reaction_7;
    reaction_t ___reaction_8;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___initBenchmark;
    reaction_t* ___initBenchmark_reactions[1];
    trigger_t ___cleanupIteration;
    reaction_t* ___cleanupIteration_reactions[1];
    trigger_t ___nextIteration;
    reaction_t* ___nextIteration_reactions[1];
    trigger_t ___finish;
    reaction_t* ___finish_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
    trigger_t ___inIterationFinish;
    reaction_t* ___inIterationFinish_reactions[1];
    trigger_t ___inInitializeFinish;
    reaction_t* ___inInitializeFinish_reactions[1];
    trigger_t ___inCleanupIterationFinish;
    reaction_t* ___inCleanupIterationFinish_reactions[1];
} benchmarkrunner_self_t;
void benchmarkrunnerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    self->measuredTimes = calloc(self->numIterations, sizeof(interval_t));
        
}
void benchmarkrunnerreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_initBenchmark_t* initBenchmark = &self->__initBenchmark;
        schedule(initBenchmark, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outInitializeStart_t* outInitializeStart = &self->__outInitializeStart;
        
}
void benchmarkrunnerreaction_function_3(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inInitializeFinish_t* inInitializeFinish = self->__inInitializeFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inInitializeFinish_width = self->__inInitializeFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_4(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outCleanupIterationStart_t* outCleanupIterationStart = &self->__outCleanupIterationStart;
        
}
void benchmarkrunnerreaction_function_5(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inCleanupIterationFinish_t* inCleanupIterationFinish = self->__inCleanupIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inCleanupIterationFinish_width = self->__inCleanupIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_6(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outIterationStart_t* outIterationStart = &self->__outIterationStart;
    benchmarkrunner_finish_t* finish = &self->__finish;
        self->startTime = get_physical_time();
        SET(outIterationStart, true);
    } else {
        schedule(finish, 0);
    }
        
}
void benchmarkrunnerreaction_function_7(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inIterationFinish_t* inIterationFinish = self->__inIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inIterationFinish_width = self->__inIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_cleanupIteration_t* cleanupIteration = &self->__cleanupIteration;
    interval_t duration = end_time - self->startTime;
    self->measuredTimes[self->count] = duration;
    self->count += 1;
    
    printf("Iteration: %d\t Duration: %.3f msec\n", self->count, toMS(duration));
    
    if(self->useCleanupIteration) {
        schedule(cleanupIteration, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_8(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    qsort(measuredMSTimes, self->numIterations, sizeof(double), comp);
    
    printf("Execution - Summary:\n");
    printf("Best Time:\t %.3f msec\n", measuredMSTimes[0]);
    printf("Worst Time:\t %.3f msec\n", measuredMSTimes[self->numIterations - 1]);
    printf("Median Time:\t %.3f msec\n", median(measuredMSTimes, self->numIterations));
    request_stop();
        
}
benchmarkrunner_self_t* new_BenchmarkRunner() {
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)calloc(1, sizeof(benchmarkrunner_self_t));
    self->__initBenchmark.trigger = &self->___initBenchmark;
    self->__cleanupIteration.trigger = &self->___cleanupIteration;
    self->__nextIteration.trigger = &self->___nextIteration;
    self->__finish.trigger = &self->___finish;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    // Set input by default to an always absent default input.
    self->__inIterationFinish = &self->__default__inIterationFinish;
    // Set input by default to an always absent default input.
    self->__inInitializeFinish = &self->__default__inInitializeFinish;
    // Set input by default to an always absent default input.
    self->__inCleanupIterationFinish = &self->__default__inCleanupIterationFinish;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = benchmarkrunnerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = benchmarkrunnerreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = benchmarkrunnerreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___reaction_3.number = 3;
    self->___reaction_3.function = benchmarkrunnerreaction_function_3;
    self->___reaction_3.self = self;
    self->___reaction_3.deadline_violation_handler = NULL;
    self->___reaction_3.tardy_handler = NULL;
    self->___reaction_4.number = 4;
    self->___reaction_4.function = benchmarkrunnerreaction_function_4;
    self->___reaction_4.self = self;
    self->___reaction_4.deadline_violation_handler = NULL;
    self->___reaction_4.tardy_handler = NULL;
    self->___reaction_5.number = 5;
    self->___reaction_5.function = benchmarkrunnerreaction_function_5;
    self->___reaction_5.self = self;
    self->___reaction_5.deadline_violation_handler = NULL;
    self->___reaction_5.tardy_handler = NULL;
    self->___reaction_6.number = 6;
    self->___reaction_6.function = benchmarkrunnerreaction_function_6;
    self->___reaction_6.self = self;
    self->___reaction_6.deadline_violation_handler = NULL;
    self->___reaction_6.tardy_handler = NULL;
    self->___reaction_7.number = 7;
    self->___reaction_7.function = benchmarkrunnerreaction_function_7;
    self->___reaction_7.self = self;
    self->___reaction_7.deadline_violation_handler = NULL;
    self->___reaction_7.tardy_handler = NULL;
    self->___reaction_8.number = 8;
    self->___reaction_8.function = benchmarkrunnerreaction_function_8;
    self->___reaction_8.self = self;
    self->___reaction_8.deadline_violation_handler = NULL;
    self->___reaction_8.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___initBenchmark.last = NULL;
    self->___initBenchmark_reactions[0] = &self->___reaction_2;
    self->___initBenchmark.reactions = &self->___initBenchmark_reactions[0];
    self->___initBenchmark.number_of_reactions = 1;
    self->___initBenchmark.is_physical = false;
    self->___initBenchmark.element_size = sizeof(bool);
    self->___cleanupIteration.last = NULL;
    self->___cleanupIteration_reactions[0] = &self->___reaction_4;
    self->___cleanupIteration.reactions = &self->___cleanupIteration_reactions[0];
    self->___cleanupIteration.number_of_reactions = 1;
    self->___cleanupIteration.is_physical = false;
    self->___cleanupIteration.element_size = sizeof(bool);
    self->___nextIteration.last = NULL;
    self->___nextIteration_reactions[0] = &self->___reaction_6;
    self->___nextIteration.reactions = &self->___nextIteration_reactions[0];
    self->___nextIteration.number_of_reactions = 1;
    self->___nextIteration.is_physical = false;
    self->___nextIteration.element_size = sizeof(bool);
    self->___finish.last = NULL;
    self->___finish_reactions[0] = &self->___reaction_8;
    self->___finish.reactions = &self->___finish_reactions[0];
    self->___finish.number_of_reactions = 1;
    self->___finish.is_physical = false;
    self->___finish.element_size = sizeof(bool);
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_1;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    self->___inIterationFinish.last = NULL;
    self->___inIterationFinish_reactions[0] = &self->___reaction_7;
    self->___inIterationFinish.reactions = &self->___inIterationFinish_reactions[0];
    self->___inIterationFinish.number_of_reactions = 1;
    self->___inIterationFinish.element_size = sizeof(bool);
    self->___inInitializeFinish.last = NULL;
    self->___inInitializeFinish_reactions[0] = &self->___reaction_3;
    self->___inInitializeFinish.reactions = &self->___inInitializeFinish_reactions[0];
    self->___inInitializeFinish.number_of_reactions = 1;
    self->___inInitializeFinish.element_size = sizeof(bool);
    self->___inCleanupIterationFinish.last = NULL;
    self->___inCleanupIterationFinish_reactions[0] = &self->___reaction_5;
    self->___inCleanupIterationFinish.reactions = &self->___inCleanupIterationFinish_reactions[0];
    self->___inCleanupIterationFinish.number_of_reactions = 1;
    self->___inCleanupIterationFinish.element_size = sizeof(bool);
    return self;
}
void delete_BenchmarkRunner(benchmarkrunner_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    if (self->___reaction_3.output_produced != NULL) {
        free(self->___reaction_3.output_produced);
    }
    if (self->___reaction_3.triggers != NULL) {
        free(self->___reaction_3.triggers);
    }
    if (self->___reaction_3.triggered_sizes != NULL) {
        free(self->___reaction_3.triggered_sizes);
    }
    if (self->___reaction_4.output_produced != NULL) {
        free(self->___reaction_4.output_produced);
    }
    if (self->___reaction_4.triggers != NULL) {
        free(self->___reaction_4.triggers);
    }
    if (self->___reaction_4.triggered_sizes != NULL) {
        free(self->___reaction_4.triggered_sizes);
    }
    if (self->___reaction_5.output_produced != NULL) {
        free(self->___reaction_5.output_produced);
    }
    if (self->___reaction_5.triggers != NULL) {
        free(self->___reaction_5.triggers);
    }
    if (self->___reaction_5.triggered_sizes != NULL) {
        free(self->___reaction_5.triggered_sizes);
    }
    if (self->___reaction_6.output_produced != NULL) {
        free(self->___reaction_6.output_produced);
    }
    if (self->___reaction_6.triggers != NULL) {
        free(self->___reaction_6.triggers);
    }
    if (self->___reaction_6.triggered_sizes != NULL) {
        free(self->___reaction_6.triggered_sizes);
    }
    if (self->___reaction_7.output_produced != NULL) {
        free(self->___reaction_7.output_produced);
    }
    if (self->___reaction_7.triggers != NULL) {
        free(self->___reaction_7.triggers);
    }
    if (self->___reaction_7.triggered_sizes != NULL) {
        free(self->___reaction_7.triggered_sizes);
    }
    if (self->___reaction_8.output_produced != NULL) {
        free(self->___reaction_8.output_produced);
    }
    if (self->___reaction_8.triggers != NULL) {
        free(self->___reaction_8.triggers);
    }
    if (self->___reaction_8.triggered_sizes != NULL) {
        free(self->___reaction_8.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_3.num_outputs; i++) {
        free(self->___reaction_3.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_4.num_outputs; i++) {
        free(self->___reaction_4.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_5.num_outputs; i++) {
        free(self->___reaction_5.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_6.num_outputs; i++) {
        free(self->___reaction_6.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_7.num_outputs; i++) {
        free(self->___reaction_7.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_8.num_outputs; i++) {
        free(self->___reaction_8.triggers[i]);
    }
    free(self);
}
// =============== END reactor class BenchmarkRunner

// =============== START reactor class ValidationReactor
#line 121 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numValues;
    double sumSoFar;
    int valuesSoFar;
    long prevValue;
    long errorValueLong;
    int errorValueInt;
    validationreactor_inValue_t* __inValue;
    // width of -2 indicates that it is not a multiport.
    int __inValue__width;
    // Default input (in case it does not get connected)
    validationreactor_inValue_t __default__inValue;
    validationreactor_outFinished_t __outFinished;
    int __outFinished__width;
    reaction_t ___reaction_0;
    trigger_t ___inValue;
    reaction_t* ___inValue_reactions[1];
} validationreactor_self_t;
void validationreactorreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    validationreactor_self_t* self = (validationreactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    validationreactor_inValue_t* inValue = self->__inValue;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inValue_width = self->__inValue__width;
    #pragma GCC diagnostic pop
    validationreactor_outFinished_t* outFinished = &self->__outFinished;
    long value = inValue->value;
    self->valuesSoFar += 1;
    if(value < self->prevValue && self->errorValueLong < 0) {
        self->errorValueLong = value;
        self->errorValueInt = self->valuesSoFar - 1;
    }
    self->prevValue = value;
    self->sumSoFar += self->prevValue;
    
    if(self->valuesSoFar == self->numValues) {
        if(self->errorValueLong >= 0) {
            printf("ERROR: Value out of place: %ld at index %d", self->errorValueLong, self->errorValueInt);
        } else {
            printf("Elements sum: %f" , self->sumSoFar);
        }
    
        // reset local state
        self->sumSoFar = 0.0;
        self->valuesSoFar = 0;
        self->prevValue = 0;
        self->errorValueLong = -1;
        self->errorValueInt = -1;
    
        SET(outFinished,true);
    }
        
}
validationreactor_self_t* new_ValidationReactor() {
    validationreactor_self_t* self = (validationreactor_self_t*)calloc(1, sizeof(validationreactor_self_t));
    // Set input by default to an always absent default input.
    self->__inValue = &self->__default__inValue;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = validationreactorreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___inValue.last = NULL;
    self->___inValue_reactions[0] = &self->___reaction_0;
    self->___inValue.reactions = &self->___inValue_reactions[0];
    self->___inValue.number_of_reactions = 1;
    self->___inValue.element_size = sizeof(long);
    return self;
}
void delete_ValidationReactor(validationreactor_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class ValidationReactor

// =============== START reactor class IntSourceReactor
// *********** From the preamble, verbatim:
#line 20 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
/**
 * A deterministic function that creates a random long type.
 * @param seed value to start with
 */
long nextLong(long seed)
{
    return ((seed * 1309) + 13849) & 65535;
}
    

// *********** End of preamble.
#line 32 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\radixSort\\radixSortWitthRunner.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numValues;
    long maxValue;
    long seed;
    int numValuesSent;
    long longSoFar;
    intsourcereactor_sendRandomNum_t __sendRandomNum;
    intsourcereactor_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    intsourcereactor_inStart_t __default__inStart;
    intsourcereactor_outNextSortReactor_t __outNextSortReactor;
    int __outNextSortReactor__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    trigger_t ___sendRandomNum;
    reaction_t* ___sendRandomNum_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
} intsourcereactor_self_t;
void intsourcereactorreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    intsourcereactor_self_t* self = (intsourcereactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    intsourcereactor_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    intsourcereactor_sendRandomNum_t* sendRandomNum = &self->__sendRandomNum;
    // reset local state
    self->numValuesSent = 0;
    
    // start execution
    schedule(sendRandomNum, 0);
        
}
void intsourcereactorreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    intsourcereactor_self_t* self = (intsourcereactor_self_t*)instance_args;
    #pragma GCC diagnostic pop
    intsourcereactor_outNextSortReactor_t* outNextSortReactor = &self->__outNextSortReactor;
    if(self->numValuesSent < self->numValues) {
         long candidate = labs(nextLong(self->seed)) % self->maxValue;
         printf("%ld",candidate);
         SET(outNextSortReactor,candidate);
         self->numValuesSent += 1;
         schedule(sendRandomNum,0);
    }
        
}
intsourcereactor_self_t* new_IntSourceReactor() {
    intsourcereactor_self_t* self = (intsourcereactor_self_t*)calloc(1, sizeof(intsourcereactor_self_t));
    self->__sendRandomNum.trigger = &self->___sendRandomNum;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = intsourcereactorreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = intsourcereactorreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___sendRandomNum.last = NULL;
    self->___sendRandomNum_reactions[0] = &self->___reaction_1;
    self->___sendRandomNum.reactions = &self->___sendRandomNum_reactions[0];
    self->___sendRandomNum.number_of_reactions = 1;
    self->___sendRandomNum.is_physical = false;
    self->___sendRandomNum.element_size = 0;
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_0;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    return self;
}
void delete_IntSourceReactor(intsourcereactor_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    free(self);
}
// =============== END reactor class IntSourceReactor

// =============== START reactor class RadixSortBenchmark
typedef struct {
    int bank_index;
    int numIterations;
    int dataSize;
    long maxValue;
    long seed;
    struct {
        benchmarkrunner_inStart_t inStart;
    } __runner;
    reaction_t ___reaction_0;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
} radixsortbenchmark_self_t;
void radixsortbenchmarkreaction_function_0(void* instance_args) {
    struct runner{
        benchmarkrunner_inStart_t* inStart;
    } runner;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    radixsortbenchmark_self_t* self = (radixsortbenchmark_self_t*)instance_args;
    #pragma GCC diagnostic pop
    runner.inStart = &(self->__runner.inStart);
    //printArgs("numIterations", self->numIterations, "dataSize", self->dataSize, "maxValue", self->maxValue, "seed", self->seed);
    printSystemInfo();
    SET(runner.inStart,true);
        
}
radixsortbenchmark_self_t* new_RadixSortBenchmark() {
    radixsortbenchmark_self_t* self = (radixsortbenchmark_self_t*)calloc(1, sizeof(radixsortbenchmark_self_t));
    self->___reaction_0.number = 0;
    self->___reaction_0.function = radixsortbenchmarkreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    return self;
}
void delete_RadixSortBenchmark(radixsortbenchmark_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class RadixSortBenchmark

void __set_default_command_line_options() {
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t** __timer_triggers = NULL;
int __timer_triggers_size = 0;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[12];
int __startup_reactions_size = 12;
// Empty array of pointers to shutdown triggers.
reaction_t** __shutdown_reactions = NULL;
int __shutdown_reactions_size = 0;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 15;
    __tokens_with_ref_count = (token_present_t*)malloc(15 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 31;
    __is_present_fields = (bool**)malloc(31 * sizeof(bool*));
    // ************* Instance RadixSortBenchmark of class RadixSortBenchmark
    radixsortbenchmark_self_t* radixsortbenchmark_self = new_RadixSortBenchmark();
    //***** Start initializing RadixSortBenchmark
    radixsortbenchmark_self->numIterations = 12; 
    radixsortbenchmark_self->dataSize = 100000; 
    radixsortbenchmark_self->maxValue = 1l << 60; 
    radixsortbenchmark_self->seed = 2048l; 
    __startup_reactions[0] = &radixsortbenchmark_self->___reaction_0;
    // ************* Instance RadixSortBenchmark.source of class IntSourceReactor
    intsourcereactor_self_t* radixsortbenchmark_source_self = new_IntSourceReactor();
    //***** Start initializing RadixSortBenchmark.source
    radixsortbenchmark_source_self->numValues = 100000; 
    radixsortbenchmark_source_self->maxValue = 1l << 60; 
    radixsortbenchmark_source_self->seed = 2048l; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_source_self->__outNextSortReactor__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_source_self->__inStart__width = -2;
    static int radixsortbenchmark_source_initial_numValuesSent = 0;
    radixsortbenchmark_source_self->numValuesSent = radixsortbenchmark_source_initial_numValuesSent;
    radixsortbenchmark_source_self->longSoFar = radixsortbenchmark_source_self->seed;
    radixsortbenchmark_source_self->___sendRandomNum.offset = 0;
    radixsortbenchmark_source_self->___sendRandomNum.period = -1;
    radixsortbenchmark_source_self->___sendRandomNum.token = __create_token(0);
    radixsortbenchmark_source_self->___sendRandomNum.is_present = false;
    __tokens_with_ref_count[0].token
            = &radixsortbenchmark_source_self->___sendRandomNum.token;
    __tokens_with_ref_count[0].is_present
            = &radixsortbenchmark_source_self->___sendRandomNum.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.source
    // ************* Instance RadixSortBenchmark.validator of class ValidationReactor
    validationreactor_self_t* radixsortbenchmark_validator_self = new_ValidationReactor();
    //***** Start initializing RadixSortBenchmark.validator
    radixsortbenchmark_validator_self->numValues = 100000; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_validator_self->__outFinished__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_validator_self->__inValue__width = -2;
    static double radixsortbenchmark_validator_initial_sumSoFar = 0.0;
    radixsortbenchmark_validator_self->sumSoFar = radixsortbenchmark_validator_initial_sumSoFar;
    static int radixsortbenchmark_validator_initial_valuesSoFar = 0;
    radixsortbenchmark_validator_self->valuesSoFar = radixsortbenchmark_validator_initial_valuesSoFar;
    static long radixsortbenchmark_validator_initial_prevValue = 0;
    radixsortbenchmark_validator_self->prevValue = radixsortbenchmark_validator_initial_prevValue;
    static long radixsortbenchmark_validator_initial_errorValueLong = -1;
    radixsortbenchmark_validator_self->errorValueLong = radixsortbenchmark_validator_initial_errorValueLong;
    static int radixsortbenchmark_validator_initial_errorValueInt = -1;
    radixsortbenchmark_validator_self->errorValueInt = radixsortbenchmark_validator_initial_errorValueInt;
    //***** End initializing RadixSortBenchmark.validator
    // ************* Instance RadixSortBenchmark.runner of class BenchmarkRunner
    benchmarkrunner_self_t* radixsortbenchmark_runner_self = new_BenchmarkRunner();
    //***** Start initializing RadixSortBenchmark.runner
    radixsortbenchmark_runner_self->numIterations = 12; 
    radixsortbenchmark_runner_self->useInit = false; 
    radixsortbenchmark_runner_self->useCleanupIteration = false; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__outIterationStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__outInitializeStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__outCleanupIterationStart__width = -2;
    __startup_reactions[1] = &radixsortbenchmark_runner_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__inStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__inIterationFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__inInitializeFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_runner_self->__inCleanupIterationFinish__width = -2;
    static unsigned radixsortbenchmark_runner_initial_count = 0;
    radixsortbenchmark_runner_self->count = radixsortbenchmark_runner_initial_count;
    radixsortbenchmark_runner_self->___initBenchmark.offset = 0;
    radixsortbenchmark_runner_self->___initBenchmark.period = -1;
    radixsortbenchmark_runner_self->___cleanupIteration.offset = 0;
    radixsortbenchmark_runner_self->___cleanupIteration.period = -1;
    radixsortbenchmark_runner_self->___nextIteration.offset = 0;
    radixsortbenchmark_runner_self->___nextIteration.period = -1;
    radixsortbenchmark_runner_self->___finish.offset = 0;
    radixsortbenchmark_runner_self->___finish.period = -1;
    radixsortbenchmark_runner_self->___initBenchmark.token = __create_token(sizeof(bool));
    radixsortbenchmark_runner_self->___initBenchmark.is_present = false;
    __tokens_with_ref_count[1].token
            = &radixsortbenchmark_runner_self->___initBenchmark.token;
    __tokens_with_ref_count[1].is_present
            = &radixsortbenchmark_runner_self->___initBenchmark.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    radixsortbenchmark_runner_self->___cleanupIteration.token = __create_token(sizeof(bool));
    radixsortbenchmark_runner_self->___cleanupIteration.is_present = false;
    __tokens_with_ref_count[2].token
            = &radixsortbenchmark_runner_self->___cleanupIteration.token;
    __tokens_with_ref_count[2].is_present
            = &radixsortbenchmark_runner_self->___cleanupIteration.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    radixsortbenchmark_runner_self->___nextIteration.token = __create_token(sizeof(bool));
    radixsortbenchmark_runner_self->___nextIteration.is_present = false;
    __tokens_with_ref_count[3].token
            = &radixsortbenchmark_runner_self->___nextIteration.token;
    __tokens_with_ref_count[3].is_present
            = &radixsortbenchmark_runner_self->___nextIteration.is_present;
    __tokens_with_ref_count[3].reset_is_present = true;
    radixsortbenchmark_runner_self->___finish.token = __create_token(sizeof(bool));
    radixsortbenchmark_runner_self->___finish.is_present = false;
    __tokens_with_ref_count[4].token
            = &radixsortbenchmark_runner_self->___finish.token;
    __tokens_with_ref_count[4].is_present
            = &radixsortbenchmark_runner_self->___finish.is_present;
    __tokens_with_ref_count[4].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.runner
    // ************* Instance RadixSortBenchmark.sorter0 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter0_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter0
    radixsortbenchmark_sorter0_self->numValues = 100000; 
    radixsortbenchmark_sorter0_self->radixIndex = 0; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter0_self->__outValue__width = -2;
    __startup_reactions[2] = &radixsortbenchmark_sorter0_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter0_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter0_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter0_self->valuesSoFar = radixsortbenchmark_sorter0_initial_valuesSoFar;
    static long radixsortbenchmark_sorter0_initial_radix = -1;
    radixsortbenchmark_sorter0_self->radix = radixsortbenchmark_sorter0_initial_radix;
    static int radixsortbenchmark_sorter0_initial_pos = 0;
    radixsortbenchmark_sorter0_self->pos = radixsortbenchmark_sorter0_initial_pos;
    static int radixsortbenchmark_sorter0_initial_sendPos = 0;
    radixsortbenchmark_sorter0_self->sendPos = radixsortbenchmark_sorter0_initial_sendPos;
    radixsortbenchmark_sorter0_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter0_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter0_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter0_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[5].token
            = &radixsortbenchmark_sorter0_self->___sendBufferedValues.token;
    __tokens_with_ref_count[5].is_present
            = &radixsortbenchmark_sorter0_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[5].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter0
    // ************* Instance RadixSortBenchmark.sorter1 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter1_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter1
    radixsortbenchmark_sorter1_self->numValues = 100000; 
    radixsortbenchmark_sorter1_self->radixIndex = 1; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter1_self->__outValue__width = -2;
    __startup_reactions[3] = &radixsortbenchmark_sorter1_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter1_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter1_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter1_self->valuesSoFar = radixsortbenchmark_sorter1_initial_valuesSoFar;
    static long radixsortbenchmark_sorter1_initial_radix = -1;
    radixsortbenchmark_sorter1_self->radix = radixsortbenchmark_sorter1_initial_radix;
    static int radixsortbenchmark_sorter1_initial_pos = 0;
    radixsortbenchmark_sorter1_self->pos = radixsortbenchmark_sorter1_initial_pos;
    static int radixsortbenchmark_sorter1_initial_sendPos = 0;
    radixsortbenchmark_sorter1_self->sendPos = radixsortbenchmark_sorter1_initial_sendPos;
    radixsortbenchmark_sorter1_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter1_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter1_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter1_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[6].token
            = &radixsortbenchmark_sorter1_self->___sendBufferedValues.token;
    __tokens_with_ref_count[6].is_present
            = &radixsortbenchmark_sorter1_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[6].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter1
    // ************* Instance RadixSortBenchmark.sorter2 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter2_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter2
    radixsortbenchmark_sorter2_self->numValues = 100000; 
    radixsortbenchmark_sorter2_self->radixIndex = 2; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter2_self->__outValue__width = -2;
    __startup_reactions[4] = &radixsortbenchmark_sorter2_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter2_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter2_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter2_self->valuesSoFar = radixsortbenchmark_sorter2_initial_valuesSoFar;
    static long radixsortbenchmark_sorter2_initial_radix = -1;
    radixsortbenchmark_sorter2_self->radix = radixsortbenchmark_sorter2_initial_radix;
    static int radixsortbenchmark_sorter2_initial_pos = 0;
    radixsortbenchmark_sorter2_self->pos = radixsortbenchmark_sorter2_initial_pos;
    static int radixsortbenchmark_sorter2_initial_sendPos = 0;
    radixsortbenchmark_sorter2_self->sendPos = radixsortbenchmark_sorter2_initial_sendPos;
    radixsortbenchmark_sorter2_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter2_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter2_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter2_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[7].token
            = &radixsortbenchmark_sorter2_self->___sendBufferedValues.token;
    __tokens_with_ref_count[7].is_present
            = &radixsortbenchmark_sorter2_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[7].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter2
    // ************* Instance RadixSortBenchmark.sorter3 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter3_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter3
    radixsortbenchmark_sorter3_self->numValues = 100000; 
    radixsortbenchmark_sorter3_self->radixIndex = 3; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter3_self->__outValue__width = -2;
    __startup_reactions[5] = &radixsortbenchmark_sorter3_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter3_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter3_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter3_self->valuesSoFar = radixsortbenchmark_sorter3_initial_valuesSoFar;
    static long radixsortbenchmark_sorter3_initial_radix = -1;
    radixsortbenchmark_sorter3_self->radix = radixsortbenchmark_sorter3_initial_radix;
    static int radixsortbenchmark_sorter3_initial_pos = 0;
    radixsortbenchmark_sorter3_self->pos = radixsortbenchmark_sorter3_initial_pos;
    static int radixsortbenchmark_sorter3_initial_sendPos = 0;
    radixsortbenchmark_sorter3_self->sendPos = radixsortbenchmark_sorter3_initial_sendPos;
    radixsortbenchmark_sorter3_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter3_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter3_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter3_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[8].token
            = &radixsortbenchmark_sorter3_self->___sendBufferedValues.token;
    __tokens_with_ref_count[8].is_present
            = &radixsortbenchmark_sorter3_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[8].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter3
    // ************* Instance RadixSortBenchmark.sorter4 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter4_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter4
    radixsortbenchmark_sorter4_self->numValues = 100000; 
    radixsortbenchmark_sorter4_self->radixIndex = 4; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter4_self->__outValue__width = -2;
    __startup_reactions[6] = &radixsortbenchmark_sorter4_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter4_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter4_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter4_self->valuesSoFar = radixsortbenchmark_sorter4_initial_valuesSoFar;
    static long radixsortbenchmark_sorter4_initial_radix = -1;
    radixsortbenchmark_sorter4_self->radix = radixsortbenchmark_sorter4_initial_radix;
    static int radixsortbenchmark_sorter4_initial_pos = 0;
    radixsortbenchmark_sorter4_self->pos = radixsortbenchmark_sorter4_initial_pos;
    static int radixsortbenchmark_sorter4_initial_sendPos = 0;
    radixsortbenchmark_sorter4_self->sendPos = radixsortbenchmark_sorter4_initial_sendPos;
    radixsortbenchmark_sorter4_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter4_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter4_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter4_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[9].token
            = &radixsortbenchmark_sorter4_self->___sendBufferedValues.token;
    __tokens_with_ref_count[9].is_present
            = &radixsortbenchmark_sorter4_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[9].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter4
    // ************* Instance RadixSortBenchmark.sorter5 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter5_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter5
    radixsortbenchmark_sorter5_self->numValues = 100000; 
    radixsortbenchmark_sorter5_self->radixIndex = 5; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter5_self->__outValue__width = -2;
    __startup_reactions[7] = &radixsortbenchmark_sorter5_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter5_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter5_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter5_self->valuesSoFar = radixsortbenchmark_sorter5_initial_valuesSoFar;
    static long radixsortbenchmark_sorter5_initial_radix = -1;
    radixsortbenchmark_sorter5_self->radix = radixsortbenchmark_sorter5_initial_radix;
    static int radixsortbenchmark_sorter5_initial_pos = 0;
    radixsortbenchmark_sorter5_self->pos = radixsortbenchmark_sorter5_initial_pos;
    static int radixsortbenchmark_sorter5_initial_sendPos = 0;
    radixsortbenchmark_sorter5_self->sendPos = radixsortbenchmark_sorter5_initial_sendPos;
    radixsortbenchmark_sorter5_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter5_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter5_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter5_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[10].token
            = &radixsortbenchmark_sorter5_self->___sendBufferedValues.token;
    __tokens_with_ref_count[10].is_present
            = &radixsortbenchmark_sorter5_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[10].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter5
    // ************* Instance RadixSortBenchmark.sorter6 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter6_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter6
    radixsortbenchmark_sorter6_self->numValues = 100000; 
    radixsortbenchmark_sorter6_self->radixIndex = 6; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter6_self->__outValue__width = -2;
    __startup_reactions[8] = &radixsortbenchmark_sorter6_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter6_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter6_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter6_self->valuesSoFar = radixsortbenchmark_sorter6_initial_valuesSoFar;
    static long radixsortbenchmark_sorter6_initial_radix = -1;
    radixsortbenchmark_sorter6_self->radix = radixsortbenchmark_sorter6_initial_radix;
    static int radixsortbenchmark_sorter6_initial_pos = 0;
    radixsortbenchmark_sorter6_self->pos = radixsortbenchmark_sorter6_initial_pos;
    static int radixsortbenchmark_sorter6_initial_sendPos = 0;
    radixsortbenchmark_sorter6_self->sendPos = radixsortbenchmark_sorter6_initial_sendPos;
    radixsortbenchmark_sorter6_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter6_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter6_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter6_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[11].token
            = &radixsortbenchmark_sorter6_self->___sendBufferedValues.token;
    __tokens_with_ref_count[11].is_present
            = &radixsortbenchmark_sorter6_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[11].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter6
    // ************* Instance RadixSortBenchmark.sorter7 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter7_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter7
    radixsortbenchmark_sorter7_self->numValues = 100000; 
    radixsortbenchmark_sorter7_self->radixIndex = 7; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter7_self->__outValue__width = -2;
    __startup_reactions[9] = &radixsortbenchmark_sorter7_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter7_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter7_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter7_self->valuesSoFar = radixsortbenchmark_sorter7_initial_valuesSoFar;
    static long radixsortbenchmark_sorter7_initial_radix = -1;
    radixsortbenchmark_sorter7_self->radix = radixsortbenchmark_sorter7_initial_radix;
    static int radixsortbenchmark_sorter7_initial_pos = 0;
    radixsortbenchmark_sorter7_self->pos = radixsortbenchmark_sorter7_initial_pos;
    static int radixsortbenchmark_sorter7_initial_sendPos = 0;
    radixsortbenchmark_sorter7_self->sendPos = radixsortbenchmark_sorter7_initial_sendPos;
    radixsortbenchmark_sorter7_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter7_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter7_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter7_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[12].token
            = &radixsortbenchmark_sorter7_self->___sendBufferedValues.token;
    __tokens_with_ref_count[12].is_present
            = &radixsortbenchmark_sorter7_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[12].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter7
    // ************* Instance RadixSortBenchmark.sorter8 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter8_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter8
    radixsortbenchmark_sorter8_self->numValues = 100000; 
    radixsortbenchmark_sorter8_self->radixIndex = 8; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter8_self->__outValue__width = -2;
    __startup_reactions[10] = &radixsortbenchmark_sorter8_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter8_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter8_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter8_self->valuesSoFar = radixsortbenchmark_sorter8_initial_valuesSoFar;
    static long radixsortbenchmark_sorter8_initial_radix = -1;
    radixsortbenchmark_sorter8_self->radix = radixsortbenchmark_sorter8_initial_radix;
    static int radixsortbenchmark_sorter8_initial_pos = 0;
    radixsortbenchmark_sorter8_self->pos = radixsortbenchmark_sorter8_initial_pos;
    static int radixsortbenchmark_sorter8_initial_sendPos = 0;
    radixsortbenchmark_sorter8_self->sendPos = radixsortbenchmark_sorter8_initial_sendPos;
    radixsortbenchmark_sorter8_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter8_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter8_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter8_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[13].token
            = &radixsortbenchmark_sorter8_self->___sendBufferedValues.token;
    __tokens_with_ref_count[13].is_present
            = &radixsortbenchmark_sorter8_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[13].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter8
    // ************* Instance RadixSortBenchmark.sorter9 of class SortActor
    sortactor_self_t* radixsortbenchmark_sorter9_self = new_SortActor();
    //***** Start initializing RadixSortBenchmark.sorter9
    radixsortbenchmark_sorter9_self->numValues = 100000; 
    radixsortbenchmark_sorter9_self->radixIndex = 9; 
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter9_self->__outValue__width = -2;
    __startup_reactions[11] = &radixsortbenchmark_sorter9_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    radixsortbenchmark_sorter9_self->__inValue__width = -2;
    static int radixsortbenchmark_sorter9_initial_valuesSoFar = 0;
    radixsortbenchmark_sorter9_self->valuesSoFar = radixsortbenchmark_sorter9_initial_valuesSoFar;
    static long radixsortbenchmark_sorter9_initial_radix = -1;
    radixsortbenchmark_sorter9_self->radix = radixsortbenchmark_sorter9_initial_radix;
    static int radixsortbenchmark_sorter9_initial_pos = 0;
    radixsortbenchmark_sorter9_self->pos = radixsortbenchmark_sorter9_initial_pos;
    static int radixsortbenchmark_sorter9_initial_sendPos = 0;
    radixsortbenchmark_sorter9_self->sendPos = radixsortbenchmark_sorter9_initial_sendPos;
    radixsortbenchmark_sorter9_self->___sendBufferedValues.offset = 0;
    radixsortbenchmark_sorter9_self->___sendBufferedValues.period = -1;
    radixsortbenchmark_sorter9_self->___sendBufferedValues.token = __create_token(0);
    radixsortbenchmark_sorter9_self->___sendBufferedValues.is_present = false;
    __tokens_with_ref_count[14].token
            = &radixsortbenchmark_sorter9_self->___sendBufferedValues.token;
    __tokens_with_ref_count[14].is_present
            = &radixsortbenchmark_sorter9_self->___sendBufferedValues.is_present;
    __tokens_with_ref_count[14].reset_is_present = true;
    //***** End initializing RadixSortBenchmark.sorter9
    //***** End initializing RadixSortBenchmark
    // Populate arrays of trigger pointers.
    radixsortbenchmark_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_self->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_self->___reaction_0.num_outputs);
        radixsortbenchmark_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_self->___reaction_0.num_outputs);
        radixsortbenchmark_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_self->___reaction_0.output_produced[0]
    = &radixsortbenchmark_self->__runner.inStart.is_present
    ;
    // Reaction 0 of RadixSortBenchmark does not depend on one maximal upstream reaction.
    radixsortbenchmark_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of RadixSortBenchmark triggers 1 downstream reactions through port RadixSortBenchmark.runner.inStart.
    radixsortbenchmark_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of RadixSortBenchmark, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.runner.inStart
    trigger_t** radixsortbenchmark_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_self->___reaction_0.triggers[0] = radixsortbenchmark_0_0;
    // Point to destination port RadixSortBenchmark.runner.inStart's trigger struct.
    radixsortbenchmark_0_0[0] = &radixsortbenchmark_runner_self->___inStart;
    radixsortbenchmark_self->__runner.inStart.
    num_destinations = 1;
    radixsortbenchmark_source_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_source_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_source_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_source_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_source_self->___reaction_0.num_outputs);
        radixsortbenchmark_source_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_source_self->___reaction_0.num_outputs);
        radixsortbenchmark_source_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_source_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_source_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_source_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_source_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_source_self->___reaction_1.num_outputs);
        radixsortbenchmark_source_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_source_self->___reaction_1.num_outputs);
        radixsortbenchmark_source_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_source_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_source_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_source_self->__outNextSortReactor.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.source depends on one maximal upstream reaction.
    radixsortbenchmark_source_self->___reaction_0.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_6);
    // Reaction 1 of RadixSortBenchmark.source depends on one maximal upstream reaction.
    radixsortbenchmark_source_self->___reaction_1.last_enabling_reaction = &(radixsortbenchmark_source_self->___reaction_0);
    // Reaction 1 of RadixSortBenchmark.source triggers 1 downstream reactions through port RadixSortBenchmark.source.outNextSortReactor.
    radixsortbenchmark_source_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.source, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.source.outNextSortReactor
    trigger_t** radixsortbenchmark_source_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_source_self->___reaction_1.triggers[0] = radixsortbenchmark_source_1_0;
    // Point to destination port RadixSortBenchmark.sorter0.inValue's trigger struct.
    radixsortbenchmark_source_1_0[0] = &radixsortbenchmark_sorter0_self->___inValue;
    radixsortbenchmark_source_self->__outNextSortReactor.num_destinations
    = 1;
    radixsortbenchmark_validator_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_validator_self->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_validator_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_validator_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_validator_self->___reaction_0.num_outputs);
        radixsortbenchmark_validator_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_validator_self->___reaction_0.num_outputs);
        radixsortbenchmark_validator_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_validator_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_validator_self->___reaction_0.output_produced[0]
    = &radixsortbenchmark_validator_self->__outFinished.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.validator depends on one maximal upstream reaction.
    radixsortbenchmark_validator_self->___reaction_0.last_enabling_reaction = &(radixsortbenchmark_sorter9_self->___reaction_2);
    // Reaction 0 of RadixSortBenchmark.validator triggers 1 downstream reactions through port RadixSortBenchmark.validator.outFinished.
    radixsortbenchmark_validator_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of RadixSortBenchmark.validator, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.validator.outFinished
    trigger_t** radixsortbenchmark_validator_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_validator_self->___reaction_0.triggers[0] = radixsortbenchmark_validator_0_0;
    // Point to destination port RadixSortBenchmark.runner.inIterationFinish's trigger struct.
    radixsortbenchmark_validator_0_0[0] = &radixsortbenchmark_runner_self->___inIterationFinish;
    radixsortbenchmark_validator_self->__outFinished.num_destinations
    = 1;
    radixsortbenchmark_runner_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_0.num_outputs);
        radixsortbenchmark_runner_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_0.num_outputs);
        radixsortbenchmark_runner_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_1.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_1.num_outputs);
        radixsortbenchmark_runner_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_1.num_outputs);
        radixsortbenchmark_runner_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_2.num_outputs);
        radixsortbenchmark_runner_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_2.num_outputs);
        radixsortbenchmark_runner_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_runner_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_runner_self->__outInitializeStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_3.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_3.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_3.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_3.num_outputs);
        radixsortbenchmark_runner_self->___reaction_3.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_3.num_outputs);
        radixsortbenchmark_runner_self->___reaction_3.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_3.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_4.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_4.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_4.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_4.num_outputs);
        radixsortbenchmark_runner_self->___reaction_4.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_4.num_outputs);
        radixsortbenchmark_runner_self->___reaction_4.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_4.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_runner_self->___reaction_4.output_produced[0]
    = &radixsortbenchmark_runner_self->__outCleanupIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_5.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_5.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_5.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_5.num_outputs);
        radixsortbenchmark_runner_self->___reaction_5.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_5.num_outputs);
        radixsortbenchmark_runner_self->___reaction_5.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_5.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_6.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_6.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_6.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_6.num_outputs);
        radixsortbenchmark_runner_self->___reaction_6.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_6.num_outputs);
        radixsortbenchmark_runner_self->___reaction_6.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_6.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_runner_self->___reaction_6.output_produced[0]
    = &radixsortbenchmark_runner_self->__outIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_7.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_7.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_7.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_7.num_outputs);
        radixsortbenchmark_runner_self->___reaction_7.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_7.num_outputs);
        radixsortbenchmark_runner_self->___reaction_7.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_7.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_runner_self->___reaction_8.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_runner_self->___reaction_8.num_outputs > 0) {
        radixsortbenchmark_runner_self->___reaction_8.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_runner_self->___reaction_8.num_outputs);
        radixsortbenchmark_runner_self->___reaction_8.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_runner_self->___reaction_8.num_outputs);
        radixsortbenchmark_runner_self->___reaction_8.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_runner_self->___reaction_8.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of RadixSortBenchmark.runner does not depend on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.runner does not depend on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 2 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.runner triggers 0 downstream reactions through port RadixSortBenchmark.runner.outInitializeStart.
    radixsortbenchmark_runner_self->___reaction_2.triggered_sizes[0] = 0;
    // Reaction 3 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_3.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_2);
    // Reaction 4 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_4.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_3);
    // Reaction 4 of RadixSortBenchmark.runner triggers 0 downstream reactions through port RadixSortBenchmark.runner.outCleanupIterationStart.
    radixsortbenchmark_runner_self->___reaction_4.triggered_sizes[0] = 0;
    // Reaction 5 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_5.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_4);
    // Reaction 6 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_6.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_5);
    // Reaction 6 of RadixSortBenchmark.runner triggers 1 downstream reactions through port RadixSortBenchmark.runner.outIterationStart.
    radixsortbenchmark_runner_self->___reaction_6.triggered_sizes[0] = 1;
    // For reaction 6 of RadixSortBenchmark.runner, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.runner.outIterationStart
    trigger_t** radixsortbenchmark_runner_6_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_runner_self->___reaction_6.triggers[0] = radixsortbenchmark_runner_6_0;
    // Point to destination port RadixSortBenchmark.source.inStart's trigger struct.
    radixsortbenchmark_runner_6_0[0] = &radixsortbenchmark_source_self->___inStart;
    // Reaction 7 of RadixSortBenchmark.runner does not depend on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_7.last_enabling_reaction = NULL;
    // Reaction 8 of RadixSortBenchmark.runner depends on one maximal upstream reaction.
    radixsortbenchmark_runner_self->___reaction_8.last_enabling_reaction = &(radixsortbenchmark_runner_self->___reaction_7);
    radixsortbenchmark_runner_self->__outIterationStart.num_destinations
    = 1;
    radixsortbenchmark_runner_self->__outInitializeStart.num_destinations
    = 0;
    radixsortbenchmark_runner_self->__outCleanupIterationStart.num_destinations
    = 0;
    radixsortbenchmark_sorter0_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter0_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter0_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter0_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter0_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter0_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter0_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter0_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter0_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter0_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter0_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter0_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter0_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter0_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter0_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter0_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter0_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter0_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter0_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter0_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter0_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter0_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter0_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter0_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter0 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter0_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter0 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter0_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter0 triggers 1 downstream reactions through port RadixSortBenchmark.sorter0.outValue.
    radixsortbenchmark_sorter0_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter0, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter0.outValue
    trigger_t** radixsortbenchmark_sorter0_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter0_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter0_1_0;
    // Point to destination port RadixSortBenchmark.sorter1.inValue's trigger struct.
    radixsortbenchmark_sorter0_1_0[0] = &radixsortbenchmark_sorter1_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter0 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter0_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter0_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter0 triggers 1 downstream reactions through port RadixSortBenchmark.sorter0.outValue.
    radixsortbenchmark_sorter0_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter0, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter0.outValue
    trigger_t** radixsortbenchmark_sorter0_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter0_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter0_2_0;
    // Point to destination port RadixSortBenchmark.sorter1.inValue's trigger struct.
    radixsortbenchmark_sorter0_2_0[0] = &radixsortbenchmark_sorter1_self->___inValue;
    radixsortbenchmark_sorter0_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter1_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter1_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter1_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter1_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter1_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter1_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter1_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter1_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter1_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter1_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter1_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter1_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter1_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter1_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter1_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter1_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter1_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter1_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter1_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter1_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter1_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter1_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter1_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter1_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter1 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter1_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter1 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter1_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter1 triggers 1 downstream reactions through port RadixSortBenchmark.sorter1.outValue.
    radixsortbenchmark_sorter1_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter1, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter1.outValue
    trigger_t** radixsortbenchmark_sorter1_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter1_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter1_1_0;
    // Point to destination port RadixSortBenchmark.sorter2.inValue's trigger struct.
    radixsortbenchmark_sorter1_1_0[0] = &radixsortbenchmark_sorter2_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter1 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter1_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter1_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter1 triggers 1 downstream reactions through port RadixSortBenchmark.sorter1.outValue.
    radixsortbenchmark_sorter1_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter1, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter1.outValue
    trigger_t** radixsortbenchmark_sorter1_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter1_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter1_2_0;
    // Point to destination port RadixSortBenchmark.sorter2.inValue's trigger struct.
    radixsortbenchmark_sorter1_2_0[0] = &radixsortbenchmark_sorter2_self->___inValue;
    radixsortbenchmark_sorter1_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter2_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter2_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter2_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter2_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter2_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter2_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter2_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter2_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter2_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter2_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter2_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter2_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter2_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter2_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter2_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter2_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter2_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter2_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter2_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter2_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter2_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter2_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter2_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter2_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter2 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter2_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter2 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter2_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter2 triggers 1 downstream reactions through port RadixSortBenchmark.sorter2.outValue.
    radixsortbenchmark_sorter2_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter2, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter2.outValue
    trigger_t** radixsortbenchmark_sorter2_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter2_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter2_1_0;
    // Point to destination port RadixSortBenchmark.sorter3.inValue's trigger struct.
    radixsortbenchmark_sorter2_1_0[0] = &radixsortbenchmark_sorter3_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter2 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter2_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter2_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter2 triggers 1 downstream reactions through port RadixSortBenchmark.sorter2.outValue.
    radixsortbenchmark_sorter2_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter2, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter2.outValue
    trigger_t** radixsortbenchmark_sorter2_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter2_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter2_2_0;
    // Point to destination port RadixSortBenchmark.sorter3.inValue's trigger struct.
    radixsortbenchmark_sorter2_2_0[0] = &radixsortbenchmark_sorter3_self->___inValue;
    radixsortbenchmark_sorter2_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter3_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter3_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter3_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter3_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter3_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter3_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter3_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter3_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter3_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter3_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter3_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter3_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter3_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter3_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter3_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter3_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter3_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter3_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter3_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter3_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter3_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter3_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter3_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter3_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter3 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter3_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter3 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter3_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter3 triggers 1 downstream reactions through port RadixSortBenchmark.sorter3.outValue.
    radixsortbenchmark_sorter3_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter3, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter3.outValue
    trigger_t** radixsortbenchmark_sorter3_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter3_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter3_1_0;
    // Point to destination port RadixSortBenchmark.sorter4.inValue's trigger struct.
    radixsortbenchmark_sorter3_1_0[0] = &radixsortbenchmark_sorter4_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter3 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter3_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter3_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter3 triggers 1 downstream reactions through port RadixSortBenchmark.sorter3.outValue.
    radixsortbenchmark_sorter3_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter3, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter3.outValue
    trigger_t** radixsortbenchmark_sorter3_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter3_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter3_2_0;
    // Point to destination port RadixSortBenchmark.sorter4.inValue's trigger struct.
    radixsortbenchmark_sorter3_2_0[0] = &radixsortbenchmark_sorter4_self->___inValue;
    radixsortbenchmark_sorter3_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter4_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter4_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter4_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter4_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter4_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter4_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter4_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter4_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter4_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter4_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter4_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter4_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter4_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter4_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter4_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter4_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter4_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter4_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter4_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter4_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter4_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter4_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter4_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter4_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter4 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter4_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter4 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter4_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter4 triggers 1 downstream reactions through port RadixSortBenchmark.sorter4.outValue.
    radixsortbenchmark_sorter4_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter4, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter4.outValue
    trigger_t** radixsortbenchmark_sorter4_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter4_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter4_1_0;
    // Point to destination port RadixSortBenchmark.sorter5.inValue's trigger struct.
    radixsortbenchmark_sorter4_1_0[0] = &radixsortbenchmark_sorter5_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter4 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter4_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter4_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter4 triggers 1 downstream reactions through port RadixSortBenchmark.sorter4.outValue.
    radixsortbenchmark_sorter4_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter4, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter4.outValue
    trigger_t** radixsortbenchmark_sorter4_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter4_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter4_2_0;
    // Point to destination port RadixSortBenchmark.sorter5.inValue's trigger struct.
    radixsortbenchmark_sorter4_2_0[0] = &radixsortbenchmark_sorter5_self->___inValue;
    radixsortbenchmark_sorter4_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter5_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter5_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter5_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter5_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter5_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter5_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter5_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter5_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter5_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter5_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter5_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter5_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter5_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter5_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter5_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter5_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter5_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter5_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter5_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter5_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter5_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter5_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter5_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter5_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter5 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter5_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter5 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter5_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter5 triggers 1 downstream reactions through port RadixSortBenchmark.sorter5.outValue.
    radixsortbenchmark_sorter5_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter5, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter5.outValue
    trigger_t** radixsortbenchmark_sorter5_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter5_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter5_1_0;
    // Point to destination port RadixSortBenchmark.sorter6.inValue's trigger struct.
    radixsortbenchmark_sorter5_1_0[0] = &radixsortbenchmark_sorter6_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter5 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter5_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter5_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter5 triggers 1 downstream reactions through port RadixSortBenchmark.sorter5.outValue.
    radixsortbenchmark_sorter5_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter5, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter5.outValue
    trigger_t** radixsortbenchmark_sorter5_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter5_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter5_2_0;
    // Point to destination port RadixSortBenchmark.sorter6.inValue's trigger struct.
    radixsortbenchmark_sorter5_2_0[0] = &radixsortbenchmark_sorter6_self->___inValue;
    radixsortbenchmark_sorter5_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter6_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter6_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter6_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter6_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter6_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter6_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter6_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter6_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter6_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter6_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter6_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter6_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter6_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter6_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter6_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter6_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter6_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter6_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter6_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter6_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter6_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter6_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter6_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter6_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter6 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter6_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter6 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter6_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter6 triggers 1 downstream reactions through port RadixSortBenchmark.sorter6.outValue.
    radixsortbenchmark_sorter6_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter6, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter6.outValue
    trigger_t** radixsortbenchmark_sorter6_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter6_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter6_1_0;
    // Point to destination port RadixSortBenchmark.sorter7.inValue's trigger struct.
    radixsortbenchmark_sorter6_1_0[0] = &radixsortbenchmark_sorter7_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter6 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter6_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter6_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter6 triggers 1 downstream reactions through port RadixSortBenchmark.sorter6.outValue.
    radixsortbenchmark_sorter6_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter6, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter6.outValue
    trigger_t** radixsortbenchmark_sorter6_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter6_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter6_2_0;
    // Point to destination port RadixSortBenchmark.sorter7.inValue's trigger struct.
    radixsortbenchmark_sorter6_2_0[0] = &radixsortbenchmark_sorter7_self->___inValue;
    radixsortbenchmark_sorter6_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter7_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter7_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter7_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter7_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter7_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter7_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter7_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter7_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter7_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter7_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter7_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter7_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter7_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter7_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter7_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter7_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter7_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter7_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter7_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter7_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter7_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter7_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter7_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter7_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter7 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter7_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter7 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter7_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter7 triggers 1 downstream reactions through port RadixSortBenchmark.sorter7.outValue.
    radixsortbenchmark_sorter7_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter7, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter7.outValue
    trigger_t** radixsortbenchmark_sorter7_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter7_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter7_1_0;
    // Point to destination port RadixSortBenchmark.sorter8.inValue's trigger struct.
    radixsortbenchmark_sorter7_1_0[0] = &radixsortbenchmark_sorter8_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter7 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter7_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter7_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter7 triggers 1 downstream reactions through port RadixSortBenchmark.sorter7.outValue.
    radixsortbenchmark_sorter7_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter7, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter7.outValue
    trigger_t** radixsortbenchmark_sorter7_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter7_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter7_2_0;
    // Point to destination port RadixSortBenchmark.sorter8.inValue's trigger struct.
    radixsortbenchmark_sorter7_2_0[0] = &radixsortbenchmark_sorter8_self->___inValue;
    radixsortbenchmark_sorter7_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter8_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter8_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter8_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter8_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter8_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter8_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter8_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter8_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter8_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter8_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter8_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter8_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter8_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter8_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter8_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter8_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter8_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter8_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter8_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter8_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter8_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter8_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter8_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter8_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter8 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter8_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter8 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter8_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter8 triggers 1 downstream reactions through port RadixSortBenchmark.sorter8.outValue.
    radixsortbenchmark_sorter8_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter8, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter8.outValue
    trigger_t** radixsortbenchmark_sorter8_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter8_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter8_1_0;
    // Point to destination port RadixSortBenchmark.sorter9.inValue's trigger struct.
    radixsortbenchmark_sorter8_1_0[0] = &radixsortbenchmark_sorter9_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter8 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter8_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter8_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter8 triggers 1 downstream reactions through port RadixSortBenchmark.sorter8.outValue.
    radixsortbenchmark_sorter8_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter8, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter8.outValue
    trigger_t** radixsortbenchmark_sorter8_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter8_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter8_2_0;
    // Point to destination port RadixSortBenchmark.sorter9.inValue's trigger struct.
    radixsortbenchmark_sorter8_2_0[0] = &radixsortbenchmark_sorter9_self->___inValue;
    radixsortbenchmark_sorter8_self->__outValue.num_destinations
    = 1;
    radixsortbenchmark_sorter9_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter9_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter9_self->___reaction_0.num_outputs > 0) {
        radixsortbenchmark_sorter9_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter9_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter9_self->___reaction_0.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter9_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter9_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter9_self->___reaction_1.num_outputs > 0) {
        radixsortbenchmark_sorter9_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter9_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter9_self->___reaction_1.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter9_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter9_self->___reaction_1.output_produced[0]
    = &radixsortbenchmark_sorter9_self->__outValue.is_present
    ;
    // Total number of outputs produced by the reaction.
    radixsortbenchmark_sorter9_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (radixsortbenchmark_sorter9_self->___reaction_2.num_outputs > 0) {
        radixsortbenchmark_sorter9_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * radixsortbenchmark_sorter9_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * radixsortbenchmark_sorter9_self->___reaction_2.num_outputs);
        radixsortbenchmark_sorter9_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * radixsortbenchmark_sorter9_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    radixsortbenchmark_sorter9_self->___reaction_2.output_produced[0]
    = &radixsortbenchmark_sorter9_self->__outValue.is_present
    ;
    // Reaction 0 of RadixSortBenchmark.sorter9 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter9_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter9 does not depend on one maximal upstream reaction.
    radixsortbenchmark_sorter9_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 1 of RadixSortBenchmark.sorter9 triggers 1 downstream reactions through port RadixSortBenchmark.sorter9.outValue.
    radixsortbenchmark_sorter9_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of RadixSortBenchmark.sorter9, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter9.outValue
    trigger_t** radixsortbenchmark_sorter9_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter9_self->___reaction_1.triggers[0] = radixsortbenchmark_sorter9_1_0;
    // Point to destination port RadixSortBenchmark.validator.inValue's trigger struct.
    radixsortbenchmark_sorter9_1_0[0] = &radixsortbenchmark_validator_self->___inValue;
    // Reaction 2 of RadixSortBenchmark.sorter9 depends on one maximal upstream reaction.
    radixsortbenchmark_sorter9_self->___reaction_2.last_enabling_reaction = &(radixsortbenchmark_sorter9_self->___reaction_1);
    // Reaction 2 of RadixSortBenchmark.sorter9 triggers 1 downstream reactions through port RadixSortBenchmark.sorter9.outValue.
    radixsortbenchmark_sorter9_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of RadixSortBenchmark.sorter9, allocate an
    // array of trigger pointers for downstream reactions through port RadixSortBenchmark.sorter9.outValue
    trigger_t** radixsortbenchmark_sorter9_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    radixsortbenchmark_sorter9_self->___reaction_2.triggers[0] = radixsortbenchmark_sorter9_2_0;
    // Point to destination port RadixSortBenchmark.validator.inValue's trigger struct.
    radixsortbenchmark_sorter9_2_0[0] = &radixsortbenchmark_validator_self->___inValue;
    radixsortbenchmark_sorter9_self->__outValue.num_destinations
    = 1;
    // doDeferredInitialize
    // Connect inputs and outputs for reactor RadixSortBenchmark.
    // Connect RadixSortBenchmark.runner.outIterationStart to input port RadixSortBenchmark.source.inStart
    radixsortbenchmark_source_self->__inStart = (intsourcereactor_inStart_t*)&radixsortbenchmark_runner_self->__outIterationStart;
    // Connect RadixSortBenchmark.validator.outFinished to input port RadixSortBenchmark.runner.inIterationFinish
    radixsortbenchmark_runner_self->__inIterationFinish = (benchmarkrunner_inIterationFinish_t*)&radixsortbenchmark_validator_self->__outFinished;
    // Connect RadixSortBenchmark.source.outNextSortReactor to input port RadixSortBenchmark.sorter0.inValue
    radixsortbenchmark_sorter0_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_source_self->__outNextSortReactor;
    // Connect RadixSortBenchmark.sorter9.outValue to input port RadixSortBenchmark.validator.inValue
    radixsortbenchmark_validator_self->__inValue = (validationreactor_inValue_t*)&radixsortbenchmark_sorter9_self->__outValue;
    // Connect RadixSortBenchmark.sorter0.outValue to input port RadixSortBenchmark.sorter1.inValue
    radixsortbenchmark_sorter1_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter0_self->__outValue;
    // Connect RadixSortBenchmark.sorter1.outValue to input port RadixSortBenchmark.sorter2.inValue
    radixsortbenchmark_sorter2_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter1_self->__outValue;
    // Connect RadixSortBenchmark.sorter2.outValue to input port RadixSortBenchmark.sorter3.inValue
    radixsortbenchmark_sorter3_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter2_self->__outValue;
    // Connect RadixSortBenchmark.sorter3.outValue to input port RadixSortBenchmark.sorter4.inValue
    radixsortbenchmark_sorter4_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter3_self->__outValue;
    // Connect RadixSortBenchmark.sorter4.outValue to input port RadixSortBenchmark.sorter5.inValue
    radixsortbenchmark_sorter5_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter4_self->__outValue;
    // Connect RadixSortBenchmark.sorter5.outValue to input port RadixSortBenchmark.sorter6.inValue
    radixsortbenchmark_sorter6_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter5_self->__outValue;
    // Connect RadixSortBenchmark.sorter6.outValue to input port RadixSortBenchmark.sorter7.inValue
    radixsortbenchmark_sorter7_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter6_self->__outValue;
    // Connect RadixSortBenchmark.sorter7.outValue to input port RadixSortBenchmark.sorter8.inValue
    radixsortbenchmark_sorter8_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter7_self->__outValue;
    // Connect RadixSortBenchmark.sorter8.outValue to input port RadixSortBenchmark.sorter9.inValue
    radixsortbenchmark_sorter9_self->__inValue = (sortactor_inValue_t*)&radixsortbenchmark_sorter8_self->__outValue;
    // Connect inputs and outputs for reactor RadixSortBenchmark.source.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.source.
    // Connect inputs and outputs for reactor RadixSortBenchmark.validator.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.validator.
    // Connect inputs and outputs for reactor RadixSortBenchmark.runner.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.runner.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter0.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter0.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter1.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter1.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter2.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter2.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter3.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter3.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter4.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter4.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter5.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter5.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter6.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter6.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter7.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter7.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter8.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter8.
    // Connect inputs and outputs for reactor RadixSortBenchmark.sorter9.
    // END Connect inputs and outputs for reactor RadixSortBenchmark.sorter9.
    // Connect PortInstance RadixSortBenchmark.runner.inStart, which gets data from reaction 0
    // of RadixSortBenchmark, to RadixSortBenchmark.runner.inStart.
    radixsortbenchmark_runner_self->__inStart = (benchmarkrunner_inStart_t*)&radixsortbenchmark_self->__runner.inStart;
    // END Connect inputs and outputs for reactor RadixSortBenchmark.
    // Add action RadixSortBenchmark.source.sendRandomNum to array of is_present fields.
    __is_present_fields[0] 
            = &radixsortbenchmark_source_self->__sendRandomNum.is_present;
    // Add action RadixSortBenchmark.runner.initBenchmark to array of is_present fields.
    __is_present_fields[1] 
            = &radixsortbenchmark_runner_self->__initBenchmark.is_present;
    // Add action RadixSortBenchmark.runner.cleanupIteration to array of is_present fields.
    __is_present_fields[2] 
            = &radixsortbenchmark_runner_self->__cleanupIteration.is_present;
    // Add action RadixSortBenchmark.runner.nextIteration to array of is_present fields.
    __is_present_fields[3] 
            = &radixsortbenchmark_runner_self->__nextIteration.is_present;
    // Add action RadixSortBenchmark.runner.finish to array of is_present fields.
    __is_present_fields[4] 
            = &radixsortbenchmark_runner_self->__finish.is_present;
    // Add action RadixSortBenchmark.sorter0.sendBufferedValues to array of is_present fields.
    __is_present_fields[5] 
            = &radixsortbenchmark_sorter0_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter1.sendBufferedValues to array of is_present fields.
    __is_present_fields[6] 
            = &radixsortbenchmark_sorter1_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter2.sendBufferedValues to array of is_present fields.
    __is_present_fields[7] 
            = &radixsortbenchmark_sorter2_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter3.sendBufferedValues to array of is_present fields.
    __is_present_fields[8] 
            = &radixsortbenchmark_sorter3_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter4.sendBufferedValues to array of is_present fields.
    __is_present_fields[9] 
            = &radixsortbenchmark_sorter4_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter5.sendBufferedValues to array of is_present fields.
    __is_present_fields[10] 
            = &radixsortbenchmark_sorter5_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter6.sendBufferedValues to array of is_present fields.
    __is_present_fields[11] 
            = &radixsortbenchmark_sorter6_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter7.sendBufferedValues to array of is_present fields.
    __is_present_fields[12] 
            = &radixsortbenchmark_sorter7_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter8.sendBufferedValues to array of is_present fields.
    __is_present_fields[13] 
            = &radixsortbenchmark_sorter8_self->__sendBufferedValues.is_present;
    // Add action RadixSortBenchmark.sorter9.sendBufferedValues to array of is_present fields.
    __is_present_fields[14] 
            = &radixsortbenchmark_sorter9_self->__sendBufferedValues.is_present;
    // Add port RadixSortBenchmark.runner.inStart to array of is_present fields.
    __is_present_fields[15] 
            = &radixsortbenchmark_self->__runner.inStart.
            is_present;
    // Add port RadixSortBenchmark.source.outNextSortReactor to array of is_present fields.
    __is_present_fields[16] = &radixsortbenchmark_source_self->__outNextSortReactor.is_present
    ;
    // Add port RadixSortBenchmark.validator.outFinished to array of is_present fields.
    __is_present_fields[17] = &radixsortbenchmark_validator_self->__outFinished.is_present
    ;
    // Add port RadixSortBenchmark.runner.outIterationStart to array of is_present fields.
    __is_present_fields[18] = &radixsortbenchmark_runner_self->__outIterationStart.is_present
    ;
    // Add port RadixSortBenchmark.runner.outInitializeStart to array of is_present fields.
    __is_present_fields[19] = &radixsortbenchmark_runner_self->__outInitializeStart.is_present
    ;
    // Add port RadixSortBenchmark.runner.outCleanupIterationStart to array of is_present fields.
    __is_present_fields[20] = &radixsortbenchmark_runner_self->__outCleanupIterationStart.is_present
    ;
    // Add port RadixSortBenchmark.sorter0.outValue to array of is_present fields.
    __is_present_fields[21] = &radixsortbenchmark_sorter0_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter1.outValue to array of is_present fields.
    __is_present_fields[22] = &radixsortbenchmark_sorter1_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter2.outValue to array of is_present fields.
    __is_present_fields[23] = &radixsortbenchmark_sorter2_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter3.outValue to array of is_present fields.
    __is_present_fields[24] = &radixsortbenchmark_sorter3_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter4.outValue to array of is_present fields.
    __is_present_fields[25] = &radixsortbenchmark_sorter4_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter5.outValue to array of is_present fields.
    __is_present_fields[26] = &radixsortbenchmark_sorter5_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter6.outValue to array of is_present fields.
    __is_present_fields[27] = &radixsortbenchmark_sorter6_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter7.outValue to array of is_present fields.
    __is_present_fields[28] = &radixsortbenchmark_sorter7_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter8.outValue to array of is_present fields.
    __is_present_fields[29] = &radixsortbenchmark_sorter8_self->__outValue.is_present
    ;
    // Add port RadixSortBenchmark.sorter9.outValue to array of is_present fields.
    __is_present_fields[30] = &radixsortbenchmark_sorter9_self->__outValue.is_present
    ;
    radixsortbenchmark_self->___reaction_0.chain_id = 2099199;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_source_self->___reaction_0.chain_id = 2047;
    // index is the OR of level 7 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_source_self->___reaction_0.index = 0x7fffffffffff0007LL;
    radixsortbenchmark_source_self->___reaction_1.chain_id = 2047;
    // index is the OR of level 8 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_source_self->___reaction_1.index = 0x7fffffffffff0008LL;
    radixsortbenchmark_validator_self->___reaction_0.chain_id = 2097151;
    // index is the OR of level 29 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_validator_self->___reaction_0.index = 0x7fffffffffff001dLL;
    radixsortbenchmark_runner_self->___reaction_0.chain_id = 4194304;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_runner_self->___reaction_1.chain_id = 6293503;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_1.index = 0x7fffffffffff0001LL;
    radixsortbenchmark_runner_self->___reaction_2.chain_id = 6293503;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_2.index = 0x7fffffffffff0002LL;
    radixsortbenchmark_runner_self->___reaction_3.chain_id = 6293503;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_3.index = 0x7fffffffffff0003LL;
    radixsortbenchmark_runner_self->___reaction_4.chain_id = 6293503;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_4.index = 0x7fffffffffff0004LL;
    radixsortbenchmark_runner_self->___reaction_5.chain_id = 6293503;
    // index is the OR of level 5 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_5.index = 0x7fffffffffff0005LL;
    radixsortbenchmark_runner_self->___reaction_6.chain_id = 6293503;
    // index is the OR of level 6 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_6.index = 0x7fffffffffff0006LL;
    radixsortbenchmark_runner_self->___reaction_7.chain_id = 8388607;
    // index is the OR of level 30 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_7.index = 0x7fffffffffff001eLL;
    radixsortbenchmark_runner_self->___reaction_8.chain_id = 8388607;
    // index is the OR of level 31 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_runner_self->___reaction_8.index = 0x7fffffffffff001fLL;
    radixsortbenchmark_sorter0_self->___reaction_0.chain_id = 2048;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter0_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter0_self->___reaction_1.chain_id = 4095;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter0_self->___reaction_1.index = 0x7fffffffffff0009LL;
    radixsortbenchmark_sorter0_self->___reaction_2.chain_id = 1023;
    // index is the OR of level 10 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter0_self->___reaction_2.index = 0x7fffffffffff000aLL;
    radixsortbenchmark_sorter1_self->___reaction_0.chain_id = 4096;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter1_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter1_self->___reaction_1.chain_id = 8191;
    // index is the OR of level 11 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter1_self->___reaction_1.index = 0x7fffffffffff000bLL;
    radixsortbenchmark_sorter1_self->___reaction_2.chain_id = 511;
    // index is the OR of level 12 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter1_self->___reaction_2.index = 0x7fffffffffff000cLL;
    radixsortbenchmark_sorter2_self->___reaction_0.chain_id = 8192;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter2_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter2_self->___reaction_1.chain_id = 16383;
    // index is the OR of level 13 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter2_self->___reaction_1.index = 0x7fffffffffff000dLL;
    radixsortbenchmark_sorter2_self->___reaction_2.chain_id = 255;
    // index is the OR of level 14 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter2_self->___reaction_2.index = 0x7fffffffffff000eLL;
    radixsortbenchmark_sorter3_self->___reaction_0.chain_id = 16384;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter3_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter3_self->___reaction_1.chain_id = 32767;
    // index is the OR of level 15 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter3_self->___reaction_1.index = 0x7fffffffffff000fLL;
    radixsortbenchmark_sorter3_self->___reaction_2.chain_id = 127;
    // index is the OR of level 16 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter3_self->___reaction_2.index = 0x7fffffffffff0010LL;
    radixsortbenchmark_sorter4_self->___reaction_0.chain_id = 32768;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter4_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter4_self->___reaction_1.chain_id = 65535;
    // index is the OR of level 17 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter4_self->___reaction_1.index = 0x7fffffffffff0011LL;
    radixsortbenchmark_sorter4_self->___reaction_2.chain_id = 63;
    // index is the OR of level 18 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter4_self->___reaction_2.index = 0x7fffffffffff0012LL;
    radixsortbenchmark_sorter5_self->___reaction_0.chain_id = 65536;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter5_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter5_self->___reaction_1.chain_id = 131071;
    // index is the OR of level 19 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter5_self->___reaction_1.index = 0x7fffffffffff0013LL;
    radixsortbenchmark_sorter5_self->___reaction_2.chain_id = 31;
    // index is the OR of level 20 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter5_self->___reaction_2.index = 0x7fffffffffff0014LL;
    radixsortbenchmark_sorter6_self->___reaction_0.chain_id = 131072;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter6_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter6_self->___reaction_1.chain_id = 262143;
    // index is the OR of level 21 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter6_self->___reaction_1.index = 0x7fffffffffff0015LL;
    radixsortbenchmark_sorter6_self->___reaction_2.chain_id = 15;
    // index is the OR of level 22 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter6_self->___reaction_2.index = 0x7fffffffffff0016LL;
    radixsortbenchmark_sorter7_self->___reaction_0.chain_id = 262144;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter7_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter7_self->___reaction_1.chain_id = 524287;
    // index is the OR of level 23 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter7_self->___reaction_1.index = 0x7fffffffffff0017LL;
    radixsortbenchmark_sorter7_self->___reaction_2.chain_id = 7;
    // index is the OR of level 24 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter7_self->___reaction_2.index = 0x7fffffffffff0018LL;
    radixsortbenchmark_sorter8_self->___reaction_0.chain_id = 524288;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter8_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter8_self->___reaction_1.chain_id = 1048575;
    // index is the OR of level 25 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter8_self->___reaction_1.index = 0x7fffffffffff0019LL;
    radixsortbenchmark_sorter8_self->___reaction_2.chain_id = 3;
    // index is the OR of level 26 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter8_self->___reaction_2.index = 0x7fffffffffff001aLL;
    radixsortbenchmark_sorter9_self->___reaction_0.chain_id = 1048576;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter9_self->___reaction_0.index = 0x7fffffffffff0000LL;
    radixsortbenchmark_sorter9_self->___reaction_1.chain_id = 2097151;
    // index is the OR of level 27 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter9_self->___reaction_1.index = 0x7fffffffffff001bLL;
    radixsortbenchmark_sorter9_self->___reaction_2.chain_id = 1;
    // index is the OR of level 28 and 
    // deadline 140737488355327 shifted left 16 bits.
    radixsortbenchmark_sorter9_self->___reaction_2.index = 0x7fffffffffff001cLL;
    calculate_epoch_offset();
}
void __trigger_startup_reactions() {
    
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
}
void logical_tag_complete(tag_t tag_to_send) {
}
tag_t send_next_event_tag(tag_t tag, bool wait_for_reply) {
    return tag;
}
bool __trigger_shutdown_reactions() {                          
    for (int i = 0; i < __shutdown_reactions_size; i++) {
        if (__shutdown_reactions[i] != NULL) {
            _lf_enqueue_reaction(__shutdown_reactions[i]);
        }
    }
    // Return true if there are shutdown reactions.
    return (__shutdown_reactions_size > 0);
}
void __termination() {stop_trace();}


#define LOG_LEVEL 2
#include "ctarget.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor.c"
// Code generated by the Lingua Franca compiler from file:
// C:\Users\soyer\lingua-franca-master\git\lingua-franca\benchmark\C\Savina\pingpong\PingPongBenchmark.lf
// =============== START reactor class Pong
#line 72 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\pingpong\\PingPongBenchmark.lf"
typedef struct {
typedef struct {
    int bank_index;
    pong_inPing_t* __inPing;
    // width of -2 indicates that it is not a multiport.
    int __inPing__width;
    // Default input (in case it does not get connected)
    pong_inPing_t __default__inPing;
    pong_outPong_t __outPong;
    int __outPong__width;
    reaction_t ___reaction_0;
    trigger_t ___inPing;
    reaction_t* ___inPing_reactions[1];
} pong_self_t;
void pongreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pong_self_t* self = (pong_self_t*)instance_args;
    #pragma GCC diagnostic pop
    pong_inPing_t* inPing = self->__inPing;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inPing_width = self->__inPing__width;
    #pragma GCC diagnostic pop
    pong_outPong_t* outPong = &self->__outPong;
        
}
pong_self_t* new_Pong() {
    pong_self_t* self = (pong_self_t*)calloc(1, sizeof(pong_self_t));
    // Set input by default to an always absent default input.
    self->__inPing = &self->__default__inPing;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = pongreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___inPing.last = NULL;
    self->___inPing_reactions[0] = &self->___reaction_0;
    self->___inPing.reactions = &self->___inPing_reactions[0];
    self->___inPing.number_of_reactions = 1;
    self->___inPing.element_size = sizeof(bool);
    return self;
}
void delete_Pong(pong_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Pong

// =============== START reactor class BenchmarkRunner
// *********** From the preamble, verbatim:
#line 138 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\pingpong\\PingPongBenchmark.lf"
        
static double toMS(interval_t t) {
    return t / 1000000.0;
}

int comp (const void * elem1, const void * elem2) {
            int f = *((double*)elem1);
            int s = *((double*)elem2);
            if (f > s) return  1;
            if (f < s) return -1;
            return 0;
        }
        
        static double median(double* execTimes, int size) {
    if (size == 0) {
        return 0.0;
    }
    
    int middle = size / 2;
    if(size % 2 == 1) {
        return execTimes[middle];
    } else {
        return (execTimes[middle-1] + execTimes[middle]) / 2;
    }
}

static double* getMSMeasurements(interval_t* measured_times, int numIterations) {
    
    double* msMeasurements = calloc(numIterations, sizeof(double));
    for (int i = 0; i < numIterations; i++) {
        msMeasurements[i] = toMS(measured_times[i]);
    }
    
    return msMeasurements;
}
    

// *********** End of preamble.
// *********** From the preamble, verbatim:
#line 176 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\pingpong\\PingPongBenchmark.lf"
        
void printBenchmarkInfo(char* benchmarkId) {
    printf("Benchmark: %s\n", benchmarkId);
}

void printSystemInfo() {
    
    printf("System information\n"); 
    printf("O/S Name: ");
    
    #ifdef _WIN32
    printf("Windows 32-bit");
    #elif _WIN64
    printf("Windows 64-bit");
    #elif __APPLE__ || __MACH__
    printf("Mac OSX");
    #elif __linux__
    printf("Linux");
    #elif __FreeBSD__
    printf("FreeBSD");
    #elif __unix || __unix__
    printf("Unix");
    #else
    printf("Other");
    #endif
    
    printf("\n");
}
    

// *********** End of preamble.
#line 43 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\pingpong\\PingPongBenchmark.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numIterations;
    bool useInit;
    bool useCleanupIteration;
    unsigned count;
    instant_t startTime;
    interval_t* measuredTimes;
    benchmarkrunner_initBenchmark_t __initBenchmark;
    benchmarkrunner_cleanupIteration_t __cleanupIteration;
    benchmarkrunner_nextIteration_t __nextIteration;
    benchmarkrunner_finish_t __finish;
    benchmarkrunner_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inStart_t __default__inStart;
    benchmarkrunner_inIterationFinish_t* __inIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inIterationFinish_t __default__inIterationFinish;
    benchmarkrunner_inInitializeFinish_t* __inInitializeFinish;
    // width of -2 indicates that it is not a multiport.
    int __inInitializeFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inInitializeFinish_t __default__inInitializeFinish;
    benchmarkrunner_inCleanupIterationFinish_t* __inCleanupIterationFinish;
    // width of -2 indicates that it is not a multiport.
    int __inCleanupIterationFinish__width;
    // Default input (in case it does not get connected)
    benchmarkrunner_inCleanupIterationFinish_t __default__inCleanupIterationFinish;
    benchmarkrunner_outIterationStart_t __outIterationStart;
    int __outIterationStart__width;
    benchmarkrunner_outInitializeStart_t __outInitializeStart;
    int __outInitializeStart__width;
    benchmarkrunner_outCleanupIterationStart_t __outCleanupIterationStart;
    int __outCleanupIterationStart__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    reaction_t ___reaction_3;
    reaction_t ___reaction_4;
    reaction_t ___reaction_5;
    reaction_t ___reaction_6;
    reaction_t ___reaction_7;
    reaction_t ___reaction_8;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___initBenchmark;
    reaction_t* ___initBenchmark_reactions[1];
    trigger_t ___cleanupIteration;
    reaction_t* ___cleanupIteration_reactions[1];
    trigger_t ___nextIteration;
    reaction_t* ___nextIteration_reactions[1];
    trigger_t ___finish;
    reaction_t* ___finish_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
    trigger_t ___inIterationFinish;
    reaction_t* ___inIterationFinish_reactions[1];
    trigger_t ___inInitializeFinish;
    reaction_t* ___inInitializeFinish_reactions[1];
    trigger_t ___inCleanupIterationFinish;
    reaction_t* ___inCleanupIterationFinish_reactions[1];
} benchmarkrunner_self_t;
void benchmarkrunnerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    self->measuredTimes = calloc(self->numIterations, sizeof(interval_t));
        
}
void benchmarkrunnerreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_initBenchmark_t* initBenchmark = &self->__initBenchmark;
        schedule(initBenchmark, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outInitializeStart_t* outInitializeStart = &self->__outInitializeStart;
        
}
void benchmarkrunnerreaction_function_3(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inInitializeFinish_t* inInitializeFinish = self->__inInitializeFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inInitializeFinish_width = self->__inInitializeFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_4(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outCleanupIterationStart_t* outCleanupIterationStart = &self->__outCleanupIterationStart;
        
}
void benchmarkrunnerreaction_function_5(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inCleanupIterationFinish_t* inCleanupIterationFinish = self->__inCleanupIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inCleanupIterationFinish_width = self->__inCleanupIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
        
}
void benchmarkrunnerreaction_function_6(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_outIterationStart_t* outIterationStart = &self->__outIterationStart;
    benchmarkrunner_finish_t* finish = &self->__finish;
        self->startTime = get_physical_time();
        SET(outIterationStart, true);
    } else {
        schedule(finish, 0);
    }
        
}
void benchmarkrunnerreaction_function_7(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    benchmarkrunner_inIterationFinish_t* inIterationFinish = self->__inIterationFinish;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inIterationFinish_width = self->__inIterationFinish__width;
    #pragma GCC diagnostic pop
    benchmarkrunner_nextIteration_t* nextIteration = &self->__nextIteration;
    benchmarkrunner_cleanupIteration_t* cleanupIteration = &self->__cleanupIteration;
    interval_t duration = end_time - self->startTime;
    self->measuredTimes[self->count] = duration;
    self->count += 1;
    
    printf("Iteration: %d\t Duration: %.3f msec\n", self->count, toMS(duration));
    
    if(self->useCleanupIteration) {
        schedule(cleanupIteration, 0);
    } else {
        schedule(nextIteration, 0);
    }
        
}
void benchmarkrunnerreaction_function_8(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)instance_args;
    #pragma GCC diagnostic pop
    qsort(measuredMSTimes, self->numIterations, sizeof(double), comp);
    
    printf("Execution - Summary:\n");
    printf("Best Time:\t %.3f msec\n", measuredMSTimes[0]);
    printf("Worst Time:\t %.3f msec\n", measuredMSTimes[self->numIterations - 1]);
    printf("Median Time:\t %.3f msec\n", median(measuredMSTimes, self->numIterations));
    request_stop();
        
}
benchmarkrunner_self_t* new_BenchmarkRunner() {
    benchmarkrunner_self_t* self = (benchmarkrunner_self_t*)calloc(1, sizeof(benchmarkrunner_self_t));
    self->__initBenchmark.trigger = &self->___initBenchmark;
    self->__cleanupIteration.trigger = &self->___cleanupIteration;
    self->__nextIteration.trigger = &self->___nextIteration;
    self->__finish.trigger = &self->___finish;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    // Set input by default to an always absent default input.
    self->__inIterationFinish = &self->__default__inIterationFinish;
    // Set input by default to an always absent default input.
    self->__inInitializeFinish = &self->__default__inInitializeFinish;
    // Set input by default to an always absent default input.
    self->__inCleanupIterationFinish = &self->__default__inCleanupIterationFinish;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = benchmarkrunnerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = benchmarkrunnerreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = benchmarkrunnerreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___reaction_3.number = 3;
    self->___reaction_3.function = benchmarkrunnerreaction_function_3;
    self->___reaction_3.self = self;
    self->___reaction_3.deadline_violation_handler = NULL;
    self->___reaction_3.tardy_handler = NULL;
    self->___reaction_4.number = 4;
    self->___reaction_4.function = benchmarkrunnerreaction_function_4;
    self->___reaction_4.self = self;
    self->___reaction_4.deadline_violation_handler = NULL;
    self->___reaction_4.tardy_handler = NULL;
    self->___reaction_5.number = 5;
    self->___reaction_5.function = benchmarkrunnerreaction_function_5;
    self->___reaction_5.self = self;
    self->___reaction_5.deadline_violation_handler = NULL;
    self->___reaction_5.tardy_handler = NULL;
    self->___reaction_6.number = 6;
    self->___reaction_6.function = benchmarkrunnerreaction_function_6;
    self->___reaction_6.self = self;
    self->___reaction_6.deadline_violation_handler = NULL;
    self->___reaction_6.tardy_handler = NULL;
    self->___reaction_7.number = 7;
    self->___reaction_7.function = benchmarkrunnerreaction_function_7;
    self->___reaction_7.self = self;
    self->___reaction_7.deadline_violation_handler = NULL;
    self->___reaction_7.tardy_handler = NULL;
    self->___reaction_8.number = 8;
    self->___reaction_8.function = benchmarkrunnerreaction_function_8;
    self->___reaction_8.self = self;
    self->___reaction_8.deadline_violation_handler = NULL;
    self->___reaction_8.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___initBenchmark.last = NULL;
    self->___initBenchmark_reactions[0] = &self->___reaction_2;
    self->___initBenchmark.reactions = &self->___initBenchmark_reactions[0];
    self->___initBenchmark.number_of_reactions = 1;
    self->___initBenchmark.is_physical = false;
    self->___initBenchmark.element_size = sizeof(bool);
    self->___cleanupIteration.last = NULL;
    self->___cleanupIteration_reactions[0] = &self->___reaction_4;
    self->___cleanupIteration.reactions = &self->___cleanupIteration_reactions[0];
    self->___cleanupIteration.number_of_reactions = 1;
    self->___cleanupIteration.is_physical = false;
    self->___cleanupIteration.element_size = sizeof(bool);
    self->___nextIteration.last = NULL;
    self->___nextIteration_reactions[0] = &self->___reaction_6;
    self->___nextIteration.reactions = &self->___nextIteration_reactions[0];
    self->___nextIteration.number_of_reactions = 1;
    self->___nextIteration.is_physical = false;
    self->___nextIteration.element_size = sizeof(bool);
    self->___finish.last = NULL;
    self->___finish_reactions[0] = &self->___reaction_8;
    self->___finish.reactions = &self->___finish_reactions[0];
    self->___finish.number_of_reactions = 1;
    self->___finish.is_physical = false;
    self->___finish.element_size = sizeof(bool);
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_1;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    self->___inIterationFinish.last = NULL;
    self->___inIterationFinish_reactions[0] = &self->___reaction_7;
    self->___inIterationFinish.reactions = &self->___inIterationFinish_reactions[0];
    self->___inIterationFinish.number_of_reactions = 1;
    self->___inIterationFinish.element_size = sizeof(bool);
    self->___inInitializeFinish.last = NULL;
    self->___inInitializeFinish_reactions[0] = &self->___reaction_3;
    self->___inInitializeFinish.reactions = &self->___inInitializeFinish_reactions[0];
    self->___inInitializeFinish.number_of_reactions = 1;
    self->___inInitializeFinish.element_size = sizeof(bool);
    self->___inCleanupIterationFinish.last = NULL;
    self->___inCleanupIterationFinish_reactions[0] = &self->___reaction_5;
    self->___inCleanupIterationFinish.reactions = &self->___inCleanupIterationFinish_reactions[0];
    self->___inCleanupIterationFinish.number_of_reactions = 1;
    self->___inCleanupIterationFinish.element_size = sizeof(bool);
    return self;
}
void delete_BenchmarkRunner(benchmarkrunner_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    if (self->___reaction_3.output_produced != NULL) {
        free(self->___reaction_3.output_produced);
    }
    if (self->___reaction_3.triggers != NULL) {
        free(self->___reaction_3.triggers);
    }
    if (self->___reaction_3.triggered_sizes != NULL) {
        free(self->___reaction_3.triggered_sizes);
    }
    if (self->___reaction_4.output_produced != NULL) {
        free(self->___reaction_4.output_produced);
    }
    if (self->___reaction_4.triggers != NULL) {
        free(self->___reaction_4.triggers);
    }
    if (self->___reaction_4.triggered_sizes != NULL) {
        free(self->___reaction_4.triggered_sizes);
    }
    if (self->___reaction_5.output_produced != NULL) {
        free(self->___reaction_5.output_produced);
    }
    if (self->___reaction_5.triggers != NULL) {
        free(self->___reaction_5.triggers);
    }
    if (self->___reaction_5.triggered_sizes != NULL) {
        free(self->___reaction_5.triggered_sizes);
    }
    if (self->___reaction_6.output_produced != NULL) {
        free(self->___reaction_6.output_produced);
    }
    if (self->___reaction_6.triggers != NULL) {
        free(self->___reaction_6.triggers);
    }
    if (self->___reaction_6.triggered_sizes != NULL) {
        free(self->___reaction_6.triggered_sizes);
    }
    if (self->___reaction_7.output_produced != NULL) {
        free(self->___reaction_7.output_produced);
    }
    if (self->___reaction_7.triggers != NULL) {
        free(self->___reaction_7.triggers);
    }
    if (self->___reaction_7.triggered_sizes != NULL) {
        free(self->___reaction_7.triggered_sizes);
    }
    if (self->___reaction_8.output_produced != NULL) {
        free(self->___reaction_8.output_produced);
    }
    if (self->___reaction_8.triggers != NULL) {
        free(self->___reaction_8.triggers);
    }
    if (self->___reaction_8.triggered_sizes != NULL) {
        free(self->___reaction_8.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_3.num_outputs; i++) {
        free(self->___reaction_3.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_4.num_outputs; i++) {
        free(self->___reaction_4.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_5.num_outputs; i++) {
        free(self->___reaction_5.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_6.num_outputs; i++) {
        free(self->___reaction_6.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_7.num_outputs; i++) {
        free(self->___reaction_7.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_8.num_outputs; i++) {
        free(self->___reaction_8.triggers[i]);
    }
    free(self);
}
// =============== END reactor class BenchmarkRunner

// =============== START reactor class Ping
#line 38 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\pingpong\\PingPongBenchmark.lf"
typedef struct {
typedef struct {
    int bank_index;
    unsigned count;
    unsigned pings_left;
    ping_serve_t __serve;
    ping_inStart_t* __inStart;
    // width of -2 indicates that it is not a multiport.
    int __inStart__width;
    // Default input (in case it does not get connected)
    ping_inStart_t __default__inStart;
    ping_inPong_t* __inPong;
    // width of -2 indicates that it is not a multiport.
    int __inPong__width;
    // Default input (in case it does not get connected)
    ping_inPong_t __default__inPong;
    ping_outFinished_t __outFinished;
    int __outFinished__width;
    ping_outPing_t __outPing;
    int __outPing__width;
    reaction_t ___reaction_0;
    reaction_t ___reaction_1;
    reaction_t ___reaction_2;
    trigger_t ___serve;
    reaction_t* ___serve_reactions[1];
    trigger_t ___inStart;
    reaction_t* ___inStart_reactions[1];
    trigger_t ___inPong;
    reaction_t* ___inPong_reactions[1];
} ping_self_t;
void pingreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    ping_self_t* self = (ping_self_t*)instance_args;
    #pragma GCC diagnostic pop
    ping_inStart_t* inStart = self->__inStart;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inStart_width = self->__inStart__width;
    #pragma GCC diagnostic pop
    ping_serve_t* serve = &self->__serve;
    // reset local state
    self->pings_left = self->count;
    
    // start execution
    schedule(serve, 0);
        
}
void pingreaction_function_1(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    ping_self_t* self = (ping_self_t*)instance_args;
    #pragma GCC diagnostic pop
    ping_outPing_t* outPing = &self->__outPing;
    SET(outPing, true); 
        
}
void pingreaction_function_2(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    ping_self_t* self = (ping_self_t*)instance_args;
    #pragma GCC diagnostic pop
    ping_inPong_t* inPong = self->__inPong;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int inPong_width = self->__inPong__width;
    #pragma GCC diagnostic pop
    ping_serve_t* serve = &self->__serve;
    ping_outFinished_t* outFinished = &self->__outFinished;
        SET(outFinished, true);
    } else {
        schedule(serve, 0);
    }
        
}
ping_self_t* new_Ping() {
    ping_self_t* self = (ping_self_t*)calloc(1, sizeof(ping_self_t));
    self->__serve.trigger = &self->___serve;
    // Set input by default to an always absent default input.
    self->__inStart = &self->__default__inStart;
    // Set input by default to an always absent default input.
    self->__inPong = &self->__default__inPong;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = pingreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___reaction_1.number = 1;
    self->___reaction_1.function = pingreaction_function_1;
    self->___reaction_1.self = self;
    self->___reaction_1.deadline_violation_handler = NULL;
    self->___reaction_1.tardy_handler = NULL;
    self->___reaction_2.number = 2;
    self->___reaction_2.function = pingreaction_function_2;
    self->___reaction_2.self = self;
    self->___reaction_2.deadline_violation_handler = NULL;
    self->___reaction_2.tardy_handler = NULL;
    self->___serve.last = NULL;
    self->___serve_reactions[0] = &self->___reaction_1;
    self->___serve.reactions = &self->___serve_reactions[0];
    self->___serve.number_of_reactions = 1;
    self->___serve.is_physical = false;
    self->___serve.element_size = 0;
    self->___inStart.last = NULL;
    self->___inStart_reactions[0] = &self->___reaction_0;
    self->___inStart.reactions = &self->___inStart_reactions[0];
    self->___inStart.number_of_reactions = 1;
    self->___inStart.element_size = sizeof(bool);
    self->___inPong.last = NULL;
    self->___inPong_reactions[0] = &self->___reaction_2;
    self->___inPong.reactions = &self->___inPong_reactions[0];
    self->___inPong.number_of_reactions = 1;
    self->___inPong.element_size = sizeof(bool);
    return self;
}
void delete_Ping(ping_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Ping

// =============== START reactor class PingPong
typedef struct {
    int bank_index;
    int numIterations;
    unsigned count;
    struct {
        benchmarkrunner_inStart_t inStart;
    } __runner;
    reaction_t ___reaction_0;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
} pingpong_self_t;
void pingpongreaction_function_0(void* instance_args) {
    struct runner{
        benchmarkrunner_inStart_t* inStart;
    } runner;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    pingpong_self_t* self = (pingpong_self_t*)instance_args;
    #pragma GCC diagnostic pop
    runner.inStart = &(self->__runner.inStart);
    printf("numIterations: %d, count: %d\n", self->numIterations, self->count);
    printSystemInfo(); 
    SET(runner.inStart, true);
        
}
pingpong_self_t* new_PingPong() {
    pingpong_self_t* self = (pingpong_self_t*)calloc(1, sizeof(pingpong_self_t));
    self->___reaction_0.number = 0;
    self->___reaction_0.function = pingpongreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    return self;
}
void delete_PingPong(pingpong_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class PingPong

char* __default_argv[] = {"PingPongBenchmark", "-f", "true"};
void __set_default_command_line_options() {
    default_argc = 3;
    default_argv = __default_argv;
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t** __timer_triggers = NULL;
int __timer_triggers_size = 0;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[2];
int __startup_reactions_size = 2;
// Empty array of pointers to shutdown triggers.
reaction_t** __shutdown_reactions = NULL;
int __shutdown_reactions_size = 0;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 5;
    __tokens_with_ref_count = (token_present_t*)malloc(5 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 12;
    __is_present_fields = (bool**)malloc(12 * sizeof(bool*));
    // ************* Instance PingPong of class PingPong
    pingpong_self_t* pingpong_self = new_PingPong();
    //***** Start initializing PingPong
    pingpong_self->numIterations = 12; 
    pingpong_self->count = 1000000; 
    __startup_reactions[0] = &pingpong_self->___reaction_0;
    // ************* Instance PingPong.ping of class Ping
    ping_self_t* pingpong_ping_self = new_Ping();
    //***** Start initializing PingPong.ping
    pingpong_ping_self->count = 1000000; 
    // width of -2 indicates that it is not a multiport.
    pingpong_ping_self->__outFinished__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_ping_self->__outPing__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_ping_self->__inStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_ping_self->__inPong__width = -2;
    static unsigned pingpong_ping_initial_pings_left = 0;
    pingpong_ping_self->pings_left = pingpong_ping_initial_pings_left;
    pingpong_ping_self->___serve.offset = 0;
    pingpong_ping_self->___serve.period = -1;
    pingpong_ping_self->___serve.token = __create_token(0);
    pingpong_ping_self->___serve.is_present = false;
    __tokens_with_ref_count[0].token
            = &pingpong_ping_self->___serve.token;
    __tokens_with_ref_count[0].is_present
            = &pingpong_ping_self->___serve.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing PingPong.ping
    // ************* Instance PingPong.runner of class BenchmarkRunner
    benchmarkrunner_self_t* pingpong_runner_self = new_BenchmarkRunner();
    //***** Start initializing PingPong.runner
    pingpong_runner_self->numIterations = 12; 
    pingpong_runner_self->useInit = false; 
    pingpong_runner_self->useCleanupIteration = false; 
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__outIterationStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__outInitializeStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__outCleanupIterationStart__width = -2;
    __startup_reactions[1] = &pingpong_runner_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__inStart__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__inIterationFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__inInitializeFinish__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_runner_self->__inCleanupIterationFinish__width = -2;
    static unsigned pingpong_runner_initial_count = 0;
    pingpong_runner_self->count = pingpong_runner_initial_count;
    pingpong_runner_self->___initBenchmark.offset = 0;
    pingpong_runner_self->___initBenchmark.period = -1;
    pingpong_runner_self->___cleanupIteration.offset = 0;
    pingpong_runner_self->___cleanupIteration.period = -1;
    pingpong_runner_self->___nextIteration.offset = 0;
    pingpong_runner_self->___nextIteration.period = -1;
    pingpong_runner_self->___finish.offset = 0;
    pingpong_runner_self->___finish.period = -1;
    pingpong_runner_self->___initBenchmark.token = __create_token(sizeof(bool));
    pingpong_runner_self->___initBenchmark.is_present = false;
    __tokens_with_ref_count[1].token
            = &pingpong_runner_self->___initBenchmark.token;
    __tokens_with_ref_count[1].is_present
            = &pingpong_runner_self->___initBenchmark.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    pingpong_runner_self->___cleanupIteration.token = __create_token(sizeof(bool));
    pingpong_runner_self->___cleanupIteration.is_present = false;
    __tokens_with_ref_count[2].token
            = &pingpong_runner_self->___cleanupIteration.token;
    __tokens_with_ref_count[2].is_present
            = &pingpong_runner_self->___cleanupIteration.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    pingpong_runner_self->___nextIteration.token = __create_token(sizeof(bool));
    pingpong_runner_self->___nextIteration.is_present = false;
    __tokens_with_ref_count[3].token
            = &pingpong_runner_self->___nextIteration.token;
    __tokens_with_ref_count[3].is_present
            = &pingpong_runner_self->___nextIteration.is_present;
    __tokens_with_ref_count[3].reset_is_present = true;
    pingpong_runner_self->___finish.token = __create_token(sizeof(bool));
    pingpong_runner_self->___finish.is_present = false;
    __tokens_with_ref_count[4].token
            = &pingpong_runner_self->___finish.token;
    __tokens_with_ref_count[4].is_present
            = &pingpong_runner_self->___finish.is_present;
    __tokens_with_ref_count[4].reset_is_present = true;
    //***** End initializing PingPong.runner
    // ************* Instance PingPong.pong of class Pong
    pong_self_t* pingpong_pong_self = new_Pong();
    //***** Start initializing PingPong.pong
    // width of -2 indicates that it is not a multiport.
    pingpong_pong_self->__outPong__width = -2;
    // width of -2 indicates that it is not a multiport.
    pingpong_pong_self->__inPing__width = -2;
    //***** End initializing PingPong.pong
    //***** End initializing PingPong
    // Populate arrays of trigger pointers.
    pingpong_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    pingpong_self->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_self->___reaction_0.num_outputs > 0) {
        pingpong_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_self->___reaction_0.num_outputs);
        pingpong_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_self->___reaction_0.num_outputs);
        pingpong_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_self->___reaction_0.output_produced[0]
    = &pingpong_self->__runner.inStart.is_present
    ;
    // Reaction 0 of PingPong does not depend on one maximal upstream reaction.
    pingpong_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of PingPong triggers 1 downstream reactions through port PingPong.runner.inStart.
    pingpong_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of PingPong, allocate an
    // array of trigger pointers for downstream reactions through port PingPong.runner.inStart
    trigger_t** pingpong_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    pingpong_self->___reaction_0.triggers[0] = pingpong_0_0;
    // Point to destination port PingPong.runner.inStart's trigger struct.
    pingpong_0_0[0] = &pingpong_runner_self->___inStart;
    pingpong_self->__runner.inStart.
    num_destinations = 1;
    pingpong_ping_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    pingpong_ping_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_ping_self->___reaction_0.num_outputs > 0) {
        pingpong_ping_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_ping_self->___reaction_0.num_outputs);
        pingpong_ping_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_ping_self->___reaction_0.num_outputs);
        pingpong_ping_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_ping_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_ping_self->___reaction_1.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_ping_self->___reaction_1.num_outputs > 0) {
        pingpong_ping_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_ping_self->___reaction_1.num_outputs);
        pingpong_ping_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_ping_self->___reaction_1.num_outputs);
        pingpong_ping_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_ping_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_ping_self->___reaction_1.output_produced[0]
    = &pingpong_ping_self->__outPing.is_present
    ;
    // Total number of outputs produced by the reaction.
    pingpong_ping_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_ping_self->___reaction_2.num_outputs > 0) {
        pingpong_ping_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_ping_self->___reaction_2.num_outputs);
        pingpong_ping_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_ping_self->___reaction_2.num_outputs);
        pingpong_ping_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_ping_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_ping_self->___reaction_2.output_produced[0]
    = &pingpong_ping_self->__outFinished.is_present
    ;
    // Reaction 0 of PingPong.ping depends on one maximal upstream reaction.
    pingpong_ping_self->___reaction_0.last_enabling_reaction = &(pingpong_runner_self->___reaction_6);
    // Reaction 1 of PingPong.ping depends on one maximal upstream reaction.
    pingpong_ping_self->___reaction_1.last_enabling_reaction = &(pingpong_ping_self->___reaction_0);
    // Reaction 1 of PingPong.ping triggers 1 downstream reactions through port PingPong.ping.outPing.
    pingpong_ping_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of PingPong.ping, allocate an
    // array of trigger pointers for downstream reactions through port PingPong.ping.outPing
    trigger_t** pingpong_ping_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    pingpong_ping_self->___reaction_1.triggers[0] = pingpong_ping_1_0;
    // Point to destination port PingPong.pong.inPing's trigger struct.
    pingpong_ping_1_0[0] = &pingpong_pong_self->___inPing;
    // Reaction 2 of PingPong.ping depends on one maximal upstream reaction.
    pingpong_ping_self->___reaction_2.last_enabling_reaction = &(pingpong_pong_self->___reaction_0);
    // Reaction 2 of PingPong.ping triggers 1 downstream reactions through port PingPong.ping.outFinished.
    pingpong_ping_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of PingPong.ping, allocate an
    // array of trigger pointers for downstream reactions through port PingPong.ping.outFinished
    trigger_t** pingpong_ping_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    pingpong_ping_self->___reaction_2.triggers[0] = pingpong_ping_2_0;
    // Point to destination port PingPong.runner.inIterationFinish's trigger struct.
    pingpong_ping_2_0[0] = &pingpong_runner_self->___inIterationFinish;
    pingpong_ping_self->__outFinished.num_destinations
    = 1;
    pingpong_ping_self->__outPing.num_destinations
    = 1;
    pingpong_runner_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_0.num_outputs > 0) {
        pingpong_runner_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_0.num_outputs);
        pingpong_runner_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_0.num_outputs);
        pingpong_runner_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_1.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_1.num_outputs > 0) {
        pingpong_runner_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_1.num_outputs);
        pingpong_runner_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_1.num_outputs);
        pingpong_runner_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_2.num_outputs > 0) {
        pingpong_runner_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_2.num_outputs);
        pingpong_runner_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_2.num_outputs);
        pingpong_runner_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_runner_self->___reaction_2.output_produced[0]
    = &pingpong_runner_self->__outInitializeStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_3.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_3.num_outputs > 0) {
        pingpong_runner_self->___reaction_3.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_3.num_outputs);
        pingpong_runner_self->___reaction_3.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_3.num_outputs);
        pingpong_runner_self->___reaction_3.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_3.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_4.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_4.num_outputs > 0) {
        pingpong_runner_self->___reaction_4.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_4.num_outputs);
        pingpong_runner_self->___reaction_4.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_4.num_outputs);
        pingpong_runner_self->___reaction_4.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_4.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_runner_self->___reaction_4.output_produced[0]
    = &pingpong_runner_self->__outCleanupIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_5.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_5.num_outputs > 0) {
        pingpong_runner_self->___reaction_5.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_5.num_outputs);
        pingpong_runner_self->___reaction_5.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_5.num_outputs);
        pingpong_runner_self->___reaction_5.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_5.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_6.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_6.num_outputs > 0) {
        pingpong_runner_self->___reaction_6.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_6.num_outputs);
        pingpong_runner_self->___reaction_6.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_6.num_outputs);
        pingpong_runner_self->___reaction_6.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_6.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_runner_self->___reaction_6.output_produced[0]
    = &pingpong_runner_self->__outIterationStart.is_present
    ;
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_7.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_7.num_outputs > 0) {
        pingpong_runner_self->___reaction_7.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_7.num_outputs);
        pingpong_runner_self->___reaction_7.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_7.num_outputs);
        pingpong_runner_self->___reaction_7.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_7.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    pingpong_runner_self->___reaction_8.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_runner_self->___reaction_8.num_outputs > 0) {
        pingpong_runner_self->___reaction_8.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_runner_self->___reaction_8.num_outputs);
        pingpong_runner_self->___reaction_8.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_runner_self->___reaction_8.num_outputs);
        pingpong_runner_self->___reaction_8.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_runner_self->___reaction_8.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of PingPong.runner does not depend on one maximal upstream reaction.
    pingpong_runner_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of PingPong.runner does not depend on one maximal upstream reaction.
    pingpong_runner_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 2 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_2.last_enabling_reaction = &(pingpong_runner_self->___reaction_1);
    // Reaction 2 of PingPong.runner triggers 0 downstream reactions through port PingPong.runner.outInitializeStart.
    pingpong_runner_self->___reaction_2.triggered_sizes[0] = 0;
    // Reaction 3 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_3.last_enabling_reaction = &(pingpong_runner_self->___reaction_2);
    // Reaction 4 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_4.last_enabling_reaction = &(pingpong_runner_self->___reaction_3);
    // Reaction 4 of PingPong.runner triggers 0 downstream reactions through port PingPong.runner.outCleanupIterationStart.
    pingpong_runner_self->___reaction_4.triggered_sizes[0] = 0;
    // Reaction 5 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_5.last_enabling_reaction = &(pingpong_runner_self->___reaction_4);
    // Reaction 6 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_6.last_enabling_reaction = &(pingpong_runner_self->___reaction_5);
    // Reaction 6 of PingPong.runner triggers 1 downstream reactions through port PingPong.runner.outIterationStart.
    pingpong_runner_self->___reaction_6.triggered_sizes[0] = 1;
    // For reaction 6 of PingPong.runner, allocate an
    // array of trigger pointers for downstream reactions through port PingPong.runner.outIterationStart
    trigger_t** pingpong_runner_6_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    pingpong_runner_self->___reaction_6.triggers[0] = pingpong_runner_6_0;
    // Point to destination port PingPong.ping.inStart's trigger struct.
    pingpong_runner_6_0[0] = &pingpong_ping_self->___inStart;
    // Reaction 7 of PingPong.runner does not depend on one maximal upstream reaction.
    pingpong_runner_self->___reaction_7.last_enabling_reaction = NULL;
    // Reaction 8 of PingPong.runner depends on one maximal upstream reaction.
    pingpong_runner_self->___reaction_8.last_enabling_reaction = &(pingpong_runner_self->___reaction_7);
    pingpong_runner_self->__outIterationStart.num_destinations
    = 1;
    pingpong_runner_self->__outInitializeStart.num_destinations
    = 0;
    pingpong_runner_self->__outCleanupIterationStart.num_destinations
    = 0;
    pingpong_pong_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    pingpong_pong_self->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (pingpong_pong_self->___reaction_0.num_outputs > 0) {
        pingpong_pong_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * pingpong_pong_self->___reaction_0.num_outputs);
        pingpong_pong_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * pingpong_pong_self->___reaction_0.num_outputs);
        pingpong_pong_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * pingpong_pong_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    pingpong_pong_self->___reaction_0.output_produced[0]
    = &pingpong_pong_self->__outPong.is_present
    ;
    // Reaction 0 of PingPong.pong depends on one maximal upstream reaction.
    pingpong_pong_self->___reaction_0.last_enabling_reaction = &(pingpong_ping_self->___reaction_1);
    // Reaction 0 of PingPong.pong triggers 1 downstream reactions through port PingPong.pong.outPong.
    pingpong_pong_self->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of PingPong.pong, allocate an
    // array of trigger pointers for downstream reactions through port PingPong.pong.outPong
    trigger_t** pingpong_pong_0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    pingpong_pong_self->___reaction_0.triggers[0] = pingpong_pong_0_0;
    // Point to destination port PingPong.ping.inPong's trigger struct.
    pingpong_pong_0_0[0] = &pingpong_ping_self->___inPong;
    pingpong_pong_self->__outPong.num_destinations
    = 1;
    // doDeferredInitialize
    // Connect inputs and outputs for reactor PingPong.
    // Connect PingPong.runner.outIterationStart to input port PingPong.ping.inStart
    pingpong_ping_self->__inStart = (ping_inStart_t*)&pingpong_runner_self->__outIterationStart;
    // Connect PingPong.ping.outFinished to input port PingPong.runner.inIterationFinish
    pingpong_runner_self->__inIterationFinish = (benchmarkrunner_inIterationFinish_t*)&pingpong_ping_self->__outFinished;
    // Connect PingPong.ping.outPing to input port PingPong.pong.inPing
    pingpong_pong_self->__inPing = (pong_inPing_t*)&pingpong_ping_self->__outPing;
    // Connect PingPong.pong.outPong to input port PingPong.ping.inPong
    pingpong_ping_self->__inPong = (ping_inPong_t*)&pingpong_pong_self->__outPong;
    // Connect inputs and outputs for reactor PingPong.ping.
    // END Connect inputs and outputs for reactor PingPong.ping.
    // Connect inputs and outputs for reactor PingPong.runner.
    // END Connect inputs and outputs for reactor PingPong.runner.
    // Connect inputs and outputs for reactor PingPong.pong.
    // END Connect inputs and outputs for reactor PingPong.pong.
    // Connect PortInstance PingPong.runner.inStart, which gets data from reaction 0
    // of PingPong, to PingPong.runner.inStart.
    pingpong_runner_self->__inStart = (benchmarkrunner_inStart_t*)&pingpong_self->__runner.inStart;
    // END Connect inputs and outputs for reactor PingPong.
    // Add action PingPong.ping.serve to array of is_present fields.
    __is_present_fields[0] 
            = &pingpong_ping_self->__serve.is_present;
    // Add action PingPong.runner.initBenchmark to array of is_present fields.
    __is_present_fields[1] 
            = &pingpong_runner_self->__initBenchmark.is_present;
    // Add action PingPong.runner.cleanupIteration to array of is_present fields.
    __is_present_fields[2] 
            = &pingpong_runner_self->__cleanupIteration.is_present;
    // Add action PingPong.runner.nextIteration to array of is_present fields.
    __is_present_fields[3] 
            = &pingpong_runner_self->__nextIteration.is_present;
    // Add action PingPong.runner.finish to array of is_present fields.
    __is_present_fields[4] 
            = &pingpong_runner_self->__finish.is_present;
    // Add port PingPong.runner.inStart to array of is_present fields.
    __is_present_fields[5] 
            = &pingpong_self->__runner.inStart.
            is_present;
    // Add port PingPong.ping.outFinished to array of is_present fields.
    __is_present_fields[6] = &pingpong_ping_self->__outFinished.is_present
    ;
    // Add port PingPong.ping.outPing to array of is_present fields.
    __is_present_fields[7] = &pingpong_ping_self->__outPing.is_present
    ;
    // Add port PingPong.runner.outIterationStart to array of is_present fields.
    __is_present_fields[8] = &pingpong_runner_self->__outIterationStart.is_present
    ;
    // Add port PingPong.runner.outInitializeStart to array of is_present fields.
    __is_present_fields[9] = &pingpong_runner_self->__outInitializeStart.is_present
    ;
    // Add port PingPong.runner.outCleanupIterationStart to array of is_present fields.
    __is_present_fields[10] = &pingpong_runner_self->__outCleanupIterationStart.is_present
    ;
    // Add port PingPong.pong.outPong to array of is_present fields.
    __is_present_fields[11] = &pingpong_pong_self->__outPong.is_present
    ;
    pingpong_self->___reaction_0.chain_id = 7;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_self->___reaction_0.index = 0x7fffffffffff0000LL;
    pingpong_ping_self->___reaction_0.chain_id = 3;
    // index is the OR of level 7 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_ping_self->___reaction_0.index = 0x7fffffffffff0007LL;
    pingpong_ping_self->___reaction_1.chain_id = 3;
    // index is the OR of level 8 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_ping_self->___reaction_1.index = 0x7fffffffffff0008LL;
    pingpong_ping_self->___reaction_2.chain_id = 3;
    // index is the OR of level 10 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_ping_self->___reaction_2.index = 0x7fffffffffff000aLL;
    pingpong_runner_self->___reaction_0.chain_id = 8;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_0.index = 0x7fffffffffff0000LL;
    pingpong_runner_self->___reaction_1.chain_id = 15;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_1.index = 0x7fffffffffff0001LL;
    pingpong_runner_self->___reaction_2.chain_id = 15;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_2.index = 0x7fffffffffff0002LL;
    pingpong_runner_self->___reaction_3.chain_id = 15;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_3.index = 0x7fffffffffff0003LL;
    pingpong_runner_self->___reaction_4.chain_id = 15;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_4.index = 0x7fffffffffff0004LL;
    pingpong_runner_self->___reaction_5.chain_id = 15;
    // index is the OR of level 5 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_5.index = 0x7fffffffffff0005LL;
    pingpong_runner_self->___reaction_6.chain_id = 15;
    // index is the OR of level 6 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_6.index = 0x7fffffffffff0006LL;
    pingpong_runner_self->___reaction_7.chain_id = 15;
    // index is the OR of level 11 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_7.index = 0x7fffffffffff000bLL;
    pingpong_runner_self->___reaction_8.chain_id = 15;
    // index is the OR of level 12 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_runner_self->___reaction_8.index = 0x7fffffffffff000cLL;
    pingpong_pong_self->___reaction_0.chain_id = 1;
    // index is the OR of level 9 and 
    // deadline 140737488355327 shifted left 16 bits.
    pingpong_pong_self->___reaction_0.index = 0x7fffffffffff0009LL;
    calculate_epoch_offset();
}
void __trigger_startup_reactions() {
    
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
}
void logical_tag_complete(tag_t tag_to_send) {
}
tag_t send_next_event_tag(tag_t tag, bool wait_for_reply) {
    return tag;
}
bool __trigger_shutdown_reactions() {                          
    for (int i = 0; i < __shutdown_reactions_size; i++) {
        if (__shutdown_reactions[i] != NULL) {
            _lf_enqueue_reaction(__shutdown_reactions[i]);
        }
    }
    // Return true if there are shutdown reactions.
    return (__shutdown_reactions_size > 0);
}
void __termination() {stop_trace();}


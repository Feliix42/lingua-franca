#define LOG_LEVEL 2
#include "ctarget.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor_threaded.c"
// Code generated by the Lingua Franca compiler from file:
// C:\Users\soyer\lingua-franca-master\git\lingua-franca\benchmark\C\Savina\bndbuffer\ProducerConsumerSync.lf
#include <stdlib.h>
#include <stddef.h>
#include <math.h>
#include "PseudoRandom.h"

static double processItem(const double curTerm, const int cost) {
        double res = curTerm;
    struct PseudoRandom random;
    initPseudoRandom(&random, cost);
    if(cost > 0) {
        for(int i = 0; i < cost; i++) {
            for(int j = 0; j < 100; j++) {
                res += log(fabs(nextDouble(random)) + 0.01);
                }
            }
        } else {
            res += log(fabs(nextDouble(random)) + 0.01);
        }
    return res;
    }
    
    void printBenchmarkInfo(char* benchmarkId) {
    printf("Benchmark: %s\n", benchmarkId);
}
    
void printSystemInfo() {
        
    printf("System information\n"); 
    printf("O/S Name: ");
        
    #ifdef _WIN32
    printf("Windows 32-bit");
    #elif _WIN64
    printf("Windows 64-bit");
    #elif __APPLE__ || __MACH__
    printf("Mac OSX");
    #elif __linux__
    printf("Linux");
    #elif __FreeBSD__
    printf("FreeBSD");
    #elif __unix || __unix__
    printf("Unix");
    #else
    printf("Other");
    #endif
        
    printf("\n");
}
    
// =============== START reactor class Consumer
#line 95 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\bndbuffer\\ProducerConsumerSync.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numItemsToConsume;
    int consCost;
    double consItem;
    int itemsConsumed;
    consumer_data_t* __data;
    // width of -2 indicates that it is not a multiport.
    int __data__width;
    // Default input (in case it does not get connected)
    consumer_data_t __default__data;
    reaction_t ___reaction_0;
    trigger_t ___data;
    reaction_t* ___data_reactions[1];
} consumer_self_t;
void consumerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    consumer_self_t* self = (consumer_self_t*)instance_args;
    #pragma GCC diagnostic pop
    consumer_data_t* data = self->__data;
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    int data_width = self->__data__width;
    #pragma GCC diagnostic pop
    self->itemsConsumed += 1;
    if (self->itemsConsumed == self->numItemsToConsume) {
                request_stop();
    }
        
}
consumer_self_t* new_Consumer() {
    consumer_self_t* self = (consumer_self_t*)calloc(1, sizeof(consumer_self_t));
    // Set input by default to an always absent default input.
    self->__data = &self->__default__data;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = consumerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___data.last = NULL;
    self->___data_reactions[0] = &self->___reaction_0;
    self->___data.reactions = &self->___data_reactions[0];
    self->___data.number_of_reactions = 1;
    self->___data.element_size = sizeof(double);
    return self;
}
void delete_Consumer(consumer_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Consumer

// =============== START reactor class Producer
#line 78 "file:C:\\Users\\soyer\\lingua-franca-master\\git\\lingua-franca\\benchmark\\C\\Savina\\bndbuffer\\ProducerConsumerSync.lf"
typedef struct {
typedef struct {
    int bank_index;
    int numItemsToProduce;
    int prodCost;
    double prodItem;
    int itemsProduced;
    producer_next_t __next;
    producer_data_t __data;
    int __data__width;
    reaction_t ___reaction_0;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___next;
    reaction_t* ___next_reactions[1];
} producer_self_t;
void producerreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    producer_self_t* self = (producer_self_t*)instance_args;
    #pragma GCC diagnostic pop
    producer_data_t* data = &self->__data;
        return;
    } else {
        schedule(next, 0);
        SET(data, processItem(self->prodItem, self->prodCost));
        self->itemsProduced += 1;
    }
        
}
producer_self_t* new_Producer() {
    producer_self_t* self = (producer_self_t*)calloc(1, sizeof(producer_self_t));
    self->__next.trigger = &self->___next;
    self->___reaction_0.number = 0;
    self->___reaction_0.function = producerreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___next.last = NULL;
    self->___next_reactions[0] = &self->___reaction_0;
    self->___next.reactions = &self->___next_reactions[0];
    self->___next.number_of_reactions = 1;
    self->___next.is_physical = false;
    self->___next.element_size = 0;
    return self;
}
void delete_Producer(producer_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class Producer

// =============== START reactor class ProducerConsumerSync
typedef struct {
    int bank_index;
    int bufferSize;
    int prodCost;
    int consCost;
    int numItemsPerProducer;
    reaction_t ___reaction_0;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
} producerconsumersync_self_t;
void producerconsumersyncreaction_function_0(void* instance_args) {
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wunused-variable"
    producerconsumersync_self_t* self = (producerconsumersync_self_t*)instance_args;
    #pragma GCC diagnostic pop
    // printArgs("numIterations", self->numIterations, "bufferSize", self->bufferSize, "prodCost", self->prodCost, "consCost", self>consCost, "numItemsPerProducer", self->numItemsPerProducer, "numProducers", 40, "numConsumers", 40);
    printf("bufferSize: %d.\n", self->bufferSize);
    printf("prodCost: %d.\n", self->prodCost);
    printf("consCost: %d.\n", self->consCost);
    printf("numItemsPerProducer: %d.\n", self->numItemsPerProducer);
    printf("numProducers: %d.\n", 40);
    printf("numConsumers: %d.\n", 40);
            
    printSystemInfo();
        
}
producerconsumersync_self_t* new_ProducerConsumerSync() {
    producerconsumersync_self_t* self = (producerconsumersync_self_t*)calloc(1, sizeof(producerconsumersync_self_t));
    self->___reaction_0.number = 0;
    self->___reaction_0.function = producerconsumersyncreaction_function_0;
    self->___reaction_0.self = self;
    self->___reaction_0.deadline_violation_handler = NULL;
    self->___reaction_0.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    return self;
}
void delete_ProducerConsumerSync(producerconsumersync_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    free(self);
}
// =============== END reactor class ProducerConsumerSync

char* __default_argv[] = {"ProducerConsumerSync", "-k", "true"};
void __set_default_command_line_options() {
    default_argc = 3;
    default_argv = __default_argv;
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t** __timer_triggers = NULL;
int __timer_triggers_size = 0;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[41];
int __startup_reactions_size = 41;
// Empty array of pointers to shutdown triggers.
reaction_t** __shutdown_reactions = NULL;
int __shutdown_reactions_size = 0;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 40;
    __tokens_with_ref_count = (token_present_t*)malloc(40 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 80;
    __is_present_fields = (bool**)malloc(80 * sizeof(bool*));
    // ************* Instance ProducerConsumerSync of class ProducerConsumerSync
    producerconsumersync_self_t* producerconsumersync_self = new_ProducerConsumerSync();
    //***** Start initializing ProducerConsumerSync
    producerconsumersync_self->bufferSize = 50; 
    producerconsumersync_self->prodCost = 25; 
    producerconsumersync_self->consCost = 25; 
    producerconsumersync_self->numItemsPerProducer = 1000; 
    __startup_reactions[0] = &producerconsumersync_self->___reaction_0;
    // ************* Instance ProducerConsumerSync.producers of class Producer
    producer_self_t* producerconsumersync_producers_self[40];
    // ************* Instance ProducerConsumerSync.producers[0] of class Producer
    producerconsumersync_producers_self[0] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[0]
    producerconsumersync_producers_self[0]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[0]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[0]->__data__width = -2;
    __startup_reactions[1] = &producerconsumersync_producers_self[0]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_0 = 0.0;
    producerconsumersync_producers_self[0]->prodItem = producerconsumersync_producers_initial_prodItem_0;
    static int producerconsumersync_producers_initial_itemsProduced_0 = 0;
    producerconsumersync_producers_self[0]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_0;
    producerconsumersync_producers_self[0]->___next.offset = 0;
    producerconsumersync_producers_self[0]->___next.period = -1;
    producerconsumersync_producers_self[0]->___next.token = __create_token(0);
    producerconsumersync_producers_self[0]->___next.is_present = false;
    __tokens_with_ref_count[0].token
            = &producerconsumersync_producers_self[0]->___next.token;
    __tokens_with_ref_count[0].is_present
            = &producerconsumersync_producers_self[0]->___next.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[0]
    // ************* Instance ProducerConsumerSync.producers[1] of class Producer
    producerconsumersync_producers_self[1] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[1]
    producerconsumersync_producers_self[1]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[1]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[1]->__data__width = -2;
    __startup_reactions[2] = &producerconsumersync_producers_self[1]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_1 = 0.0;
    producerconsumersync_producers_self[1]->prodItem = producerconsumersync_producers_initial_prodItem_1;
    static int producerconsumersync_producers_initial_itemsProduced_1 = 0;
    producerconsumersync_producers_self[1]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_1;
    producerconsumersync_producers_self[1]->___next.offset = 0;
    producerconsumersync_producers_self[1]->___next.period = -1;
    producerconsumersync_producers_self[1]->___next.token = __create_token(0);
    producerconsumersync_producers_self[1]->___next.is_present = false;
    __tokens_with_ref_count[1].token
            = &producerconsumersync_producers_self[1]->___next.token;
    __tokens_with_ref_count[1].is_present
            = &producerconsumersync_producers_self[1]->___next.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[1]
    // ************* Instance ProducerConsumerSync.producers[2] of class Producer
    producerconsumersync_producers_self[2] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[2]
    producerconsumersync_producers_self[2]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[2]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[2]->__data__width = -2;
    __startup_reactions[3] = &producerconsumersync_producers_self[2]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_2 = 0.0;
    producerconsumersync_producers_self[2]->prodItem = producerconsumersync_producers_initial_prodItem_2;
    static int producerconsumersync_producers_initial_itemsProduced_2 = 0;
    producerconsumersync_producers_self[2]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_2;
    producerconsumersync_producers_self[2]->___next.offset = 0;
    producerconsumersync_producers_self[2]->___next.period = -1;
    producerconsumersync_producers_self[2]->___next.token = __create_token(0);
    producerconsumersync_producers_self[2]->___next.is_present = false;
    __tokens_with_ref_count[2].token
            = &producerconsumersync_producers_self[2]->___next.token;
    __tokens_with_ref_count[2].is_present
            = &producerconsumersync_producers_self[2]->___next.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[2]
    // ************* Instance ProducerConsumerSync.producers[3] of class Producer
    producerconsumersync_producers_self[3] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[3]
    producerconsumersync_producers_self[3]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[3]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[3]->__data__width = -2;
    __startup_reactions[4] = &producerconsumersync_producers_self[3]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_3 = 0.0;
    producerconsumersync_producers_self[3]->prodItem = producerconsumersync_producers_initial_prodItem_3;
    static int producerconsumersync_producers_initial_itemsProduced_3 = 0;
    producerconsumersync_producers_self[3]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_3;
    producerconsumersync_producers_self[3]->___next.offset = 0;
    producerconsumersync_producers_self[3]->___next.period = -1;
    producerconsumersync_producers_self[3]->___next.token = __create_token(0);
    producerconsumersync_producers_self[3]->___next.is_present = false;
    __tokens_with_ref_count[3].token
            = &producerconsumersync_producers_self[3]->___next.token;
    __tokens_with_ref_count[3].is_present
            = &producerconsumersync_producers_self[3]->___next.is_present;
    __tokens_with_ref_count[3].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[3]
    // ************* Instance ProducerConsumerSync.producers[4] of class Producer
    producerconsumersync_producers_self[4] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[4]
    producerconsumersync_producers_self[4]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[4]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[4]->__data__width = -2;
    __startup_reactions[5] = &producerconsumersync_producers_self[4]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_4 = 0.0;
    producerconsumersync_producers_self[4]->prodItem = producerconsumersync_producers_initial_prodItem_4;
    static int producerconsumersync_producers_initial_itemsProduced_4 = 0;
    producerconsumersync_producers_self[4]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_4;
    producerconsumersync_producers_self[4]->___next.offset = 0;
    producerconsumersync_producers_self[4]->___next.period = -1;
    producerconsumersync_producers_self[4]->___next.token = __create_token(0);
    producerconsumersync_producers_self[4]->___next.is_present = false;
    __tokens_with_ref_count[4].token
            = &producerconsumersync_producers_self[4]->___next.token;
    __tokens_with_ref_count[4].is_present
            = &producerconsumersync_producers_self[4]->___next.is_present;
    __tokens_with_ref_count[4].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[4]
    // ************* Instance ProducerConsumerSync.producers[5] of class Producer
    producerconsumersync_producers_self[5] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[5]
    producerconsumersync_producers_self[5]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[5]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[5]->__data__width = -2;
    __startup_reactions[6] = &producerconsumersync_producers_self[5]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_5 = 0.0;
    producerconsumersync_producers_self[5]->prodItem = producerconsumersync_producers_initial_prodItem_5;
    static int producerconsumersync_producers_initial_itemsProduced_5 = 0;
    producerconsumersync_producers_self[5]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_5;
    producerconsumersync_producers_self[5]->___next.offset = 0;
    producerconsumersync_producers_self[5]->___next.period = -1;
    producerconsumersync_producers_self[5]->___next.token = __create_token(0);
    producerconsumersync_producers_self[5]->___next.is_present = false;
    __tokens_with_ref_count[5].token
            = &producerconsumersync_producers_self[5]->___next.token;
    __tokens_with_ref_count[5].is_present
            = &producerconsumersync_producers_self[5]->___next.is_present;
    __tokens_with_ref_count[5].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[5]
    // ************* Instance ProducerConsumerSync.producers[6] of class Producer
    producerconsumersync_producers_self[6] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[6]
    producerconsumersync_producers_self[6]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[6]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[6]->__data__width = -2;
    __startup_reactions[7] = &producerconsumersync_producers_self[6]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_6 = 0.0;
    producerconsumersync_producers_self[6]->prodItem = producerconsumersync_producers_initial_prodItem_6;
    static int producerconsumersync_producers_initial_itemsProduced_6 = 0;
    producerconsumersync_producers_self[6]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_6;
    producerconsumersync_producers_self[6]->___next.offset = 0;
    producerconsumersync_producers_self[6]->___next.period = -1;
    producerconsumersync_producers_self[6]->___next.token = __create_token(0);
    producerconsumersync_producers_self[6]->___next.is_present = false;
    __tokens_with_ref_count[6].token
            = &producerconsumersync_producers_self[6]->___next.token;
    __tokens_with_ref_count[6].is_present
            = &producerconsumersync_producers_self[6]->___next.is_present;
    __tokens_with_ref_count[6].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[6]
    // ************* Instance ProducerConsumerSync.producers[7] of class Producer
    producerconsumersync_producers_self[7] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[7]
    producerconsumersync_producers_self[7]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[7]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[7]->__data__width = -2;
    __startup_reactions[8] = &producerconsumersync_producers_self[7]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_7 = 0.0;
    producerconsumersync_producers_self[7]->prodItem = producerconsumersync_producers_initial_prodItem_7;
    static int producerconsumersync_producers_initial_itemsProduced_7 = 0;
    producerconsumersync_producers_self[7]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_7;
    producerconsumersync_producers_self[7]->___next.offset = 0;
    producerconsumersync_producers_self[7]->___next.period = -1;
    producerconsumersync_producers_self[7]->___next.token = __create_token(0);
    producerconsumersync_producers_self[7]->___next.is_present = false;
    __tokens_with_ref_count[7].token
            = &producerconsumersync_producers_self[7]->___next.token;
    __tokens_with_ref_count[7].is_present
            = &producerconsumersync_producers_self[7]->___next.is_present;
    __tokens_with_ref_count[7].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[7]
    // ************* Instance ProducerConsumerSync.producers[8] of class Producer
    producerconsumersync_producers_self[8] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[8]
    producerconsumersync_producers_self[8]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[8]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[8]->__data__width = -2;
    __startup_reactions[9] = &producerconsumersync_producers_self[8]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_8 = 0.0;
    producerconsumersync_producers_self[8]->prodItem = producerconsumersync_producers_initial_prodItem_8;
    static int producerconsumersync_producers_initial_itemsProduced_8 = 0;
    producerconsumersync_producers_self[8]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_8;
    producerconsumersync_producers_self[8]->___next.offset = 0;
    producerconsumersync_producers_self[8]->___next.period = -1;
    producerconsumersync_producers_self[8]->___next.token = __create_token(0);
    producerconsumersync_producers_self[8]->___next.is_present = false;
    __tokens_with_ref_count[8].token
            = &producerconsumersync_producers_self[8]->___next.token;
    __tokens_with_ref_count[8].is_present
            = &producerconsumersync_producers_self[8]->___next.is_present;
    __tokens_with_ref_count[8].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[8]
    // ************* Instance ProducerConsumerSync.producers[9] of class Producer
    producerconsumersync_producers_self[9] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[9]
    producerconsumersync_producers_self[9]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[9]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[9]->__data__width = -2;
    __startup_reactions[10] = &producerconsumersync_producers_self[9]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_9 = 0.0;
    producerconsumersync_producers_self[9]->prodItem = producerconsumersync_producers_initial_prodItem_9;
    static int producerconsumersync_producers_initial_itemsProduced_9 = 0;
    producerconsumersync_producers_self[9]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_9;
    producerconsumersync_producers_self[9]->___next.offset = 0;
    producerconsumersync_producers_self[9]->___next.period = -1;
    producerconsumersync_producers_self[9]->___next.token = __create_token(0);
    producerconsumersync_producers_self[9]->___next.is_present = false;
    __tokens_with_ref_count[9].token
            = &producerconsumersync_producers_self[9]->___next.token;
    __tokens_with_ref_count[9].is_present
            = &producerconsumersync_producers_self[9]->___next.is_present;
    __tokens_with_ref_count[9].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[9]
    // ************* Instance ProducerConsumerSync.producers[10] of class Producer
    producerconsumersync_producers_self[10] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[10]
    producerconsumersync_producers_self[10]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[10]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[10]->__data__width = -2;
    __startup_reactions[11] = &producerconsumersync_producers_self[10]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_10 = 0.0;
    producerconsumersync_producers_self[10]->prodItem = producerconsumersync_producers_initial_prodItem_10;
    static int producerconsumersync_producers_initial_itemsProduced_10 = 0;
    producerconsumersync_producers_self[10]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_10;
    producerconsumersync_producers_self[10]->___next.offset = 0;
    producerconsumersync_producers_self[10]->___next.period = -1;
    producerconsumersync_producers_self[10]->___next.token = __create_token(0);
    producerconsumersync_producers_self[10]->___next.is_present = false;
    __tokens_with_ref_count[10].token
            = &producerconsumersync_producers_self[10]->___next.token;
    __tokens_with_ref_count[10].is_present
            = &producerconsumersync_producers_self[10]->___next.is_present;
    __tokens_with_ref_count[10].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[10]
    // ************* Instance ProducerConsumerSync.producers[11] of class Producer
    producerconsumersync_producers_self[11] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[11]
    producerconsumersync_producers_self[11]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[11]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[11]->__data__width = -2;
    __startup_reactions[12] = &producerconsumersync_producers_self[11]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_11 = 0.0;
    producerconsumersync_producers_self[11]->prodItem = producerconsumersync_producers_initial_prodItem_11;
    static int producerconsumersync_producers_initial_itemsProduced_11 = 0;
    producerconsumersync_producers_self[11]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_11;
    producerconsumersync_producers_self[11]->___next.offset = 0;
    producerconsumersync_producers_self[11]->___next.period = -1;
    producerconsumersync_producers_self[11]->___next.token = __create_token(0);
    producerconsumersync_producers_self[11]->___next.is_present = false;
    __tokens_with_ref_count[11].token
            = &producerconsumersync_producers_self[11]->___next.token;
    __tokens_with_ref_count[11].is_present
            = &producerconsumersync_producers_self[11]->___next.is_present;
    __tokens_with_ref_count[11].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[11]
    // ************* Instance ProducerConsumerSync.producers[12] of class Producer
    producerconsumersync_producers_self[12] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[12]
    producerconsumersync_producers_self[12]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[12]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[12]->__data__width = -2;
    __startup_reactions[13] = &producerconsumersync_producers_self[12]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_12 = 0.0;
    producerconsumersync_producers_self[12]->prodItem = producerconsumersync_producers_initial_prodItem_12;
    static int producerconsumersync_producers_initial_itemsProduced_12 = 0;
    producerconsumersync_producers_self[12]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_12;
    producerconsumersync_producers_self[12]->___next.offset = 0;
    producerconsumersync_producers_self[12]->___next.period = -1;
    producerconsumersync_producers_self[12]->___next.token = __create_token(0);
    producerconsumersync_producers_self[12]->___next.is_present = false;
    __tokens_with_ref_count[12].token
            = &producerconsumersync_producers_self[12]->___next.token;
    __tokens_with_ref_count[12].is_present
            = &producerconsumersync_producers_self[12]->___next.is_present;
    __tokens_with_ref_count[12].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[12]
    // ************* Instance ProducerConsumerSync.producers[13] of class Producer
    producerconsumersync_producers_self[13] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[13]
    producerconsumersync_producers_self[13]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[13]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[13]->__data__width = -2;
    __startup_reactions[14] = &producerconsumersync_producers_self[13]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_13 = 0.0;
    producerconsumersync_producers_self[13]->prodItem = producerconsumersync_producers_initial_prodItem_13;
    static int producerconsumersync_producers_initial_itemsProduced_13 = 0;
    producerconsumersync_producers_self[13]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_13;
    producerconsumersync_producers_self[13]->___next.offset = 0;
    producerconsumersync_producers_self[13]->___next.period = -1;
    producerconsumersync_producers_self[13]->___next.token = __create_token(0);
    producerconsumersync_producers_self[13]->___next.is_present = false;
    __tokens_with_ref_count[13].token
            = &producerconsumersync_producers_self[13]->___next.token;
    __tokens_with_ref_count[13].is_present
            = &producerconsumersync_producers_self[13]->___next.is_present;
    __tokens_with_ref_count[13].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[13]
    // ************* Instance ProducerConsumerSync.producers[14] of class Producer
    producerconsumersync_producers_self[14] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[14]
    producerconsumersync_producers_self[14]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[14]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[14]->__data__width = -2;
    __startup_reactions[15] = &producerconsumersync_producers_self[14]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_14 = 0.0;
    producerconsumersync_producers_self[14]->prodItem = producerconsumersync_producers_initial_prodItem_14;
    static int producerconsumersync_producers_initial_itemsProduced_14 = 0;
    producerconsumersync_producers_self[14]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_14;
    producerconsumersync_producers_self[14]->___next.offset = 0;
    producerconsumersync_producers_self[14]->___next.period = -1;
    producerconsumersync_producers_self[14]->___next.token = __create_token(0);
    producerconsumersync_producers_self[14]->___next.is_present = false;
    __tokens_with_ref_count[14].token
            = &producerconsumersync_producers_self[14]->___next.token;
    __tokens_with_ref_count[14].is_present
            = &producerconsumersync_producers_self[14]->___next.is_present;
    __tokens_with_ref_count[14].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[14]
    // ************* Instance ProducerConsumerSync.producers[15] of class Producer
    producerconsumersync_producers_self[15] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[15]
    producerconsumersync_producers_self[15]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[15]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[15]->__data__width = -2;
    __startup_reactions[16] = &producerconsumersync_producers_self[15]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_15 = 0.0;
    producerconsumersync_producers_self[15]->prodItem = producerconsumersync_producers_initial_prodItem_15;
    static int producerconsumersync_producers_initial_itemsProduced_15 = 0;
    producerconsumersync_producers_self[15]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_15;
    producerconsumersync_producers_self[15]->___next.offset = 0;
    producerconsumersync_producers_self[15]->___next.period = -1;
    producerconsumersync_producers_self[15]->___next.token = __create_token(0);
    producerconsumersync_producers_self[15]->___next.is_present = false;
    __tokens_with_ref_count[15].token
            = &producerconsumersync_producers_self[15]->___next.token;
    __tokens_with_ref_count[15].is_present
            = &producerconsumersync_producers_self[15]->___next.is_present;
    __tokens_with_ref_count[15].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[15]
    // ************* Instance ProducerConsumerSync.producers[16] of class Producer
    producerconsumersync_producers_self[16] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[16]
    producerconsumersync_producers_self[16]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[16]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[16]->__data__width = -2;
    __startup_reactions[17] = &producerconsumersync_producers_self[16]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_16 = 0.0;
    producerconsumersync_producers_self[16]->prodItem = producerconsumersync_producers_initial_prodItem_16;
    static int producerconsumersync_producers_initial_itemsProduced_16 = 0;
    producerconsumersync_producers_self[16]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_16;
    producerconsumersync_producers_self[16]->___next.offset = 0;
    producerconsumersync_producers_self[16]->___next.period = -1;
    producerconsumersync_producers_self[16]->___next.token = __create_token(0);
    producerconsumersync_producers_self[16]->___next.is_present = false;
    __tokens_with_ref_count[16].token
            = &producerconsumersync_producers_self[16]->___next.token;
    __tokens_with_ref_count[16].is_present
            = &producerconsumersync_producers_self[16]->___next.is_present;
    __tokens_with_ref_count[16].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[16]
    // ************* Instance ProducerConsumerSync.producers[17] of class Producer
    producerconsumersync_producers_self[17] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[17]
    producerconsumersync_producers_self[17]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[17]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[17]->__data__width = -2;
    __startup_reactions[18] = &producerconsumersync_producers_self[17]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_17 = 0.0;
    producerconsumersync_producers_self[17]->prodItem = producerconsumersync_producers_initial_prodItem_17;
    static int producerconsumersync_producers_initial_itemsProduced_17 = 0;
    producerconsumersync_producers_self[17]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_17;
    producerconsumersync_producers_self[17]->___next.offset = 0;
    producerconsumersync_producers_self[17]->___next.period = -1;
    producerconsumersync_producers_self[17]->___next.token = __create_token(0);
    producerconsumersync_producers_self[17]->___next.is_present = false;
    __tokens_with_ref_count[17].token
            = &producerconsumersync_producers_self[17]->___next.token;
    __tokens_with_ref_count[17].is_present
            = &producerconsumersync_producers_self[17]->___next.is_present;
    __tokens_with_ref_count[17].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[17]
    // ************* Instance ProducerConsumerSync.producers[18] of class Producer
    producerconsumersync_producers_self[18] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[18]
    producerconsumersync_producers_self[18]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[18]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[18]->__data__width = -2;
    __startup_reactions[19] = &producerconsumersync_producers_self[18]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_18 = 0.0;
    producerconsumersync_producers_self[18]->prodItem = producerconsumersync_producers_initial_prodItem_18;
    static int producerconsumersync_producers_initial_itemsProduced_18 = 0;
    producerconsumersync_producers_self[18]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_18;
    producerconsumersync_producers_self[18]->___next.offset = 0;
    producerconsumersync_producers_self[18]->___next.period = -1;
    producerconsumersync_producers_self[18]->___next.token = __create_token(0);
    producerconsumersync_producers_self[18]->___next.is_present = false;
    __tokens_with_ref_count[18].token
            = &producerconsumersync_producers_self[18]->___next.token;
    __tokens_with_ref_count[18].is_present
            = &producerconsumersync_producers_self[18]->___next.is_present;
    __tokens_with_ref_count[18].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[18]
    // ************* Instance ProducerConsumerSync.producers[19] of class Producer
    producerconsumersync_producers_self[19] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[19]
    producerconsumersync_producers_self[19]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[19]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[19]->__data__width = -2;
    __startup_reactions[20] = &producerconsumersync_producers_self[19]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_19 = 0.0;
    producerconsumersync_producers_self[19]->prodItem = producerconsumersync_producers_initial_prodItem_19;
    static int producerconsumersync_producers_initial_itemsProduced_19 = 0;
    producerconsumersync_producers_self[19]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_19;
    producerconsumersync_producers_self[19]->___next.offset = 0;
    producerconsumersync_producers_self[19]->___next.period = -1;
    producerconsumersync_producers_self[19]->___next.token = __create_token(0);
    producerconsumersync_producers_self[19]->___next.is_present = false;
    __tokens_with_ref_count[19].token
            = &producerconsumersync_producers_self[19]->___next.token;
    __tokens_with_ref_count[19].is_present
            = &producerconsumersync_producers_self[19]->___next.is_present;
    __tokens_with_ref_count[19].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[19]
    // ************* Instance ProducerConsumerSync.producers[20] of class Producer
    producerconsumersync_producers_self[20] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[20]
    producerconsumersync_producers_self[20]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[20]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[20]->__data__width = -2;
    __startup_reactions[21] = &producerconsumersync_producers_self[20]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_20 = 0.0;
    producerconsumersync_producers_self[20]->prodItem = producerconsumersync_producers_initial_prodItem_20;
    static int producerconsumersync_producers_initial_itemsProduced_20 = 0;
    producerconsumersync_producers_self[20]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_20;
    producerconsumersync_producers_self[20]->___next.offset = 0;
    producerconsumersync_producers_self[20]->___next.period = -1;
    producerconsumersync_producers_self[20]->___next.token = __create_token(0);
    producerconsumersync_producers_self[20]->___next.is_present = false;
    __tokens_with_ref_count[20].token
            = &producerconsumersync_producers_self[20]->___next.token;
    __tokens_with_ref_count[20].is_present
            = &producerconsumersync_producers_self[20]->___next.is_present;
    __tokens_with_ref_count[20].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[20]
    // ************* Instance ProducerConsumerSync.producers[21] of class Producer
    producerconsumersync_producers_self[21] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[21]
    producerconsumersync_producers_self[21]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[21]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[21]->__data__width = -2;
    __startup_reactions[22] = &producerconsumersync_producers_self[21]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_21 = 0.0;
    producerconsumersync_producers_self[21]->prodItem = producerconsumersync_producers_initial_prodItem_21;
    static int producerconsumersync_producers_initial_itemsProduced_21 = 0;
    producerconsumersync_producers_self[21]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_21;
    producerconsumersync_producers_self[21]->___next.offset = 0;
    producerconsumersync_producers_self[21]->___next.period = -1;
    producerconsumersync_producers_self[21]->___next.token = __create_token(0);
    producerconsumersync_producers_self[21]->___next.is_present = false;
    __tokens_with_ref_count[21].token
            = &producerconsumersync_producers_self[21]->___next.token;
    __tokens_with_ref_count[21].is_present
            = &producerconsumersync_producers_self[21]->___next.is_present;
    __tokens_with_ref_count[21].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[21]
    // ************* Instance ProducerConsumerSync.producers[22] of class Producer
    producerconsumersync_producers_self[22] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[22]
    producerconsumersync_producers_self[22]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[22]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[22]->__data__width = -2;
    __startup_reactions[23] = &producerconsumersync_producers_self[22]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_22 = 0.0;
    producerconsumersync_producers_self[22]->prodItem = producerconsumersync_producers_initial_prodItem_22;
    static int producerconsumersync_producers_initial_itemsProduced_22 = 0;
    producerconsumersync_producers_self[22]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_22;
    producerconsumersync_producers_self[22]->___next.offset = 0;
    producerconsumersync_producers_self[22]->___next.period = -1;
    producerconsumersync_producers_self[22]->___next.token = __create_token(0);
    producerconsumersync_producers_self[22]->___next.is_present = false;
    __tokens_with_ref_count[22].token
            = &producerconsumersync_producers_self[22]->___next.token;
    __tokens_with_ref_count[22].is_present
            = &producerconsumersync_producers_self[22]->___next.is_present;
    __tokens_with_ref_count[22].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[22]
    // ************* Instance ProducerConsumerSync.producers[23] of class Producer
    producerconsumersync_producers_self[23] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[23]
    producerconsumersync_producers_self[23]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[23]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[23]->__data__width = -2;
    __startup_reactions[24] = &producerconsumersync_producers_self[23]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_23 = 0.0;
    producerconsumersync_producers_self[23]->prodItem = producerconsumersync_producers_initial_prodItem_23;
    static int producerconsumersync_producers_initial_itemsProduced_23 = 0;
    producerconsumersync_producers_self[23]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_23;
    producerconsumersync_producers_self[23]->___next.offset = 0;
    producerconsumersync_producers_self[23]->___next.period = -1;
    producerconsumersync_producers_self[23]->___next.token = __create_token(0);
    producerconsumersync_producers_self[23]->___next.is_present = false;
    __tokens_with_ref_count[23].token
            = &producerconsumersync_producers_self[23]->___next.token;
    __tokens_with_ref_count[23].is_present
            = &producerconsumersync_producers_self[23]->___next.is_present;
    __tokens_with_ref_count[23].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[23]
    // ************* Instance ProducerConsumerSync.producers[24] of class Producer
    producerconsumersync_producers_self[24] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[24]
    producerconsumersync_producers_self[24]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[24]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[24]->__data__width = -2;
    __startup_reactions[25] = &producerconsumersync_producers_self[24]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_24 = 0.0;
    producerconsumersync_producers_self[24]->prodItem = producerconsumersync_producers_initial_prodItem_24;
    static int producerconsumersync_producers_initial_itemsProduced_24 = 0;
    producerconsumersync_producers_self[24]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_24;
    producerconsumersync_producers_self[24]->___next.offset = 0;
    producerconsumersync_producers_self[24]->___next.period = -1;
    producerconsumersync_producers_self[24]->___next.token = __create_token(0);
    producerconsumersync_producers_self[24]->___next.is_present = false;
    __tokens_with_ref_count[24].token
            = &producerconsumersync_producers_self[24]->___next.token;
    __tokens_with_ref_count[24].is_present
            = &producerconsumersync_producers_self[24]->___next.is_present;
    __tokens_with_ref_count[24].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[24]
    // ************* Instance ProducerConsumerSync.producers[25] of class Producer
    producerconsumersync_producers_self[25] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[25]
    producerconsumersync_producers_self[25]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[25]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[25]->__data__width = -2;
    __startup_reactions[26] = &producerconsumersync_producers_self[25]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_25 = 0.0;
    producerconsumersync_producers_self[25]->prodItem = producerconsumersync_producers_initial_prodItem_25;
    static int producerconsumersync_producers_initial_itemsProduced_25 = 0;
    producerconsumersync_producers_self[25]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_25;
    producerconsumersync_producers_self[25]->___next.offset = 0;
    producerconsumersync_producers_self[25]->___next.period = -1;
    producerconsumersync_producers_self[25]->___next.token = __create_token(0);
    producerconsumersync_producers_self[25]->___next.is_present = false;
    __tokens_with_ref_count[25].token
            = &producerconsumersync_producers_self[25]->___next.token;
    __tokens_with_ref_count[25].is_present
            = &producerconsumersync_producers_self[25]->___next.is_present;
    __tokens_with_ref_count[25].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[25]
    // ************* Instance ProducerConsumerSync.producers[26] of class Producer
    producerconsumersync_producers_self[26] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[26]
    producerconsumersync_producers_self[26]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[26]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[26]->__data__width = -2;
    __startup_reactions[27] = &producerconsumersync_producers_self[26]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_26 = 0.0;
    producerconsumersync_producers_self[26]->prodItem = producerconsumersync_producers_initial_prodItem_26;
    static int producerconsumersync_producers_initial_itemsProduced_26 = 0;
    producerconsumersync_producers_self[26]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_26;
    producerconsumersync_producers_self[26]->___next.offset = 0;
    producerconsumersync_producers_self[26]->___next.period = -1;
    producerconsumersync_producers_self[26]->___next.token = __create_token(0);
    producerconsumersync_producers_self[26]->___next.is_present = false;
    __tokens_with_ref_count[26].token
            = &producerconsumersync_producers_self[26]->___next.token;
    __tokens_with_ref_count[26].is_present
            = &producerconsumersync_producers_self[26]->___next.is_present;
    __tokens_with_ref_count[26].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[26]
    // ************* Instance ProducerConsumerSync.producers[27] of class Producer
    producerconsumersync_producers_self[27] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[27]
    producerconsumersync_producers_self[27]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[27]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[27]->__data__width = -2;
    __startup_reactions[28] = &producerconsumersync_producers_self[27]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_27 = 0.0;
    producerconsumersync_producers_self[27]->prodItem = producerconsumersync_producers_initial_prodItem_27;
    static int producerconsumersync_producers_initial_itemsProduced_27 = 0;
    producerconsumersync_producers_self[27]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_27;
    producerconsumersync_producers_self[27]->___next.offset = 0;
    producerconsumersync_producers_self[27]->___next.period = -1;
    producerconsumersync_producers_self[27]->___next.token = __create_token(0);
    producerconsumersync_producers_self[27]->___next.is_present = false;
    __tokens_with_ref_count[27].token
            = &producerconsumersync_producers_self[27]->___next.token;
    __tokens_with_ref_count[27].is_present
            = &producerconsumersync_producers_self[27]->___next.is_present;
    __tokens_with_ref_count[27].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[27]
    // ************* Instance ProducerConsumerSync.producers[28] of class Producer
    producerconsumersync_producers_self[28] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[28]
    producerconsumersync_producers_self[28]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[28]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[28]->__data__width = -2;
    __startup_reactions[29] = &producerconsumersync_producers_self[28]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_28 = 0.0;
    producerconsumersync_producers_self[28]->prodItem = producerconsumersync_producers_initial_prodItem_28;
    static int producerconsumersync_producers_initial_itemsProduced_28 = 0;
    producerconsumersync_producers_self[28]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_28;
    producerconsumersync_producers_self[28]->___next.offset = 0;
    producerconsumersync_producers_self[28]->___next.period = -1;
    producerconsumersync_producers_self[28]->___next.token = __create_token(0);
    producerconsumersync_producers_self[28]->___next.is_present = false;
    __tokens_with_ref_count[28].token
            = &producerconsumersync_producers_self[28]->___next.token;
    __tokens_with_ref_count[28].is_present
            = &producerconsumersync_producers_self[28]->___next.is_present;
    __tokens_with_ref_count[28].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[28]
    // ************* Instance ProducerConsumerSync.producers[29] of class Producer
    producerconsumersync_producers_self[29] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[29]
    producerconsumersync_producers_self[29]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[29]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[29]->__data__width = -2;
    __startup_reactions[30] = &producerconsumersync_producers_self[29]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_29 = 0.0;
    producerconsumersync_producers_self[29]->prodItem = producerconsumersync_producers_initial_prodItem_29;
    static int producerconsumersync_producers_initial_itemsProduced_29 = 0;
    producerconsumersync_producers_self[29]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_29;
    producerconsumersync_producers_self[29]->___next.offset = 0;
    producerconsumersync_producers_self[29]->___next.period = -1;
    producerconsumersync_producers_self[29]->___next.token = __create_token(0);
    producerconsumersync_producers_self[29]->___next.is_present = false;
    __tokens_with_ref_count[29].token
            = &producerconsumersync_producers_self[29]->___next.token;
    __tokens_with_ref_count[29].is_present
            = &producerconsumersync_producers_self[29]->___next.is_present;
    __tokens_with_ref_count[29].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[29]
    // ************* Instance ProducerConsumerSync.producers[30] of class Producer
    producerconsumersync_producers_self[30] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[30]
    producerconsumersync_producers_self[30]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[30]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[30]->__data__width = -2;
    __startup_reactions[31] = &producerconsumersync_producers_self[30]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_30 = 0.0;
    producerconsumersync_producers_self[30]->prodItem = producerconsumersync_producers_initial_prodItem_30;
    static int producerconsumersync_producers_initial_itemsProduced_30 = 0;
    producerconsumersync_producers_self[30]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_30;
    producerconsumersync_producers_self[30]->___next.offset = 0;
    producerconsumersync_producers_self[30]->___next.period = -1;
    producerconsumersync_producers_self[30]->___next.token = __create_token(0);
    producerconsumersync_producers_self[30]->___next.is_present = false;
    __tokens_with_ref_count[30].token
            = &producerconsumersync_producers_self[30]->___next.token;
    __tokens_with_ref_count[30].is_present
            = &producerconsumersync_producers_self[30]->___next.is_present;
    __tokens_with_ref_count[30].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[30]
    // ************* Instance ProducerConsumerSync.producers[31] of class Producer
    producerconsumersync_producers_self[31] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[31]
    producerconsumersync_producers_self[31]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[31]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[31]->__data__width = -2;
    __startup_reactions[32] = &producerconsumersync_producers_self[31]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_31 = 0.0;
    producerconsumersync_producers_self[31]->prodItem = producerconsumersync_producers_initial_prodItem_31;
    static int producerconsumersync_producers_initial_itemsProduced_31 = 0;
    producerconsumersync_producers_self[31]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_31;
    producerconsumersync_producers_self[31]->___next.offset = 0;
    producerconsumersync_producers_self[31]->___next.period = -1;
    producerconsumersync_producers_self[31]->___next.token = __create_token(0);
    producerconsumersync_producers_self[31]->___next.is_present = false;
    __tokens_with_ref_count[31].token
            = &producerconsumersync_producers_self[31]->___next.token;
    __tokens_with_ref_count[31].is_present
            = &producerconsumersync_producers_self[31]->___next.is_present;
    __tokens_with_ref_count[31].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[31]
    // ************* Instance ProducerConsumerSync.producers[32] of class Producer
    producerconsumersync_producers_self[32] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[32]
    producerconsumersync_producers_self[32]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[32]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[32]->__data__width = -2;
    __startup_reactions[33] = &producerconsumersync_producers_self[32]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_32 = 0.0;
    producerconsumersync_producers_self[32]->prodItem = producerconsumersync_producers_initial_prodItem_32;
    static int producerconsumersync_producers_initial_itemsProduced_32 = 0;
    producerconsumersync_producers_self[32]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_32;
    producerconsumersync_producers_self[32]->___next.offset = 0;
    producerconsumersync_producers_self[32]->___next.period = -1;
    producerconsumersync_producers_self[32]->___next.token = __create_token(0);
    producerconsumersync_producers_self[32]->___next.is_present = false;
    __tokens_with_ref_count[32].token
            = &producerconsumersync_producers_self[32]->___next.token;
    __tokens_with_ref_count[32].is_present
            = &producerconsumersync_producers_self[32]->___next.is_present;
    __tokens_with_ref_count[32].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[32]
    // ************* Instance ProducerConsumerSync.producers[33] of class Producer
    producerconsumersync_producers_self[33] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[33]
    producerconsumersync_producers_self[33]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[33]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[33]->__data__width = -2;
    __startup_reactions[34] = &producerconsumersync_producers_self[33]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_33 = 0.0;
    producerconsumersync_producers_self[33]->prodItem = producerconsumersync_producers_initial_prodItem_33;
    static int producerconsumersync_producers_initial_itemsProduced_33 = 0;
    producerconsumersync_producers_self[33]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_33;
    producerconsumersync_producers_self[33]->___next.offset = 0;
    producerconsumersync_producers_self[33]->___next.period = -1;
    producerconsumersync_producers_self[33]->___next.token = __create_token(0);
    producerconsumersync_producers_self[33]->___next.is_present = false;
    __tokens_with_ref_count[33].token
            = &producerconsumersync_producers_self[33]->___next.token;
    __tokens_with_ref_count[33].is_present
            = &producerconsumersync_producers_self[33]->___next.is_present;
    __tokens_with_ref_count[33].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[33]
    // ************* Instance ProducerConsumerSync.producers[34] of class Producer
    producerconsumersync_producers_self[34] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[34]
    producerconsumersync_producers_self[34]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[34]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[34]->__data__width = -2;
    __startup_reactions[35] = &producerconsumersync_producers_self[34]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_34 = 0.0;
    producerconsumersync_producers_self[34]->prodItem = producerconsumersync_producers_initial_prodItem_34;
    static int producerconsumersync_producers_initial_itemsProduced_34 = 0;
    producerconsumersync_producers_self[34]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_34;
    producerconsumersync_producers_self[34]->___next.offset = 0;
    producerconsumersync_producers_self[34]->___next.period = -1;
    producerconsumersync_producers_self[34]->___next.token = __create_token(0);
    producerconsumersync_producers_self[34]->___next.is_present = false;
    __tokens_with_ref_count[34].token
            = &producerconsumersync_producers_self[34]->___next.token;
    __tokens_with_ref_count[34].is_present
            = &producerconsumersync_producers_self[34]->___next.is_present;
    __tokens_with_ref_count[34].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[34]
    // ************* Instance ProducerConsumerSync.producers[35] of class Producer
    producerconsumersync_producers_self[35] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[35]
    producerconsumersync_producers_self[35]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[35]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[35]->__data__width = -2;
    __startup_reactions[36] = &producerconsumersync_producers_self[35]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_35 = 0.0;
    producerconsumersync_producers_self[35]->prodItem = producerconsumersync_producers_initial_prodItem_35;
    static int producerconsumersync_producers_initial_itemsProduced_35 = 0;
    producerconsumersync_producers_self[35]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_35;
    producerconsumersync_producers_self[35]->___next.offset = 0;
    producerconsumersync_producers_self[35]->___next.period = -1;
    producerconsumersync_producers_self[35]->___next.token = __create_token(0);
    producerconsumersync_producers_self[35]->___next.is_present = false;
    __tokens_with_ref_count[35].token
            = &producerconsumersync_producers_self[35]->___next.token;
    __tokens_with_ref_count[35].is_present
            = &producerconsumersync_producers_self[35]->___next.is_present;
    __tokens_with_ref_count[35].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[35]
    // ************* Instance ProducerConsumerSync.producers[36] of class Producer
    producerconsumersync_producers_self[36] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[36]
    producerconsumersync_producers_self[36]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[36]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[36]->__data__width = -2;
    __startup_reactions[37] = &producerconsumersync_producers_self[36]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_36 = 0.0;
    producerconsumersync_producers_self[36]->prodItem = producerconsumersync_producers_initial_prodItem_36;
    static int producerconsumersync_producers_initial_itemsProduced_36 = 0;
    producerconsumersync_producers_self[36]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_36;
    producerconsumersync_producers_self[36]->___next.offset = 0;
    producerconsumersync_producers_self[36]->___next.period = -1;
    producerconsumersync_producers_self[36]->___next.token = __create_token(0);
    producerconsumersync_producers_self[36]->___next.is_present = false;
    __tokens_with_ref_count[36].token
            = &producerconsumersync_producers_self[36]->___next.token;
    __tokens_with_ref_count[36].is_present
            = &producerconsumersync_producers_self[36]->___next.is_present;
    __tokens_with_ref_count[36].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[36]
    // ************* Instance ProducerConsumerSync.producers[37] of class Producer
    producerconsumersync_producers_self[37] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[37]
    producerconsumersync_producers_self[37]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[37]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[37]->__data__width = -2;
    __startup_reactions[38] = &producerconsumersync_producers_self[37]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_37 = 0.0;
    producerconsumersync_producers_self[37]->prodItem = producerconsumersync_producers_initial_prodItem_37;
    static int producerconsumersync_producers_initial_itemsProduced_37 = 0;
    producerconsumersync_producers_self[37]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_37;
    producerconsumersync_producers_self[37]->___next.offset = 0;
    producerconsumersync_producers_self[37]->___next.period = -1;
    producerconsumersync_producers_self[37]->___next.token = __create_token(0);
    producerconsumersync_producers_self[37]->___next.is_present = false;
    __tokens_with_ref_count[37].token
            = &producerconsumersync_producers_self[37]->___next.token;
    __tokens_with_ref_count[37].is_present
            = &producerconsumersync_producers_self[37]->___next.is_present;
    __tokens_with_ref_count[37].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[37]
    // ************* Instance ProducerConsumerSync.producers[38] of class Producer
    producerconsumersync_producers_self[38] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[38]
    producerconsumersync_producers_self[38]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[38]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[38]->__data__width = -2;
    __startup_reactions[39] = &producerconsumersync_producers_self[38]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_38 = 0.0;
    producerconsumersync_producers_self[38]->prodItem = producerconsumersync_producers_initial_prodItem_38;
    static int producerconsumersync_producers_initial_itemsProduced_38 = 0;
    producerconsumersync_producers_self[38]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_38;
    producerconsumersync_producers_self[38]->___next.offset = 0;
    producerconsumersync_producers_self[38]->___next.period = -1;
    producerconsumersync_producers_self[38]->___next.token = __create_token(0);
    producerconsumersync_producers_self[38]->___next.is_present = false;
    __tokens_with_ref_count[38].token
            = &producerconsumersync_producers_self[38]->___next.token;
    __tokens_with_ref_count[38].is_present
            = &producerconsumersync_producers_self[38]->___next.is_present;
    __tokens_with_ref_count[38].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[38]
    // ************* Instance ProducerConsumerSync.producers[39] of class Producer
    producerconsumersync_producers_self[39] = new_Producer();
    //***** Start initializing ProducerConsumerSync.producers[39]
    producerconsumersync_producers_self[39]->numItemsToProduce = 1000; 
    producerconsumersync_producers_self[39]->prodCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_producers_self[39]->__data__width = -2;
    __startup_reactions[40] = &producerconsumersync_producers_self[39]->___reaction_0;
    static double producerconsumersync_producers_initial_prodItem_39 = 0.0;
    producerconsumersync_producers_self[39]->prodItem = producerconsumersync_producers_initial_prodItem_39;
    static int producerconsumersync_producers_initial_itemsProduced_39 = 0;
    producerconsumersync_producers_self[39]->itemsProduced = producerconsumersync_producers_initial_itemsProduced_39;
    producerconsumersync_producers_self[39]->___next.offset = 0;
    producerconsumersync_producers_self[39]->___next.period = -1;
    producerconsumersync_producers_self[39]->___next.token = __create_token(0);
    producerconsumersync_producers_self[39]->___next.is_present = false;
    __tokens_with_ref_count[39].token
            = &producerconsumersync_producers_self[39]->___next.token;
    __tokens_with_ref_count[39].is_present
            = &producerconsumersync_producers_self[39]->___next.is_present;
    __tokens_with_ref_count[39].reset_is_present = true;
    //***** End initializing ProducerConsumerSync.producers[39]
    // ************* Instance ProducerConsumerSync.consumers of class Consumer
    consumer_self_t* producerconsumersync_consumers_self[40];
    // ************* Instance ProducerConsumerSync.consumers[0] of class Consumer
    producerconsumersync_consumers_self[0] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[0]
    producerconsumersync_consumers_self[0]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[0]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[0]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_0 = 0.0;
    producerconsumersync_consumers_self[0]->consItem = producerconsumersync_consumers_initial_consItem_0;
    static int producerconsumersync_consumers_initial_itemsConsumed_0 = 0;
    producerconsumersync_consumers_self[0]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_0;
    //***** End initializing ProducerConsumerSync.consumers[0]
    // ************* Instance ProducerConsumerSync.consumers[1] of class Consumer
    producerconsumersync_consumers_self[1] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[1]
    producerconsumersync_consumers_self[1]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[1]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[1]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_1 = 0.0;
    producerconsumersync_consumers_self[1]->consItem = producerconsumersync_consumers_initial_consItem_1;
    static int producerconsumersync_consumers_initial_itemsConsumed_1 = 0;
    producerconsumersync_consumers_self[1]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_1;
    //***** End initializing ProducerConsumerSync.consumers[1]
    // ************* Instance ProducerConsumerSync.consumers[2] of class Consumer
    producerconsumersync_consumers_self[2] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[2]
    producerconsumersync_consumers_self[2]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[2]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[2]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_2 = 0.0;
    producerconsumersync_consumers_self[2]->consItem = producerconsumersync_consumers_initial_consItem_2;
    static int producerconsumersync_consumers_initial_itemsConsumed_2 = 0;
    producerconsumersync_consumers_self[2]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_2;
    //***** End initializing ProducerConsumerSync.consumers[2]
    // ************* Instance ProducerConsumerSync.consumers[3] of class Consumer
    producerconsumersync_consumers_self[3] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[3]
    producerconsumersync_consumers_self[3]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[3]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[3]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_3 = 0.0;
    producerconsumersync_consumers_self[3]->consItem = producerconsumersync_consumers_initial_consItem_3;
    static int producerconsumersync_consumers_initial_itemsConsumed_3 = 0;
    producerconsumersync_consumers_self[3]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_3;
    //***** End initializing ProducerConsumerSync.consumers[3]
    // ************* Instance ProducerConsumerSync.consumers[4] of class Consumer
    producerconsumersync_consumers_self[4] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[4]
    producerconsumersync_consumers_self[4]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[4]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[4]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_4 = 0.0;
    producerconsumersync_consumers_self[4]->consItem = producerconsumersync_consumers_initial_consItem_4;
    static int producerconsumersync_consumers_initial_itemsConsumed_4 = 0;
    producerconsumersync_consumers_self[4]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_4;
    //***** End initializing ProducerConsumerSync.consumers[4]
    // ************* Instance ProducerConsumerSync.consumers[5] of class Consumer
    producerconsumersync_consumers_self[5] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[5]
    producerconsumersync_consumers_self[5]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[5]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[5]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_5 = 0.0;
    producerconsumersync_consumers_self[5]->consItem = producerconsumersync_consumers_initial_consItem_5;
    static int producerconsumersync_consumers_initial_itemsConsumed_5 = 0;
    producerconsumersync_consumers_self[5]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_5;
    //***** End initializing ProducerConsumerSync.consumers[5]
    // ************* Instance ProducerConsumerSync.consumers[6] of class Consumer
    producerconsumersync_consumers_self[6] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[6]
    producerconsumersync_consumers_self[6]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[6]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[6]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_6 = 0.0;
    producerconsumersync_consumers_self[6]->consItem = producerconsumersync_consumers_initial_consItem_6;
    static int producerconsumersync_consumers_initial_itemsConsumed_6 = 0;
    producerconsumersync_consumers_self[6]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_6;
    //***** End initializing ProducerConsumerSync.consumers[6]
    // ************* Instance ProducerConsumerSync.consumers[7] of class Consumer
    producerconsumersync_consumers_self[7] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[7]
    producerconsumersync_consumers_self[7]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[7]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[7]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_7 = 0.0;
    producerconsumersync_consumers_self[7]->consItem = producerconsumersync_consumers_initial_consItem_7;
    static int producerconsumersync_consumers_initial_itemsConsumed_7 = 0;
    producerconsumersync_consumers_self[7]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_7;
    //***** End initializing ProducerConsumerSync.consumers[7]
    // ************* Instance ProducerConsumerSync.consumers[8] of class Consumer
    producerconsumersync_consumers_self[8] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[8]
    producerconsumersync_consumers_self[8]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[8]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[8]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_8 = 0.0;
    producerconsumersync_consumers_self[8]->consItem = producerconsumersync_consumers_initial_consItem_8;
    static int producerconsumersync_consumers_initial_itemsConsumed_8 = 0;
    producerconsumersync_consumers_self[8]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_8;
    //***** End initializing ProducerConsumerSync.consumers[8]
    // ************* Instance ProducerConsumerSync.consumers[9] of class Consumer
    producerconsumersync_consumers_self[9] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[9]
    producerconsumersync_consumers_self[9]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[9]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[9]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_9 = 0.0;
    producerconsumersync_consumers_self[9]->consItem = producerconsumersync_consumers_initial_consItem_9;
    static int producerconsumersync_consumers_initial_itemsConsumed_9 = 0;
    producerconsumersync_consumers_self[9]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_9;
    //***** End initializing ProducerConsumerSync.consumers[9]
    // ************* Instance ProducerConsumerSync.consumers[10] of class Consumer
    producerconsumersync_consumers_self[10] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[10]
    producerconsumersync_consumers_self[10]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[10]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[10]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_10 = 0.0;
    producerconsumersync_consumers_self[10]->consItem = producerconsumersync_consumers_initial_consItem_10;
    static int producerconsumersync_consumers_initial_itemsConsumed_10 = 0;
    producerconsumersync_consumers_self[10]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_10;
    //***** End initializing ProducerConsumerSync.consumers[10]
    // ************* Instance ProducerConsumerSync.consumers[11] of class Consumer
    producerconsumersync_consumers_self[11] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[11]
    producerconsumersync_consumers_self[11]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[11]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[11]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_11 = 0.0;
    producerconsumersync_consumers_self[11]->consItem = producerconsumersync_consumers_initial_consItem_11;
    static int producerconsumersync_consumers_initial_itemsConsumed_11 = 0;
    producerconsumersync_consumers_self[11]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_11;
    //***** End initializing ProducerConsumerSync.consumers[11]
    // ************* Instance ProducerConsumerSync.consumers[12] of class Consumer
    producerconsumersync_consumers_self[12] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[12]
    producerconsumersync_consumers_self[12]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[12]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[12]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_12 = 0.0;
    producerconsumersync_consumers_self[12]->consItem = producerconsumersync_consumers_initial_consItem_12;
    static int producerconsumersync_consumers_initial_itemsConsumed_12 = 0;
    producerconsumersync_consumers_self[12]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_12;
    //***** End initializing ProducerConsumerSync.consumers[12]
    // ************* Instance ProducerConsumerSync.consumers[13] of class Consumer
    producerconsumersync_consumers_self[13] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[13]
    producerconsumersync_consumers_self[13]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[13]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[13]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_13 = 0.0;
    producerconsumersync_consumers_self[13]->consItem = producerconsumersync_consumers_initial_consItem_13;
    static int producerconsumersync_consumers_initial_itemsConsumed_13 = 0;
    producerconsumersync_consumers_self[13]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_13;
    //***** End initializing ProducerConsumerSync.consumers[13]
    // ************* Instance ProducerConsumerSync.consumers[14] of class Consumer
    producerconsumersync_consumers_self[14] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[14]
    producerconsumersync_consumers_self[14]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[14]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[14]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_14 = 0.0;
    producerconsumersync_consumers_self[14]->consItem = producerconsumersync_consumers_initial_consItem_14;
    static int producerconsumersync_consumers_initial_itemsConsumed_14 = 0;
    producerconsumersync_consumers_self[14]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_14;
    //***** End initializing ProducerConsumerSync.consumers[14]
    // ************* Instance ProducerConsumerSync.consumers[15] of class Consumer
    producerconsumersync_consumers_self[15] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[15]
    producerconsumersync_consumers_self[15]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[15]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[15]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_15 = 0.0;
    producerconsumersync_consumers_self[15]->consItem = producerconsumersync_consumers_initial_consItem_15;
    static int producerconsumersync_consumers_initial_itemsConsumed_15 = 0;
    producerconsumersync_consumers_self[15]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_15;
    //***** End initializing ProducerConsumerSync.consumers[15]
    // ************* Instance ProducerConsumerSync.consumers[16] of class Consumer
    producerconsumersync_consumers_self[16] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[16]
    producerconsumersync_consumers_self[16]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[16]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[16]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_16 = 0.0;
    producerconsumersync_consumers_self[16]->consItem = producerconsumersync_consumers_initial_consItem_16;
    static int producerconsumersync_consumers_initial_itemsConsumed_16 = 0;
    producerconsumersync_consumers_self[16]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_16;
    //***** End initializing ProducerConsumerSync.consumers[16]
    // ************* Instance ProducerConsumerSync.consumers[17] of class Consumer
    producerconsumersync_consumers_self[17] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[17]
    producerconsumersync_consumers_self[17]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[17]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[17]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_17 = 0.0;
    producerconsumersync_consumers_self[17]->consItem = producerconsumersync_consumers_initial_consItem_17;
    static int producerconsumersync_consumers_initial_itemsConsumed_17 = 0;
    producerconsumersync_consumers_self[17]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_17;
    //***** End initializing ProducerConsumerSync.consumers[17]
    // ************* Instance ProducerConsumerSync.consumers[18] of class Consumer
    producerconsumersync_consumers_self[18] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[18]
    producerconsumersync_consumers_self[18]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[18]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[18]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_18 = 0.0;
    producerconsumersync_consumers_self[18]->consItem = producerconsumersync_consumers_initial_consItem_18;
    static int producerconsumersync_consumers_initial_itemsConsumed_18 = 0;
    producerconsumersync_consumers_self[18]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_18;
    //***** End initializing ProducerConsumerSync.consumers[18]
    // ************* Instance ProducerConsumerSync.consumers[19] of class Consumer
    producerconsumersync_consumers_self[19] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[19]
    producerconsumersync_consumers_self[19]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[19]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[19]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_19 = 0.0;
    producerconsumersync_consumers_self[19]->consItem = producerconsumersync_consumers_initial_consItem_19;
    static int producerconsumersync_consumers_initial_itemsConsumed_19 = 0;
    producerconsumersync_consumers_self[19]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_19;
    //***** End initializing ProducerConsumerSync.consumers[19]
    // ************* Instance ProducerConsumerSync.consumers[20] of class Consumer
    producerconsumersync_consumers_self[20] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[20]
    producerconsumersync_consumers_self[20]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[20]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[20]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_20 = 0.0;
    producerconsumersync_consumers_self[20]->consItem = producerconsumersync_consumers_initial_consItem_20;
    static int producerconsumersync_consumers_initial_itemsConsumed_20 = 0;
    producerconsumersync_consumers_self[20]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_20;
    //***** End initializing ProducerConsumerSync.consumers[20]
    // ************* Instance ProducerConsumerSync.consumers[21] of class Consumer
    producerconsumersync_consumers_self[21] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[21]
    producerconsumersync_consumers_self[21]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[21]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[21]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_21 = 0.0;
    producerconsumersync_consumers_self[21]->consItem = producerconsumersync_consumers_initial_consItem_21;
    static int producerconsumersync_consumers_initial_itemsConsumed_21 = 0;
    producerconsumersync_consumers_self[21]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_21;
    //***** End initializing ProducerConsumerSync.consumers[21]
    // ************* Instance ProducerConsumerSync.consumers[22] of class Consumer
    producerconsumersync_consumers_self[22] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[22]
    producerconsumersync_consumers_self[22]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[22]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[22]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_22 = 0.0;
    producerconsumersync_consumers_self[22]->consItem = producerconsumersync_consumers_initial_consItem_22;
    static int producerconsumersync_consumers_initial_itemsConsumed_22 = 0;
    producerconsumersync_consumers_self[22]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_22;
    //***** End initializing ProducerConsumerSync.consumers[22]
    // ************* Instance ProducerConsumerSync.consumers[23] of class Consumer
    producerconsumersync_consumers_self[23] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[23]
    producerconsumersync_consumers_self[23]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[23]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[23]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_23 = 0.0;
    producerconsumersync_consumers_self[23]->consItem = producerconsumersync_consumers_initial_consItem_23;
    static int producerconsumersync_consumers_initial_itemsConsumed_23 = 0;
    producerconsumersync_consumers_self[23]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_23;
    //***** End initializing ProducerConsumerSync.consumers[23]
    // ************* Instance ProducerConsumerSync.consumers[24] of class Consumer
    producerconsumersync_consumers_self[24] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[24]
    producerconsumersync_consumers_self[24]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[24]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[24]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_24 = 0.0;
    producerconsumersync_consumers_self[24]->consItem = producerconsumersync_consumers_initial_consItem_24;
    static int producerconsumersync_consumers_initial_itemsConsumed_24 = 0;
    producerconsumersync_consumers_self[24]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_24;
    //***** End initializing ProducerConsumerSync.consumers[24]
    // ************* Instance ProducerConsumerSync.consumers[25] of class Consumer
    producerconsumersync_consumers_self[25] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[25]
    producerconsumersync_consumers_self[25]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[25]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[25]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_25 = 0.0;
    producerconsumersync_consumers_self[25]->consItem = producerconsumersync_consumers_initial_consItem_25;
    static int producerconsumersync_consumers_initial_itemsConsumed_25 = 0;
    producerconsumersync_consumers_self[25]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_25;
    //***** End initializing ProducerConsumerSync.consumers[25]
    // ************* Instance ProducerConsumerSync.consumers[26] of class Consumer
    producerconsumersync_consumers_self[26] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[26]
    producerconsumersync_consumers_self[26]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[26]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[26]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_26 = 0.0;
    producerconsumersync_consumers_self[26]->consItem = producerconsumersync_consumers_initial_consItem_26;
    static int producerconsumersync_consumers_initial_itemsConsumed_26 = 0;
    producerconsumersync_consumers_self[26]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_26;
    //***** End initializing ProducerConsumerSync.consumers[26]
    // ************* Instance ProducerConsumerSync.consumers[27] of class Consumer
    producerconsumersync_consumers_self[27] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[27]
    producerconsumersync_consumers_self[27]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[27]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[27]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_27 = 0.0;
    producerconsumersync_consumers_self[27]->consItem = producerconsumersync_consumers_initial_consItem_27;
    static int producerconsumersync_consumers_initial_itemsConsumed_27 = 0;
    producerconsumersync_consumers_self[27]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_27;
    //***** End initializing ProducerConsumerSync.consumers[27]
    // ************* Instance ProducerConsumerSync.consumers[28] of class Consumer
    producerconsumersync_consumers_self[28] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[28]
    producerconsumersync_consumers_self[28]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[28]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[28]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_28 = 0.0;
    producerconsumersync_consumers_self[28]->consItem = producerconsumersync_consumers_initial_consItem_28;
    static int producerconsumersync_consumers_initial_itemsConsumed_28 = 0;
    producerconsumersync_consumers_self[28]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_28;
    //***** End initializing ProducerConsumerSync.consumers[28]
    // ************* Instance ProducerConsumerSync.consumers[29] of class Consumer
    producerconsumersync_consumers_self[29] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[29]
    producerconsumersync_consumers_self[29]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[29]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[29]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_29 = 0.0;
    producerconsumersync_consumers_self[29]->consItem = producerconsumersync_consumers_initial_consItem_29;
    static int producerconsumersync_consumers_initial_itemsConsumed_29 = 0;
    producerconsumersync_consumers_self[29]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_29;
    //***** End initializing ProducerConsumerSync.consumers[29]
    // ************* Instance ProducerConsumerSync.consumers[30] of class Consumer
    producerconsumersync_consumers_self[30] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[30]
    producerconsumersync_consumers_self[30]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[30]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[30]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_30 = 0.0;
    producerconsumersync_consumers_self[30]->consItem = producerconsumersync_consumers_initial_consItem_30;
    static int producerconsumersync_consumers_initial_itemsConsumed_30 = 0;
    producerconsumersync_consumers_self[30]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_30;
    //***** End initializing ProducerConsumerSync.consumers[30]
    // ************* Instance ProducerConsumerSync.consumers[31] of class Consumer
    producerconsumersync_consumers_self[31] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[31]
    producerconsumersync_consumers_self[31]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[31]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[31]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_31 = 0.0;
    producerconsumersync_consumers_self[31]->consItem = producerconsumersync_consumers_initial_consItem_31;
    static int producerconsumersync_consumers_initial_itemsConsumed_31 = 0;
    producerconsumersync_consumers_self[31]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_31;
    //***** End initializing ProducerConsumerSync.consumers[31]
    // ************* Instance ProducerConsumerSync.consumers[32] of class Consumer
    producerconsumersync_consumers_self[32] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[32]
    producerconsumersync_consumers_self[32]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[32]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[32]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_32 = 0.0;
    producerconsumersync_consumers_self[32]->consItem = producerconsumersync_consumers_initial_consItem_32;
    static int producerconsumersync_consumers_initial_itemsConsumed_32 = 0;
    producerconsumersync_consumers_self[32]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_32;
    //***** End initializing ProducerConsumerSync.consumers[32]
    // ************* Instance ProducerConsumerSync.consumers[33] of class Consumer
    producerconsumersync_consumers_self[33] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[33]
    producerconsumersync_consumers_self[33]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[33]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[33]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_33 = 0.0;
    producerconsumersync_consumers_self[33]->consItem = producerconsumersync_consumers_initial_consItem_33;
    static int producerconsumersync_consumers_initial_itemsConsumed_33 = 0;
    producerconsumersync_consumers_self[33]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_33;
    //***** End initializing ProducerConsumerSync.consumers[33]
    // ************* Instance ProducerConsumerSync.consumers[34] of class Consumer
    producerconsumersync_consumers_self[34] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[34]
    producerconsumersync_consumers_self[34]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[34]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[34]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_34 = 0.0;
    producerconsumersync_consumers_self[34]->consItem = producerconsumersync_consumers_initial_consItem_34;
    static int producerconsumersync_consumers_initial_itemsConsumed_34 = 0;
    producerconsumersync_consumers_self[34]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_34;
    //***** End initializing ProducerConsumerSync.consumers[34]
    // ************* Instance ProducerConsumerSync.consumers[35] of class Consumer
    producerconsumersync_consumers_self[35] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[35]
    producerconsumersync_consumers_self[35]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[35]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[35]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_35 = 0.0;
    producerconsumersync_consumers_self[35]->consItem = producerconsumersync_consumers_initial_consItem_35;
    static int producerconsumersync_consumers_initial_itemsConsumed_35 = 0;
    producerconsumersync_consumers_self[35]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_35;
    //***** End initializing ProducerConsumerSync.consumers[35]
    // ************* Instance ProducerConsumerSync.consumers[36] of class Consumer
    producerconsumersync_consumers_self[36] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[36]
    producerconsumersync_consumers_self[36]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[36]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[36]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_36 = 0.0;
    producerconsumersync_consumers_self[36]->consItem = producerconsumersync_consumers_initial_consItem_36;
    static int producerconsumersync_consumers_initial_itemsConsumed_36 = 0;
    producerconsumersync_consumers_self[36]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_36;
    //***** End initializing ProducerConsumerSync.consumers[36]
    // ************* Instance ProducerConsumerSync.consumers[37] of class Consumer
    producerconsumersync_consumers_self[37] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[37]
    producerconsumersync_consumers_self[37]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[37]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[37]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_37 = 0.0;
    producerconsumersync_consumers_self[37]->consItem = producerconsumersync_consumers_initial_consItem_37;
    static int producerconsumersync_consumers_initial_itemsConsumed_37 = 0;
    producerconsumersync_consumers_self[37]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_37;
    //***** End initializing ProducerConsumerSync.consumers[37]
    // ************* Instance ProducerConsumerSync.consumers[38] of class Consumer
    producerconsumersync_consumers_self[38] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[38]
    producerconsumersync_consumers_self[38]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[38]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[38]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_38 = 0.0;
    producerconsumersync_consumers_self[38]->consItem = producerconsumersync_consumers_initial_consItem_38;
    static int producerconsumersync_consumers_initial_itemsConsumed_38 = 0;
    producerconsumersync_consumers_self[38]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_38;
    //***** End initializing ProducerConsumerSync.consumers[38]
    // ************* Instance ProducerConsumerSync.consumers[39] of class Consumer
    producerconsumersync_consumers_self[39] = new_Consumer();
    //***** Start initializing ProducerConsumerSync.consumers[39]
    producerconsumersync_consumers_self[39]->numItemsToConsume = 1000; 
    producerconsumersync_consumers_self[39]->consCost = 25; 
    // width of -2 indicates that it is not a multiport.
    producerconsumersync_consumers_self[39]->__data__width = -2;
    static double producerconsumersync_consumers_initial_consItem_39 = 0.0;
    producerconsumersync_consumers_self[39]->consItem = producerconsumersync_consumers_initial_consItem_39;
    static int producerconsumersync_consumers_initial_itemsConsumed_39 = 0;
    producerconsumersync_consumers_self[39]->itemsConsumed = producerconsumersync_consumers_initial_itemsConsumed_39;
    //***** End initializing ProducerConsumerSync.consumers[39]
    //***** End initializing ProducerConsumerSync
    // Populate arrays of trigger pointers.
    producerconsumersync_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    producerconsumersync_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_self->___reaction_0.num_outputs > 0) {
        producerconsumersync_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_self->___reaction_0.num_outputs);
        producerconsumersync_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_self->___reaction_0.num_outputs);
        producerconsumersync_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync does not depend on one maximal upstream reaction.
    producerconsumersync_self->___reaction_0.last_enabling_reaction = NULL;
    producerconsumersync_producers_self[0]->bank_index = 0;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[0]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[0]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[0]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[0]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[0]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[0]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[0]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[0]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[0]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[0]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[0] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[0]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[0] triggers 1 downstream reactions through port ProducerConsumerSync.producers[0].data.
    producerconsumersync_producers_self[0]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[0], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[0].data
    trigger_t** producerconsumersync_producers_0__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[0]->___reaction_0.triggers[0] = producerconsumersync_producers_0__0_0;
    // Point to destination port ProducerConsumerSync.consumers[0].data's trigger struct.
    producerconsumersync_producers_0__0_0[0] = &producerconsumersync_consumers_self[0]->___data;
    producerconsumersync_producers_self[0]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[1]->bank_index = 1;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[1]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[1]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[1]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[1]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[1]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[1]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[1]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[1]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[1]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[1]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[1] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[1]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[1] triggers 1 downstream reactions through port ProducerConsumerSync.producers[1].data.
    producerconsumersync_producers_self[1]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[1], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[1].data
    trigger_t** producerconsumersync_producers_1__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[1]->___reaction_0.triggers[0] = producerconsumersync_producers_1__0_0;
    // Point to destination port ProducerConsumerSync.consumers[1].data's trigger struct.
    producerconsumersync_producers_1__0_0[0] = &producerconsumersync_consumers_self[1]->___data;
    producerconsumersync_producers_self[1]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[2]->bank_index = 2;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[2]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[2]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[2]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[2]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[2]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[2]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[2]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[2]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[2]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[2]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[2] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[2]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[2] triggers 1 downstream reactions through port ProducerConsumerSync.producers[2].data.
    producerconsumersync_producers_self[2]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[2], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[2].data
    trigger_t** producerconsumersync_producers_2__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[2]->___reaction_0.triggers[0] = producerconsumersync_producers_2__0_0;
    // Point to destination port ProducerConsumerSync.consumers[2].data's trigger struct.
    producerconsumersync_producers_2__0_0[0] = &producerconsumersync_consumers_self[2]->___data;
    producerconsumersync_producers_self[2]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[3]->bank_index = 3;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[3]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[3]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[3]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[3]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[3]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[3]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[3]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[3]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[3]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[3]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[3] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[3]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[3] triggers 1 downstream reactions through port ProducerConsumerSync.producers[3].data.
    producerconsumersync_producers_self[3]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[3], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[3].data
    trigger_t** producerconsumersync_producers_3__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[3]->___reaction_0.triggers[0] = producerconsumersync_producers_3__0_0;
    // Point to destination port ProducerConsumerSync.consumers[3].data's trigger struct.
    producerconsumersync_producers_3__0_0[0] = &producerconsumersync_consumers_self[3]->___data;
    producerconsumersync_producers_self[3]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[4]->bank_index = 4;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[4]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[4]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[4]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[4]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[4]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[4]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[4]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[4]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[4]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[4]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[4] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[4]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[4] triggers 1 downstream reactions through port ProducerConsumerSync.producers[4].data.
    producerconsumersync_producers_self[4]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[4], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[4].data
    trigger_t** producerconsumersync_producers_4__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[4]->___reaction_0.triggers[0] = producerconsumersync_producers_4__0_0;
    // Point to destination port ProducerConsumerSync.consumers[4].data's trigger struct.
    producerconsumersync_producers_4__0_0[0] = &producerconsumersync_consumers_self[4]->___data;
    producerconsumersync_producers_self[4]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[5]->bank_index = 5;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[5]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[5]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[5]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[5]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[5]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[5]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[5]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[5]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[5]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[5]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[5] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[5]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[5] triggers 1 downstream reactions through port ProducerConsumerSync.producers[5].data.
    producerconsumersync_producers_self[5]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[5], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[5].data
    trigger_t** producerconsumersync_producers_5__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[5]->___reaction_0.triggers[0] = producerconsumersync_producers_5__0_0;
    // Point to destination port ProducerConsumerSync.consumers[5].data's trigger struct.
    producerconsumersync_producers_5__0_0[0] = &producerconsumersync_consumers_self[5]->___data;
    producerconsumersync_producers_self[5]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[6]->bank_index = 6;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[6]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[6]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[6]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[6]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[6]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[6]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[6]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[6]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[6]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[6]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[6] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[6]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[6] triggers 1 downstream reactions through port ProducerConsumerSync.producers[6].data.
    producerconsumersync_producers_self[6]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[6], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[6].data
    trigger_t** producerconsumersync_producers_6__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[6]->___reaction_0.triggers[0] = producerconsumersync_producers_6__0_0;
    // Point to destination port ProducerConsumerSync.consumers[6].data's trigger struct.
    producerconsumersync_producers_6__0_0[0] = &producerconsumersync_consumers_self[6]->___data;
    producerconsumersync_producers_self[6]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[7]->bank_index = 7;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[7]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[7]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[7]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[7]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[7]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[7]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[7]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[7]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[7]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[7]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[7] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[7]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[7] triggers 1 downstream reactions through port ProducerConsumerSync.producers[7].data.
    producerconsumersync_producers_self[7]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[7], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[7].data
    trigger_t** producerconsumersync_producers_7__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[7]->___reaction_0.triggers[0] = producerconsumersync_producers_7__0_0;
    // Point to destination port ProducerConsumerSync.consumers[7].data's trigger struct.
    producerconsumersync_producers_7__0_0[0] = &producerconsumersync_consumers_self[7]->___data;
    producerconsumersync_producers_self[7]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[8]->bank_index = 8;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[8]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[8]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[8]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[8]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[8]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[8]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[8]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[8]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[8]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[8]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[8] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[8]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[8] triggers 1 downstream reactions through port ProducerConsumerSync.producers[8].data.
    producerconsumersync_producers_self[8]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[8], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[8].data
    trigger_t** producerconsumersync_producers_8__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[8]->___reaction_0.triggers[0] = producerconsumersync_producers_8__0_0;
    // Point to destination port ProducerConsumerSync.consumers[8].data's trigger struct.
    producerconsumersync_producers_8__0_0[0] = &producerconsumersync_consumers_self[8]->___data;
    producerconsumersync_producers_self[8]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[9]->bank_index = 9;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[9]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[9]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[9]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[9]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[9]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[9]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[9]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[9]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[9]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[9]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[9] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[9]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[9] triggers 1 downstream reactions through port ProducerConsumerSync.producers[9].data.
    producerconsumersync_producers_self[9]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[9], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[9].data
    trigger_t** producerconsumersync_producers_9__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[9]->___reaction_0.triggers[0] = producerconsumersync_producers_9__0_0;
    // Point to destination port ProducerConsumerSync.consumers[9].data's trigger struct.
    producerconsumersync_producers_9__0_0[0] = &producerconsumersync_consumers_self[9]->___data;
    producerconsumersync_producers_self[9]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[10]->bank_index = 10;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[10]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[10]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[10]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[10]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[10]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[10]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[10]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[10]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[10]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[10]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[10] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[10]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[10] triggers 1 downstream reactions through port ProducerConsumerSync.producers[10].data.
    producerconsumersync_producers_self[10]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[10], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[10].data
    trigger_t** producerconsumersync_producers_10__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[10]->___reaction_0.triggers[0] = producerconsumersync_producers_10__0_0;
    // Point to destination port ProducerConsumerSync.consumers[10].data's trigger struct.
    producerconsumersync_producers_10__0_0[0] = &producerconsumersync_consumers_self[10]->___data;
    producerconsumersync_producers_self[10]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[11]->bank_index = 11;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[11]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[11]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[11]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[11]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[11]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[11]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[11]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[11]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[11]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[11]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[11] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[11]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[11] triggers 1 downstream reactions through port ProducerConsumerSync.producers[11].data.
    producerconsumersync_producers_self[11]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[11], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[11].data
    trigger_t** producerconsumersync_producers_11__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[11]->___reaction_0.triggers[0] = producerconsumersync_producers_11__0_0;
    // Point to destination port ProducerConsumerSync.consumers[11].data's trigger struct.
    producerconsumersync_producers_11__0_0[0] = &producerconsumersync_consumers_self[11]->___data;
    producerconsumersync_producers_self[11]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[12]->bank_index = 12;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[12]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[12]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[12]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[12]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[12]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[12]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[12]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[12]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[12]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[12]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[12] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[12]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[12] triggers 1 downstream reactions through port ProducerConsumerSync.producers[12].data.
    producerconsumersync_producers_self[12]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[12], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[12].data
    trigger_t** producerconsumersync_producers_12__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[12]->___reaction_0.triggers[0] = producerconsumersync_producers_12__0_0;
    // Point to destination port ProducerConsumerSync.consumers[12].data's trigger struct.
    producerconsumersync_producers_12__0_0[0] = &producerconsumersync_consumers_self[12]->___data;
    producerconsumersync_producers_self[12]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[13]->bank_index = 13;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[13]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[13]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[13]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[13]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[13]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[13]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[13]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[13]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[13]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[13]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[13] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[13]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[13] triggers 1 downstream reactions through port ProducerConsumerSync.producers[13].data.
    producerconsumersync_producers_self[13]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[13], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[13].data
    trigger_t** producerconsumersync_producers_13__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[13]->___reaction_0.triggers[0] = producerconsumersync_producers_13__0_0;
    // Point to destination port ProducerConsumerSync.consumers[13].data's trigger struct.
    producerconsumersync_producers_13__0_0[0] = &producerconsumersync_consumers_self[13]->___data;
    producerconsumersync_producers_self[13]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[14]->bank_index = 14;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[14]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[14]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[14]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[14]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[14]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[14]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[14]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[14]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[14]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[14]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[14] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[14]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[14] triggers 1 downstream reactions through port ProducerConsumerSync.producers[14].data.
    producerconsumersync_producers_self[14]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[14], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[14].data
    trigger_t** producerconsumersync_producers_14__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[14]->___reaction_0.triggers[0] = producerconsumersync_producers_14__0_0;
    // Point to destination port ProducerConsumerSync.consumers[14].data's trigger struct.
    producerconsumersync_producers_14__0_0[0] = &producerconsumersync_consumers_self[14]->___data;
    producerconsumersync_producers_self[14]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[15]->bank_index = 15;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[15]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[15]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[15]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[15]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[15]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[15]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[15]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[15]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[15]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[15]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[15] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[15]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[15] triggers 1 downstream reactions through port ProducerConsumerSync.producers[15].data.
    producerconsumersync_producers_self[15]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[15], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[15].data
    trigger_t** producerconsumersync_producers_15__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[15]->___reaction_0.triggers[0] = producerconsumersync_producers_15__0_0;
    // Point to destination port ProducerConsumerSync.consumers[15].data's trigger struct.
    producerconsumersync_producers_15__0_0[0] = &producerconsumersync_consumers_self[15]->___data;
    producerconsumersync_producers_self[15]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[16]->bank_index = 16;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[16]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[16]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[16]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[16]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[16]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[16]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[16]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[16]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[16]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[16]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[16] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[16]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[16] triggers 1 downstream reactions through port ProducerConsumerSync.producers[16].data.
    producerconsumersync_producers_self[16]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[16], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[16].data
    trigger_t** producerconsumersync_producers_16__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[16]->___reaction_0.triggers[0] = producerconsumersync_producers_16__0_0;
    // Point to destination port ProducerConsumerSync.consumers[16].data's trigger struct.
    producerconsumersync_producers_16__0_0[0] = &producerconsumersync_consumers_self[16]->___data;
    producerconsumersync_producers_self[16]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[17]->bank_index = 17;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[17]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[17]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[17]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[17]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[17]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[17]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[17]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[17]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[17]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[17]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[17] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[17]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[17] triggers 1 downstream reactions through port ProducerConsumerSync.producers[17].data.
    producerconsumersync_producers_self[17]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[17], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[17].data
    trigger_t** producerconsumersync_producers_17__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[17]->___reaction_0.triggers[0] = producerconsumersync_producers_17__0_0;
    // Point to destination port ProducerConsumerSync.consumers[17].data's trigger struct.
    producerconsumersync_producers_17__0_0[0] = &producerconsumersync_consumers_self[17]->___data;
    producerconsumersync_producers_self[17]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[18]->bank_index = 18;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[18]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[18]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[18]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[18]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[18]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[18]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[18]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[18]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[18]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[18]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[18] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[18]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[18] triggers 1 downstream reactions through port ProducerConsumerSync.producers[18].data.
    producerconsumersync_producers_self[18]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[18], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[18].data
    trigger_t** producerconsumersync_producers_18__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[18]->___reaction_0.triggers[0] = producerconsumersync_producers_18__0_0;
    // Point to destination port ProducerConsumerSync.consumers[18].data's trigger struct.
    producerconsumersync_producers_18__0_0[0] = &producerconsumersync_consumers_self[18]->___data;
    producerconsumersync_producers_self[18]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[19]->bank_index = 19;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[19]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[19]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[19]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[19]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[19]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[19]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[19]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[19]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[19]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[19]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[19] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[19]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[19] triggers 1 downstream reactions through port ProducerConsumerSync.producers[19].data.
    producerconsumersync_producers_self[19]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[19], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[19].data
    trigger_t** producerconsumersync_producers_19__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[19]->___reaction_0.triggers[0] = producerconsumersync_producers_19__0_0;
    // Point to destination port ProducerConsumerSync.consumers[19].data's trigger struct.
    producerconsumersync_producers_19__0_0[0] = &producerconsumersync_consumers_self[19]->___data;
    producerconsumersync_producers_self[19]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[20]->bank_index = 20;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[20]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[20]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[20]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[20]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[20]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[20]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[20]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[20]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[20]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[20]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[20] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[20]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[20] triggers 1 downstream reactions through port ProducerConsumerSync.producers[20].data.
    producerconsumersync_producers_self[20]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[20], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[20].data
    trigger_t** producerconsumersync_producers_20__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[20]->___reaction_0.triggers[0] = producerconsumersync_producers_20__0_0;
    // Point to destination port ProducerConsumerSync.consumers[20].data's trigger struct.
    producerconsumersync_producers_20__0_0[0] = &producerconsumersync_consumers_self[20]->___data;
    producerconsumersync_producers_self[20]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[21]->bank_index = 21;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[21]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[21]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[21]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[21]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[21]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[21]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[21]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[21]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[21]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[21]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[21] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[21]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[21] triggers 1 downstream reactions through port ProducerConsumerSync.producers[21].data.
    producerconsumersync_producers_self[21]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[21], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[21].data
    trigger_t** producerconsumersync_producers_21__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[21]->___reaction_0.triggers[0] = producerconsumersync_producers_21__0_0;
    // Point to destination port ProducerConsumerSync.consumers[21].data's trigger struct.
    producerconsumersync_producers_21__0_0[0] = &producerconsumersync_consumers_self[21]->___data;
    producerconsumersync_producers_self[21]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[22]->bank_index = 22;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[22]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[22]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[22]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[22]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[22]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[22]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[22]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[22]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[22]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[22]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[22] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[22]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[22] triggers 1 downstream reactions through port ProducerConsumerSync.producers[22].data.
    producerconsumersync_producers_self[22]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[22], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[22].data
    trigger_t** producerconsumersync_producers_22__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[22]->___reaction_0.triggers[0] = producerconsumersync_producers_22__0_0;
    // Point to destination port ProducerConsumerSync.consumers[22].data's trigger struct.
    producerconsumersync_producers_22__0_0[0] = &producerconsumersync_consumers_self[22]->___data;
    producerconsumersync_producers_self[22]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[23]->bank_index = 23;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[23]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[23]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[23]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[23]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[23]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[23]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[23]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[23]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[23]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[23]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[23] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[23]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[23] triggers 1 downstream reactions through port ProducerConsumerSync.producers[23].data.
    producerconsumersync_producers_self[23]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[23], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[23].data
    trigger_t** producerconsumersync_producers_23__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[23]->___reaction_0.triggers[0] = producerconsumersync_producers_23__0_0;
    // Point to destination port ProducerConsumerSync.consumers[23].data's trigger struct.
    producerconsumersync_producers_23__0_0[0] = &producerconsumersync_consumers_self[23]->___data;
    producerconsumersync_producers_self[23]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[24]->bank_index = 24;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[24]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[24]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[24]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[24]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[24]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[24]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[24]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[24]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[24]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[24]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[24] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[24]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[24] triggers 1 downstream reactions through port ProducerConsumerSync.producers[24].data.
    producerconsumersync_producers_self[24]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[24], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[24].data
    trigger_t** producerconsumersync_producers_24__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[24]->___reaction_0.triggers[0] = producerconsumersync_producers_24__0_0;
    // Point to destination port ProducerConsumerSync.consumers[24].data's trigger struct.
    producerconsumersync_producers_24__0_0[0] = &producerconsumersync_consumers_self[24]->___data;
    producerconsumersync_producers_self[24]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[25]->bank_index = 25;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[25]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[25]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[25]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[25]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[25]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[25]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[25]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[25]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[25]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[25]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[25] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[25]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[25] triggers 1 downstream reactions through port ProducerConsumerSync.producers[25].data.
    producerconsumersync_producers_self[25]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[25], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[25].data
    trigger_t** producerconsumersync_producers_25__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[25]->___reaction_0.triggers[0] = producerconsumersync_producers_25__0_0;
    // Point to destination port ProducerConsumerSync.consumers[25].data's trigger struct.
    producerconsumersync_producers_25__0_0[0] = &producerconsumersync_consumers_self[25]->___data;
    producerconsumersync_producers_self[25]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[26]->bank_index = 26;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[26]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[26]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[26]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[26]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[26]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[26]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[26]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[26]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[26]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[26]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[26] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[26]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[26] triggers 1 downstream reactions through port ProducerConsumerSync.producers[26].data.
    producerconsumersync_producers_self[26]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[26], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[26].data
    trigger_t** producerconsumersync_producers_26__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[26]->___reaction_0.triggers[0] = producerconsumersync_producers_26__0_0;
    // Point to destination port ProducerConsumerSync.consumers[26].data's trigger struct.
    producerconsumersync_producers_26__0_0[0] = &producerconsumersync_consumers_self[26]->___data;
    producerconsumersync_producers_self[26]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[27]->bank_index = 27;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[27]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[27]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[27]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[27]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[27]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[27]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[27]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[27]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[27]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[27]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[27] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[27]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[27] triggers 1 downstream reactions through port ProducerConsumerSync.producers[27].data.
    producerconsumersync_producers_self[27]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[27], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[27].data
    trigger_t** producerconsumersync_producers_27__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[27]->___reaction_0.triggers[0] = producerconsumersync_producers_27__0_0;
    // Point to destination port ProducerConsumerSync.consumers[27].data's trigger struct.
    producerconsumersync_producers_27__0_0[0] = &producerconsumersync_consumers_self[27]->___data;
    producerconsumersync_producers_self[27]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[28]->bank_index = 28;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[28]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[28]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[28]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[28]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[28]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[28]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[28]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[28]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[28]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[28]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[28] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[28]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[28] triggers 1 downstream reactions through port ProducerConsumerSync.producers[28].data.
    producerconsumersync_producers_self[28]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[28], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[28].data
    trigger_t** producerconsumersync_producers_28__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[28]->___reaction_0.triggers[0] = producerconsumersync_producers_28__0_0;
    // Point to destination port ProducerConsumerSync.consumers[28].data's trigger struct.
    producerconsumersync_producers_28__0_0[0] = &producerconsumersync_consumers_self[28]->___data;
    producerconsumersync_producers_self[28]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[29]->bank_index = 29;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[29]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[29]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[29]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[29]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[29]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[29]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[29]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[29]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[29]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[29]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[29] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[29]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[29] triggers 1 downstream reactions through port ProducerConsumerSync.producers[29].data.
    producerconsumersync_producers_self[29]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[29], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[29].data
    trigger_t** producerconsumersync_producers_29__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[29]->___reaction_0.triggers[0] = producerconsumersync_producers_29__0_0;
    // Point to destination port ProducerConsumerSync.consumers[29].data's trigger struct.
    producerconsumersync_producers_29__0_0[0] = &producerconsumersync_consumers_self[29]->___data;
    producerconsumersync_producers_self[29]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[30]->bank_index = 30;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[30]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[30]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[30]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[30]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[30]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[30]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[30]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[30]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[30]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[30]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[30] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[30]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[30] triggers 1 downstream reactions through port ProducerConsumerSync.producers[30].data.
    producerconsumersync_producers_self[30]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[30], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[30].data
    trigger_t** producerconsumersync_producers_30__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[30]->___reaction_0.triggers[0] = producerconsumersync_producers_30__0_0;
    // Point to destination port ProducerConsumerSync.consumers[30].data's trigger struct.
    producerconsumersync_producers_30__0_0[0] = &producerconsumersync_consumers_self[30]->___data;
    producerconsumersync_producers_self[30]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[31]->bank_index = 31;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[31]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[31]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[31]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[31]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[31]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[31]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[31]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[31]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[31]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[31]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[31] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[31]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[31] triggers 1 downstream reactions through port ProducerConsumerSync.producers[31].data.
    producerconsumersync_producers_self[31]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[31], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[31].data
    trigger_t** producerconsumersync_producers_31__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[31]->___reaction_0.triggers[0] = producerconsumersync_producers_31__0_0;
    // Point to destination port ProducerConsumerSync.consumers[31].data's trigger struct.
    producerconsumersync_producers_31__0_0[0] = &producerconsumersync_consumers_self[31]->___data;
    producerconsumersync_producers_self[31]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[32]->bank_index = 32;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[32]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[32]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[32]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[32]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[32]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[32]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[32]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[32]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[32]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[32]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[32] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[32]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[32] triggers 1 downstream reactions through port ProducerConsumerSync.producers[32].data.
    producerconsumersync_producers_self[32]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[32], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[32].data
    trigger_t** producerconsumersync_producers_32__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[32]->___reaction_0.triggers[0] = producerconsumersync_producers_32__0_0;
    // Point to destination port ProducerConsumerSync.consumers[32].data's trigger struct.
    producerconsumersync_producers_32__0_0[0] = &producerconsumersync_consumers_self[32]->___data;
    producerconsumersync_producers_self[32]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[33]->bank_index = 33;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[33]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[33]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[33]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[33]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[33]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[33]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[33]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[33]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[33]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[33]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[33] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[33]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[33] triggers 1 downstream reactions through port ProducerConsumerSync.producers[33].data.
    producerconsumersync_producers_self[33]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[33], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[33].data
    trigger_t** producerconsumersync_producers_33__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[33]->___reaction_0.triggers[0] = producerconsumersync_producers_33__0_0;
    // Point to destination port ProducerConsumerSync.consumers[33].data's trigger struct.
    producerconsumersync_producers_33__0_0[0] = &producerconsumersync_consumers_self[33]->___data;
    producerconsumersync_producers_self[33]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[34]->bank_index = 34;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[34]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[34]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[34]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[34]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[34]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[34]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[34]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[34]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[34]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[34]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[34] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[34]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[34] triggers 1 downstream reactions through port ProducerConsumerSync.producers[34].data.
    producerconsumersync_producers_self[34]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[34], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[34].data
    trigger_t** producerconsumersync_producers_34__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[34]->___reaction_0.triggers[0] = producerconsumersync_producers_34__0_0;
    // Point to destination port ProducerConsumerSync.consumers[34].data's trigger struct.
    producerconsumersync_producers_34__0_0[0] = &producerconsumersync_consumers_self[34]->___data;
    producerconsumersync_producers_self[34]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[35]->bank_index = 35;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[35]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[35]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[35]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[35]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[35]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[35]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[35]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[35]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[35]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[35]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[35] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[35]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[35] triggers 1 downstream reactions through port ProducerConsumerSync.producers[35].data.
    producerconsumersync_producers_self[35]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[35], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[35].data
    trigger_t** producerconsumersync_producers_35__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[35]->___reaction_0.triggers[0] = producerconsumersync_producers_35__0_0;
    // Point to destination port ProducerConsumerSync.consumers[35].data's trigger struct.
    producerconsumersync_producers_35__0_0[0] = &producerconsumersync_consumers_self[35]->___data;
    producerconsumersync_producers_self[35]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[36]->bank_index = 36;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[36]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[36]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[36]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[36]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[36]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[36]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[36]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[36]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[36]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[36]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[36] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[36]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[36] triggers 1 downstream reactions through port ProducerConsumerSync.producers[36].data.
    producerconsumersync_producers_self[36]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[36], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[36].data
    trigger_t** producerconsumersync_producers_36__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[36]->___reaction_0.triggers[0] = producerconsumersync_producers_36__0_0;
    // Point to destination port ProducerConsumerSync.consumers[36].data's trigger struct.
    producerconsumersync_producers_36__0_0[0] = &producerconsumersync_consumers_self[36]->___data;
    producerconsumersync_producers_self[36]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[37]->bank_index = 37;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[37]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[37]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[37]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[37]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[37]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[37]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[37]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[37]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[37]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[37]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[37] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[37]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[37] triggers 1 downstream reactions through port ProducerConsumerSync.producers[37].data.
    producerconsumersync_producers_self[37]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[37], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[37].data
    trigger_t** producerconsumersync_producers_37__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[37]->___reaction_0.triggers[0] = producerconsumersync_producers_37__0_0;
    // Point to destination port ProducerConsumerSync.consumers[37].data's trigger struct.
    producerconsumersync_producers_37__0_0[0] = &producerconsumersync_consumers_self[37]->___data;
    producerconsumersync_producers_self[37]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[38]->bank_index = 38;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[38]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[38]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[38]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[38]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[38]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[38]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[38]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[38]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[38]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[38]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[38] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[38]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[38] triggers 1 downstream reactions through port ProducerConsumerSync.producers[38].data.
    producerconsumersync_producers_self[38]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[38], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[38].data
    trigger_t** producerconsumersync_producers_38__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[38]->___reaction_0.triggers[0] = producerconsumersync_producers_38__0_0;
    // Point to destination port ProducerConsumerSync.consumers[38].data's trigger struct.
    producerconsumersync_producers_38__0_0[0] = &producerconsumersync_consumers_self[38]->___data;
    producerconsumersync_producers_self[38]->__data.num_destinations
    = 1;
    producerconsumersync_producers_self[39]->bank_index = 39;
    // Total number of outputs produced by the reaction.
    producerconsumersync_producers_self[39]->___reaction_0.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_producers_self[39]->___reaction_0.num_outputs > 0) {
        producerconsumersync_producers_self[39]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_producers_self[39]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[39]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_producers_self[39]->___reaction_0.num_outputs);
        producerconsumersync_producers_self[39]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_producers_self[39]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    producerconsumersync_producers_self[39]->___reaction_0.output_produced[0]
    = &producerconsumersync_producers_self[39]->__data.is_present
    ;
    // Reaction 0 of ProducerConsumerSync.producers[39] does not depend on one maximal upstream reaction.
    producerconsumersync_producers_self[39]->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 0 of ProducerConsumerSync.producers[39] triggers 1 downstream reactions through port ProducerConsumerSync.producers[39].data.
    producerconsumersync_producers_self[39]->___reaction_0.triggered_sizes[0] = 1;
    // For reaction 0 of ProducerConsumerSync.producers[39], allocate an
    // array of trigger pointers for downstream reactions through port ProducerConsumerSync.producers[39].data
    trigger_t** producerconsumersync_producers_39__0_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    producerconsumersync_producers_self[39]->___reaction_0.triggers[0] = producerconsumersync_producers_39__0_0;
    // Point to destination port ProducerConsumerSync.consumers[39].data's trigger struct.
    producerconsumersync_producers_39__0_0[0] = &producerconsumersync_consumers_self[39]->___data;
    producerconsumersync_producers_self[39]->__data.num_destinations
    = 1;
    producerconsumersync_consumers_self[0]->bank_index = 0;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[0]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[0]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[0]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[0]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[0]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[0]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[0]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[0]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[0] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[0]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[0]->___reaction_0);
    producerconsumersync_consumers_self[1]->bank_index = 1;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[1]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[1]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[1]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[1]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[1]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[1]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[1]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[1]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[1] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[1]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[1]->___reaction_0);
    producerconsumersync_consumers_self[2]->bank_index = 2;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[2]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[2]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[2]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[2]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[2]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[2]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[2]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[2]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[2] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[2]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[2]->___reaction_0);
    producerconsumersync_consumers_self[3]->bank_index = 3;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[3]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[3]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[3]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[3]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[3]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[3]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[3]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[3]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[3] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[3]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[3]->___reaction_0);
    producerconsumersync_consumers_self[4]->bank_index = 4;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[4]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[4]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[4]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[4]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[4]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[4]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[4]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[4]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[4] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[4]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[4]->___reaction_0);
    producerconsumersync_consumers_self[5]->bank_index = 5;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[5]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[5]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[5]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[5]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[5]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[5]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[5]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[5]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[5] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[5]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[5]->___reaction_0);
    producerconsumersync_consumers_self[6]->bank_index = 6;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[6]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[6]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[6]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[6]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[6]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[6]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[6]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[6]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[6] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[6]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[6]->___reaction_0);
    producerconsumersync_consumers_self[7]->bank_index = 7;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[7]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[7]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[7]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[7]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[7]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[7]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[7]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[7]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[7] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[7]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[7]->___reaction_0);
    producerconsumersync_consumers_self[8]->bank_index = 8;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[8]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[8]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[8]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[8]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[8]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[8]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[8]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[8]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[8] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[8]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[8]->___reaction_0);
    producerconsumersync_consumers_self[9]->bank_index = 9;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[9]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[9]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[9]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[9]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[9]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[9]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[9]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[9]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[9] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[9]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[9]->___reaction_0);
    producerconsumersync_consumers_self[10]->bank_index = 10;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[10]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[10]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[10]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[10]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[10]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[10]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[10]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[10]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[10] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[10]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[10]->___reaction_0);
    producerconsumersync_consumers_self[11]->bank_index = 11;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[11]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[11]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[11]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[11]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[11]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[11]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[11]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[11]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[11] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[11]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[11]->___reaction_0);
    producerconsumersync_consumers_self[12]->bank_index = 12;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[12]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[12]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[12]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[12]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[12]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[12]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[12]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[12]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[12] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[12]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[12]->___reaction_0);
    producerconsumersync_consumers_self[13]->bank_index = 13;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[13]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[13]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[13]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[13]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[13]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[13]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[13]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[13]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[13] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[13]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[13]->___reaction_0);
    producerconsumersync_consumers_self[14]->bank_index = 14;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[14]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[14]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[14]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[14]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[14]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[14]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[14]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[14]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[14] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[14]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[14]->___reaction_0);
    producerconsumersync_consumers_self[15]->bank_index = 15;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[15]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[15]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[15]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[15]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[15]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[15]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[15]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[15]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[15] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[15]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[15]->___reaction_0);
    producerconsumersync_consumers_self[16]->bank_index = 16;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[16]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[16]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[16]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[16]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[16]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[16]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[16]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[16]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[16] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[16]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[16]->___reaction_0);
    producerconsumersync_consumers_self[17]->bank_index = 17;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[17]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[17]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[17]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[17]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[17]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[17]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[17]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[17]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[17] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[17]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[17]->___reaction_0);
    producerconsumersync_consumers_self[18]->bank_index = 18;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[18]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[18]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[18]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[18]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[18]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[18]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[18]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[18]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[18] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[18]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[18]->___reaction_0);
    producerconsumersync_consumers_self[19]->bank_index = 19;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[19]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[19]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[19]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[19]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[19]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[19]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[19]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[19]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[19] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[19]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[19]->___reaction_0);
    producerconsumersync_consumers_self[20]->bank_index = 20;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[20]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[20]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[20]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[20]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[20]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[20]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[20]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[20]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[20] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[20]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[20]->___reaction_0);
    producerconsumersync_consumers_self[21]->bank_index = 21;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[21]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[21]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[21]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[21]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[21]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[21]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[21]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[21]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[21] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[21]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[21]->___reaction_0);
    producerconsumersync_consumers_self[22]->bank_index = 22;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[22]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[22]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[22]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[22]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[22]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[22]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[22]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[22]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[22] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[22]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[22]->___reaction_0);
    producerconsumersync_consumers_self[23]->bank_index = 23;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[23]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[23]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[23]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[23]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[23]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[23]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[23]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[23]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[23] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[23]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[23]->___reaction_0);
    producerconsumersync_consumers_self[24]->bank_index = 24;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[24]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[24]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[24]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[24]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[24]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[24]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[24]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[24]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[24] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[24]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[24]->___reaction_0);
    producerconsumersync_consumers_self[25]->bank_index = 25;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[25]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[25]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[25]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[25]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[25]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[25]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[25]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[25]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[25] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[25]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[25]->___reaction_0);
    producerconsumersync_consumers_self[26]->bank_index = 26;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[26]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[26]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[26]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[26]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[26]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[26]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[26]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[26]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[26] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[26]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[26]->___reaction_0);
    producerconsumersync_consumers_self[27]->bank_index = 27;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[27]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[27]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[27]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[27]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[27]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[27]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[27]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[27]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[27] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[27]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[27]->___reaction_0);
    producerconsumersync_consumers_self[28]->bank_index = 28;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[28]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[28]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[28]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[28]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[28]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[28]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[28]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[28]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[28] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[28]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[28]->___reaction_0);
    producerconsumersync_consumers_self[29]->bank_index = 29;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[29]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[29]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[29]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[29]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[29]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[29]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[29]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[29]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[29] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[29]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[29]->___reaction_0);
    producerconsumersync_consumers_self[30]->bank_index = 30;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[30]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[30]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[30]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[30]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[30]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[30]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[30]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[30]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[30] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[30]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[30]->___reaction_0);
    producerconsumersync_consumers_self[31]->bank_index = 31;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[31]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[31]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[31]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[31]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[31]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[31]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[31]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[31]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[31] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[31]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[31]->___reaction_0);
    producerconsumersync_consumers_self[32]->bank_index = 32;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[32]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[32]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[32]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[32]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[32]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[32]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[32]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[32]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[32] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[32]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[32]->___reaction_0);
    producerconsumersync_consumers_self[33]->bank_index = 33;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[33]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[33]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[33]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[33]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[33]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[33]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[33]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[33]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[33] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[33]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[33]->___reaction_0);
    producerconsumersync_consumers_self[34]->bank_index = 34;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[34]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[34]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[34]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[34]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[34]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[34]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[34]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[34]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[34] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[34]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[34]->___reaction_0);
    producerconsumersync_consumers_self[35]->bank_index = 35;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[35]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[35]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[35]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[35]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[35]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[35]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[35]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[35]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[35] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[35]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[35]->___reaction_0);
    producerconsumersync_consumers_self[36]->bank_index = 36;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[36]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[36]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[36]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[36]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[36]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[36]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[36]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[36]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[36] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[36]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[36]->___reaction_0);
    producerconsumersync_consumers_self[37]->bank_index = 37;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[37]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[37]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[37]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[37]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[37]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[37]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[37]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[37]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[37] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[37]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[37]->___reaction_0);
    producerconsumersync_consumers_self[38]->bank_index = 38;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[38]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[38]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[38]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[38]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[38]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[38]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[38]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[38]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[38] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[38]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[38]->___reaction_0);
    producerconsumersync_consumers_self[39]->bank_index = 39;
    // Total number of outputs produced by the reaction.
    producerconsumersync_consumers_self[39]->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (producerconsumersync_consumers_self[39]->___reaction_0.num_outputs > 0) {
        producerconsumersync_consumers_self[39]->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * producerconsumersync_consumers_self[39]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[39]->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * producerconsumersync_consumers_self[39]->___reaction_0.num_outputs);
        producerconsumersync_consumers_self[39]->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * producerconsumersync_consumers_self[39]->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of ProducerConsumerSync.consumers[39] depends on one maximal upstream reaction.
    producerconsumersync_consumers_self[39]->___reaction_0.last_enabling_reaction = &(producerconsumersync_producers_self[39]->___reaction_0);
    // doDeferredInitialize
    // Connect inputs and outputs for reactor ProducerConsumerSync.
    // Connect ProducerConsumerSync.producers[0].data to input port ProducerConsumerSync.consumers[0].data
    producerconsumersync_consumers_self[0]->__data = (consumer_data_t*)&producerconsumersync_producers_self[0]->__data;
    // Connect ProducerConsumerSync.producers[1].data to input port ProducerConsumerSync.consumers[1].data
    producerconsumersync_consumers_self[1]->__data = (consumer_data_t*)&producerconsumersync_producers_self[1]->__data;
    // Connect ProducerConsumerSync.producers[2].data to input port ProducerConsumerSync.consumers[2].data
    producerconsumersync_consumers_self[2]->__data = (consumer_data_t*)&producerconsumersync_producers_self[2]->__data;
    // Connect ProducerConsumerSync.producers[3].data to input port ProducerConsumerSync.consumers[3].data
    producerconsumersync_consumers_self[3]->__data = (consumer_data_t*)&producerconsumersync_producers_self[3]->__data;
    // Connect ProducerConsumerSync.producers[4].data to input port ProducerConsumerSync.consumers[4].data
    producerconsumersync_consumers_self[4]->__data = (consumer_data_t*)&producerconsumersync_producers_self[4]->__data;
    // Connect ProducerConsumerSync.producers[5].data to input port ProducerConsumerSync.consumers[5].data
    producerconsumersync_consumers_self[5]->__data = (consumer_data_t*)&producerconsumersync_producers_self[5]->__data;
    // Connect ProducerConsumerSync.producers[6].data to input port ProducerConsumerSync.consumers[6].data
    producerconsumersync_consumers_self[6]->__data = (consumer_data_t*)&producerconsumersync_producers_self[6]->__data;
    // Connect ProducerConsumerSync.producers[7].data to input port ProducerConsumerSync.consumers[7].data
    producerconsumersync_consumers_self[7]->__data = (consumer_data_t*)&producerconsumersync_producers_self[7]->__data;
    // Connect ProducerConsumerSync.producers[8].data to input port ProducerConsumerSync.consumers[8].data
    producerconsumersync_consumers_self[8]->__data = (consumer_data_t*)&producerconsumersync_producers_self[8]->__data;
    // Connect ProducerConsumerSync.producers[9].data to input port ProducerConsumerSync.consumers[9].data
    producerconsumersync_consumers_self[9]->__data = (consumer_data_t*)&producerconsumersync_producers_self[9]->__data;
    // Connect ProducerConsumerSync.producers[10].data to input port ProducerConsumerSync.consumers[10].data
    producerconsumersync_consumers_self[10]->__data = (consumer_data_t*)&producerconsumersync_producers_self[10]->__data;
    // Connect ProducerConsumerSync.producers[11].data to input port ProducerConsumerSync.consumers[11].data
    producerconsumersync_consumers_self[11]->__data = (consumer_data_t*)&producerconsumersync_producers_self[11]->__data;
    // Connect ProducerConsumerSync.producers[12].data to input port ProducerConsumerSync.consumers[12].data
    producerconsumersync_consumers_self[12]->__data = (consumer_data_t*)&producerconsumersync_producers_self[12]->__data;
    // Connect ProducerConsumerSync.producers[13].data to input port ProducerConsumerSync.consumers[13].data
    producerconsumersync_consumers_self[13]->__data = (consumer_data_t*)&producerconsumersync_producers_self[13]->__data;
    // Connect ProducerConsumerSync.producers[14].data to input port ProducerConsumerSync.consumers[14].data
    producerconsumersync_consumers_self[14]->__data = (consumer_data_t*)&producerconsumersync_producers_self[14]->__data;
    // Connect ProducerConsumerSync.producers[15].data to input port ProducerConsumerSync.consumers[15].data
    producerconsumersync_consumers_self[15]->__data = (consumer_data_t*)&producerconsumersync_producers_self[15]->__data;
    // Connect ProducerConsumerSync.producers[16].data to input port ProducerConsumerSync.consumers[16].data
    producerconsumersync_consumers_self[16]->__data = (consumer_data_t*)&producerconsumersync_producers_self[16]->__data;
    // Connect ProducerConsumerSync.producers[17].data to input port ProducerConsumerSync.consumers[17].data
    producerconsumersync_consumers_self[17]->__data = (consumer_data_t*)&producerconsumersync_producers_self[17]->__data;
    // Connect ProducerConsumerSync.producers[18].data to input port ProducerConsumerSync.consumers[18].data
    producerconsumersync_consumers_self[18]->__data = (consumer_data_t*)&producerconsumersync_producers_self[18]->__data;
    // Connect ProducerConsumerSync.producers[19].data to input port ProducerConsumerSync.consumers[19].data
    producerconsumersync_consumers_self[19]->__data = (consumer_data_t*)&producerconsumersync_producers_self[19]->__data;
    // Connect ProducerConsumerSync.producers[20].data to input port ProducerConsumerSync.consumers[20].data
    producerconsumersync_consumers_self[20]->__data = (consumer_data_t*)&producerconsumersync_producers_self[20]->__data;
    // Connect ProducerConsumerSync.producers[21].data to input port ProducerConsumerSync.consumers[21].data
    producerconsumersync_consumers_self[21]->__data = (consumer_data_t*)&producerconsumersync_producers_self[21]->__data;
    // Connect ProducerConsumerSync.producers[22].data to input port ProducerConsumerSync.consumers[22].data
    producerconsumersync_consumers_self[22]->__data = (consumer_data_t*)&producerconsumersync_producers_self[22]->__data;
    // Connect ProducerConsumerSync.producers[23].data to input port ProducerConsumerSync.consumers[23].data
    producerconsumersync_consumers_self[23]->__data = (consumer_data_t*)&producerconsumersync_producers_self[23]->__data;
    // Connect ProducerConsumerSync.producers[24].data to input port ProducerConsumerSync.consumers[24].data
    producerconsumersync_consumers_self[24]->__data = (consumer_data_t*)&producerconsumersync_producers_self[24]->__data;
    // Connect ProducerConsumerSync.producers[25].data to input port ProducerConsumerSync.consumers[25].data
    producerconsumersync_consumers_self[25]->__data = (consumer_data_t*)&producerconsumersync_producers_self[25]->__data;
    // Connect ProducerConsumerSync.producers[26].data to input port ProducerConsumerSync.consumers[26].data
    producerconsumersync_consumers_self[26]->__data = (consumer_data_t*)&producerconsumersync_producers_self[26]->__data;
    // Connect ProducerConsumerSync.producers[27].data to input port ProducerConsumerSync.consumers[27].data
    producerconsumersync_consumers_self[27]->__data = (consumer_data_t*)&producerconsumersync_producers_self[27]->__data;
    // Connect ProducerConsumerSync.producers[28].data to input port ProducerConsumerSync.consumers[28].data
    producerconsumersync_consumers_self[28]->__data = (consumer_data_t*)&producerconsumersync_producers_self[28]->__data;
    // Connect ProducerConsumerSync.producers[29].data to input port ProducerConsumerSync.consumers[29].data
    producerconsumersync_consumers_self[29]->__data = (consumer_data_t*)&producerconsumersync_producers_self[29]->__data;
    // Connect ProducerConsumerSync.producers[30].data to input port ProducerConsumerSync.consumers[30].data
    producerconsumersync_consumers_self[30]->__data = (consumer_data_t*)&producerconsumersync_producers_self[30]->__data;
    // Connect ProducerConsumerSync.producers[31].data to input port ProducerConsumerSync.consumers[31].data
    producerconsumersync_consumers_self[31]->__data = (consumer_data_t*)&producerconsumersync_producers_self[31]->__data;
    // Connect ProducerConsumerSync.producers[32].data to input port ProducerConsumerSync.consumers[32].data
    producerconsumersync_consumers_self[32]->__data = (consumer_data_t*)&producerconsumersync_producers_self[32]->__data;
    // Connect ProducerConsumerSync.producers[33].data to input port ProducerConsumerSync.consumers[33].data
    producerconsumersync_consumers_self[33]->__data = (consumer_data_t*)&producerconsumersync_producers_self[33]->__data;
    // Connect ProducerConsumerSync.producers[34].data to input port ProducerConsumerSync.consumers[34].data
    producerconsumersync_consumers_self[34]->__data = (consumer_data_t*)&producerconsumersync_producers_self[34]->__data;
    // Connect ProducerConsumerSync.producers[35].data to input port ProducerConsumerSync.consumers[35].data
    producerconsumersync_consumers_self[35]->__data = (consumer_data_t*)&producerconsumersync_producers_self[35]->__data;
    // Connect ProducerConsumerSync.producers[36].data to input port ProducerConsumerSync.consumers[36].data
    producerconsumersync_consumers_self[36]->__data = (consumer_data_t*)&producerconsumersync_producers_self[36]->__data;
    // Connect ProducerConsumerSync.producers[37].data to input port ProducerConsumerSync.consumers[37].data
    producerconsumersync_consumers_self[37]->__data = (consumer_data_t*)&producerconsumersync_producers_self[37]->__data;
    // Connect ProducerConsumerSync.producers[38].data to input port ProducerConsumerSync.consumers[38].data
    producerconsumersync_consumers_self[38]->__data = (consumer_data_t*)&producerconsumersync_producers_self[38]->__data;
    // Connect ProducerConsumerSync.producers[39].data to input port ProducerConsumerSync.consumers[39].data
    producerconsumersync_consumers_self[39]->__data = (consumer_data_t*)&producerconsumersync_producers_self[39]->__data;
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers.
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers.
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[0].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[0].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[1].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[1].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[2].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[2].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[3].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[3].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[4].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[4].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[5].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[5].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[6].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[6].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[7].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[7].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[8].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[8].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[9].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[9].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[10].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[10].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[11].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[11].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[12].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[12].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[13].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[13].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[14].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[14].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[15].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[15].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[16].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[16].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[17].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[17].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[18].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[18].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[19].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[19].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[20].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[20].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[21].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[21].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[22].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[22].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[23].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[23].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[24].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[24].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[25].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[25].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[26].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[26].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[27].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[27].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[28].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[28].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[29].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[29].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[30].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[30].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[31].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[31].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[32].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[32].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[33].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[33].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[34].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[34].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[35].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[35].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[36].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[36].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[37].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[37].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[38].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[38].
    // Connect inputs and outputs for reactor ProducerConsumerSync.producers[39].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.producers[39].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers.
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers.
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[0].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[0].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[1].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[1].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[2].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[2].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[3].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[3].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[4].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[4].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[5].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[5].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[6].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[6].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[7].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[7].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[8].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[8].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[9].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[9].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[10].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[10].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[11].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[11].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[12].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[12].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[13].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[13].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[14].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[14].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[15].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[15].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[16].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[16].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[17].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[17].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[18].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[18].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[19].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[19].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[20].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[20].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[21].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[21].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[22].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[22].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[23].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[23].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[24].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[24].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[25].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[25].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[26].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[26].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[27].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[27].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[28].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[28].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[29].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[29].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[30].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[30].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[31].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[31].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[32].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[32].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[33].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[33].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[34].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[34].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[35].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[35].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[36].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[36].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[37].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[37].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[38].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[38].
    // Connect inputs and outputs for reactor ProducerConsumerSync.consumers[39].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.consumers[39].
    // END Connect inputs and outputs for reactor ProducerConsumerSync.
    // Add action ProducerConsumerSync.producers[0].next to array of is_present fields.
    __is_present_fields[0] 
            = &producerconsumersync_producers_self[0]->__next.is_present;
    // Add action ProducerConsumerSync.producers[1].next to array of is_present fields.
    __is_present_fields[1] 
            = &producerconsumersync_producers_self[1]->__next.is_present;
    // Add action ProducerConsumerSync.producers[2].next to array of is_present fields.
    __is_present_fields[2] 
            = &producerconsumersync_producers_self[2]->__next.is_present;
    // Add action ProducerConsumerSync.producers[3].next to array of is_present fields.
    __is_present_fields[3] 
            = &producerconsumersync_producers_self[3]->__next.is_present;
    // Add action ProducerConsumerSync.producers[4].next to array of is_present fields.
    __is_present_fields[4] 
            = &producerconsumersync_producers_self[4]->__next.is_present;
    // Add action ProducerConsumerSync.producers[5].next to array of is_present fields.
    __is_present_fields[5] 
            = &producerconsumersync_producers_self[5]->__next.is_present;
    // Add action ProducerConsumerSync.producers[6].next to array of is_present fields.
    __is_present_fields[6] 
            = &producerconsumersync_producers_self[6]->__next.is_present;
    // Add action ProducerConsumerSync.producers[7].next to array of is_present fields.
    __is_present_fields[7] 
            = &producerconsumersync_producers_self[7]->__next.is_present;
    // Add action ProducerConsumerSync.producers[8].next to array of is_present fields.
    __is_present_fields[8] 
            = &producerconsumersync_producers_self[8]->__next.is_present;
    // Add action ProducerConsumerSync.producers[9].next to array of is_present fields.
    __is_present_fields[9] 
            = &producerconsumersync_producers_self[9]->__next.is_present;
    // Add action ProducerConsumerSync.producers[10].next to array of is_present fields.
    __is_present_fields[10] 
            = &producerconsumersync_producers_self[10]->__next.is_present;
    // Add action ProducerConsumerSync.producers[11].next to array of is_present fields.
    __is_present_fields[11] 
            = &producerconsumersync_producers_self[11]->__next.is_present;
    // Add action ProducerConsumerSync.producers[12].next to array of is_present fields.
    __is_present_fields[12] 
            = &producerconsumersync_producers_self[12]->__next.is_present;
    // Add action ProducerConsumerSync.producers[13].next to array of is_present fields.
    __is_present_fields[13] 
            = &producerconsumersync_producers_self[13]->__next.is_present;
    // Add action ProducerConsumerSync.producers[14].next to array of is_present fields.
    __is_present_fields[14] 
            = &producerconsumersync_producers_self[14]->__next.is_present;
    // Add action ProducerConsumerSync.producers[15].next to array of is_present fields.
    __is_present_fields[15] 
            = &producerconsumersync_producers_self[15]->__next.is_present;
    // Add action ProducerConsumerSync.producers[16].next to array of is_present fields.
    __is_present_fields[16] 
            = &producerconsumersync_producers_self[16]->__next.is_present;
    // Add action ProducerConsumerSync.producers[17].next to array of is_present fields.
    __is_present_fields[17] 
            = &producerconsumersync_producers_self[17]->__next.is_present;
    // Add action ProducerConsumerSync.producers[18].next to array of is_present fields.
    __is_present_fields[18] 
            = &producerconsumersync_producers_self[18]->__next.is_present;
    // Add action ProducerConsumerSync.producers[19].next to array of is_present fields.
    __is_present_fields[19] 
            = &producerconsumersync_producers_self[19]->__next.is_present;
    // Add action ProducerConsumerSync.producers[20].next to array of is_present fields.
    __is_present_fields[20] 
            = &producerconsumersync_producers_self[20]->__next.is_present;
    // Add action ProducerConsumerSync.producers[21].next to array of is_present fields.
    __is_present_fields[21] 
            = &producerconsumersync_producers_self[21]->__next.is_present;
    // Add action ProducerConsumerSync.producers[22].next to array of is_present fields.
    __is_present_fields[22] 
            = &producerconsumersync_producers_self[22]->__next.is_present;
    // Add action ProducerConsumerSync.producers[23].next to array of is_present fields.
    __is_present_fields[23] 
            = &producerconsumersync_producers_self[23]->__next.is_present;
    // Add action ProducerConsumerSync.producers[24].next to array of is_present fields.
    __is_present_fields[24] 
            = &producerconsumersync_producers_self[24]->__next.is_present;
    // Add action ProducerConsumerSync.producers[25].next to array of is_present fields.
    __is_present_fields[25] 
            = &producerconsumersync_producers_self[25]->__next.is_present;
    // Add action ProducerConsumerSync.producers[26].next to array of is_present fields.
    __is_present_fields[26] 
            = &producerconsumersync_producers_self[26]->__next.is_present;
    // Add action ProducerConsumerSync.producers[27].next to array of is_present fields.
    __is_present_fields[27] 
            = &producerconsumersync_producers_self[27]->__next.is_present;
    // Add action ProducerConsumerSync.producers[28].next to array of is_present fields.
    __is_present_fields[28] 
            = &producerconsumersync_producers_self[28]->__next.is_present;
    // Add action ProducerConsumerSync.producers[29].next to array of is_present fields.
    __is_present_fields[29] 
            = &producerconsumersync_producers_self[29]->__next.is_present;
    // Add action ProducerConsumerSync.producers[30].next to array of is_present fields.
    __is_present_fields[30] 
            = &producerconsumersync_producers_self[30]->__next.is_present;
    // Add action ProducerConsumerSync.producers[31].next to array of is_present fields.
    __is_present_fields[31] 
            = &producerconsumersync_producers_self[31]->__next.is_present;
    // Add action ProducerConsumerSync.producers[32].next to array of is_present fields.
    __is_present_fields[32] 
            = &producerconsumersync_producers_self[32]->__next.is_present;
    // Add action ProducerConsumerSync.producers[33].next to array of is_present fields.
    __is_present_fields[33] 
            = &producerconsumersync_producers_self[33]->__next.is_present;
    // Add action ProducerConsumerSync.producers[34].next to array of is_present fields.
    __is_present_fields[34] 
            = &producerconsumersync_producers_self[34]->__next.is_present;
    // Add action ProducerConsumerSync.producers[35].next to array of is_present fields.
    __is_present_fields[35] 
            = &producerconsumersync_producers_self[35]->__next.is_present;
    // Add action ProducerConsumerSync.producers[36].next to array of is_present fields.
    __is_present_fields[36] 
            = &producerconsumersync_producers_self[36]->__next.is_present;
    // Add action ProducerConsumerSync.producers[37].next to array of is_present fields.
    __is_present_fields[37] 
            = &producerconsumersync_producers_self[37]->__next.is_present;
    // Add action ProducerConsumerSync.producers[38].next to array of is_present fields.
    __is_present_fields[38] 
            = &producerconsumersync_producers_self[38]->__next.is_present;
    // Add action ProducerConsumerSync.producers[39].next to array of is_present fields.
    __is_present_fields[39] 
            = &producerconsumersync_producers_self[39]->__next.is_present;
    // Add port ProducerConsumerSync.producers[0].data to array of is_present fields.
    __is_present_fields[40] = &producerconsumersync_producers_self[0]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[1].data to array of is_present fields.
    __is_present_fields[41] = &producerconsumersync_producers_self[1]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[2].data to array of is_present fields.
    __is_present_fields[42] = &producerconsumersync_producers_self[2]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[3].data to array of is_present fields.
    __is_present_fields[43] = &producerconsumersync_producers_self[3]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[4].data to array of is_present fields.
    __is_present_fields[44] = &producerconsumersync_producers_self[4]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[5].data to array of is_present fields.
    __is_present_fields[45] = &producerconsumersync_producers_self[5]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[6].data to array of is_present fields.
    __is_present_fields[46] = &producerconsumersync_producers_self[6]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[7].data to array of is_present fields.
    __is_present_fields[47] = &producerconsumersync_producers_self[7]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[8].data to array of is_present fields.
    __is_present_fields[48] = &producerconsumersync_producers_self[8]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[9].data to array of is_present fields.
    __is_present_fields[49] = &producerconsumersync_producers_self[9]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[10].data to array of is_present fields.
    __is_present_fields[50] = &producerconsumersync_producers_self[10]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[11].data to array of is_present fields.
    __is_present_fields[51] = &producerconsumersync_producers_self[11]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[12].data to array of is_present fields.
    __is_present_fields[52] = &producerconsumersync_producers_self[12]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[13].data to array of is_present fields.
    __is_present_fields[53] = &producerconsumersync_producers_self[13]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[14].data to array of is_present fields.
    __is_present_fields[54] = &producerconsumersync_producers_self[14]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[15].data to array of is_present fields.
    __is_present_fields[55] = &producerconsumersync_producers_self[15]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[16].data to array of is_present fields.
    __is_present_fields[56] = &producerconsumersync_producers_self[16]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[17].data to array of is_present fields.
    __is_present_fields[57] = &producerconsumersync_producers_self[17]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[18].data to array of is_present fields.
    __is_present_fields[58] = &producerconsumersync_producers_self[18]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[19].data to array of is_present fields.
    __is_present_fields[59] = &producerconsumersync_producers_self[19]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[20].data to array of is_present fields.
    __is_present_fields[60] = &producerconsumersync_producers_self[20]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[21].data to array of is_present fields.
    __is_present_fields[61] = &producerconsumersync_producers_self[21]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[22].data to array of is_present fields.
    __is_present_fields[62] = &producerconsumersync_producers_self[22]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[23].data to array of is_present fields.
    __is_present_fields[63] = &producerconsumersync_producers_self[23]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[24].data to array of is_present fields.
    __is_present_fields[64] = &producerconsumersync_producers_self[24]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[25].data to array of is_present fields.
    __is_present_fields[65] = &producerconsumersync_producers_self[25]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[26].data to array of is_present fields.
    __is_present_fields[66] = &producerconsumersync_producers_self[26]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[27].data to array of is_present fields.
    __is_present_fields[67] = &producerconsumersync_producers_self[27]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[28].data to array of is_present fields.
    __is_present_fields[68] = &producerconsumersync_producers_self[28]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[29].data to array of is_present fields.
    __is_present_fields[69] = &producerconsumersync_producers_self[29]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[30].data to array of is_present fields.
    __is_present_fields[70] = &producerconsumersync_producers_self[30]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[31].data to array of is_present fields.
    __is_present_fields[71] = &producerconsumersync_producers_self[31]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[32].data to array of is_present fields.
    __is_present_fields[72] = &producerconsumersync_producers_self[32]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[33].data to array of is_present fields.
    __is_present_fields[73] = &producerconsumersync_producers_self[33]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[34].data to array of is_present fields.
    __is_present_fields[74] = &producerconsumersync_producers_self[34]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[35].data to array of is_present fields.
    __is_present_fields[75] = &producerconsumersync_producers_self[35]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[36].data to array of is_present fields.
    __is_present_fields[76] = &producerconsumersync_producers_self[36]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[37].data to array of is_present fields.
    __is_present_fields[77] = &producerconsumersync_producers_self[37]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[38].data to array of is_present fields.
    __is_present_fields[78] = &producerconsumersync_producers_self[38]->__data.is_present
    ;
    // Add port ProducerConsumerSync.producers[39].data to array of is_present fields.
    __is_present_fields[79] = &producerconsumersync_producers_self[39]->__data.is_present
    ;
    producerconsumersync_self->___reaction_0.chain_id = 256;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_self->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[0]->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[0]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[1]->___reaction_0.chain_id = 2;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[1]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[2]->___reaction_0.chain_id = 4;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[2]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[3]->___reaction_0.chain_id = 8;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[3]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[4]->___reaction_0.chain_id = 16;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[4]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[5]->___reaction_0.chain_id = 32;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[5]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[6]->___reaction_0.chain_id = 64;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[6]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[7]->___reaction_0.chain_id = 128;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[7]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[8]->___reaction_0.chain_id = 256;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[8]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[9]->___reaction_0.chain_id = 512;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[9]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[10]->___reaction_0.chain_id = 1024;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[10]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[11]->___reaction_0.chain_id = 2048;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[11]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[12]->___reaction_0.chain_id = 4096;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[12]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[13]->___reaction_0.chain_id = 8192;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[13]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[14]->___reaction_0.chain_id = 16384;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[14]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[15]->___reaction_0.chain_id = 32768;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[15]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[16]->___reaction_0.chain_id = 65536;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[16]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[17]->___reaction_0.chain_id = 131072;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[17]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[18]->___reaction_0.chain_id = 262144;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[18]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[19]->___reaction_0.chain_id = 524288;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[19]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[20]->___reaction_0.chain_id = 1048576;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[20]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[21]->___reaction_0.chain_id = 2097152;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[21]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[22]->___reaction_0.chain_id = 4194304;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[22]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[23]->___reaction_0.chain_id = 8388608;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[23]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[24]->___reaction_0.chain_id = 16777216;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[24]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[25]->___reaction_0.chain_id = 33554432;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[25]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[26]->___reaction_0.chain_id = 67108864;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[26]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[27]->___reaction_0.chain_id = 134217728;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[27]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[28]->___reaction_0.chain_id = 268435456;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[28]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[29]->___reaction_0.chain_id = 536870912;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[29]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[30]->___reaction_0.chain_id = 1073741824;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[30]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[31]->___reaction_0.chain_id = -2147483648;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[31]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[32]->___reaction_0.chain_id = 1;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[32]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[33]->___reaction_0.chain_id = 2;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[33]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[34]->___reaction_0.chain_id = 4;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[34]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[35]->___reaction_0.chain_id = 8;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[35]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[36]->___reaction_0.chain_id = 16;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[36]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[37]->___reaction_0.chain_id = 32;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[37]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[38]->___reaction_0.chain_id = 64;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[38]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_producers_self[39]->___reaction_0.chain_id = 128;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_producers_self[39]->___reaction_0.index = 0x7fffffffffff0000LL;
    producerconsumersync_consumers_self[0]->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[0]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[1]->___reaction_0.chain_id = 2;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[1]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[2]->___reaction_0.chain_id = 4;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[2]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[3]->___reaction_0.chain_id = 8;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[3]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[4]->___reaction_0.chain_id = 16;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[4]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[5]->___reaction_0.chain_id = 32;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[5]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[6]->___reaction_0.chain_id = 64;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[6]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[7]->___reaction_0.chain_id = 128;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[7]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[8]->___reaction_0.chain_id = 256;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[8]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[9]->___reaction_0.chain_id = 512;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[9]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[10]->___reaction_0.chain_id = 1024;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[10]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[11]->___reaction_0.chain_id = 2048;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[11]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[12]->___reaction_0.chain_id = 4096;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[12]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[13]->___reaction_0.chain_id = 8192;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[13]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[14]->___reaction_0.chain_id = 16384;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[14]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[15]->___reaction_0.chain_id = 32768;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[15]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[16]->___reaction_0.chain_id = 65536;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[16]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[17]->___reaction_0.chain_id = 131072;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[17]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[18]->___reaction_0.chain_id = 262144;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[18]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[19]->___reaction_0.chain_id = 524288;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[19]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[20]->___reaction_0.chain_id = 1048576;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[20]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[21]->___reaction_0.chain_id = 2097152;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[21]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[22]->___reaction_0.chain_id = 4194304;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[22]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[23]->___reaction_0.chain_id = 8388608;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[23]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[24]->___reaction_0.chain_id = 16777216;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[24]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[25]->___reaction_0.chain_id = 33554432;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[25]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[26]->___reaction_0.chain_id = 67108864;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[26]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[27]->___reaction_0.chain_id = 134217728;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[27]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[28]->___reaction_0.chain_id = 268435456;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[28]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[29]->___reaction_0.chain_id = 536870912;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[29]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[30]->___reaction_0.chain_id = 1073741824;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[30]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[31]->___reaction_0.chain_id = -2147483648;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[31]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[32]->___reaction_0.chain_id = 1;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[32]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[33]->___reaction_0.chain_id = 2;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[33]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[34]->___reaction_0.chain_id = 4;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[34]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[35]->___reaction_0.chain_id = 8;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[35]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[36]->___reaction_0.chain_id = 16;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[36]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[37]->___reaction_0.chain_id = 32;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[37]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[38]->___reaction_0.chain_id = 64;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[38]->___reaction_0.index = 0x7fffffffffff0001LL;
    producerconsumersync_consumers_self[39]->___reaction_0.chain_id = 128;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    producerconsumersync_consumers_self[39]->___reaction_0.index = 0x7fffffffffff0001LL;
    calculate_epoch_offset();
}
void __trigger_startup_reactions() {
    if (_lf_number_of_threads == 0) {
       _lf_number_of_threads = 24;
    }
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
}
void logical_tag_complete(tag_t tag_to_send) {
}
tag_t send_next_event_tag(tag_t tag, bool wait_for_reply) {
    return tag;
}
bool __trigger_shutdown_reactions() {                          
    for (int i = 0; i < __shutdown_reactions_size; i++) {
        if (__shutdown_reactions[i] != NULL) {
            _lf_enqueue_reaction(__shutdown_reactions[i]);
        }
    }
    // Return true if there are shutdown reactions.
    return (__shutdown_reactions_size > 0);
}
void __termination() {stop_trace();}


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Reactor-Py: /home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Reactor-Py
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Reactor-Py API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b11836cbd51165a175a03d8d87298208.html">org.lflang</a></li><li class="navelem"><a class="el" href="dir_af4706f0e5a17c44cf29f92ff62f955b.html">src</a></li><li class="navelem"><a class="el" href="dir_c7ad6bb7b973c5f66153a52fa8d720b8.html">lib</a></li><li class="navelem"><a class="el" href="dir_f594d3f3475fb561a19d4bc6a0ae7e5e.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">net_util.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="net__util_8h_source.html">net_util.h</a>&quot;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af58c457e08491f7cfd5a0a46940e11ad"><td class="memItemLeft" align="right" valign="top"><a id="af58c457e08491f7cfd5a0a46940e11ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NUMBER_OF_FEDERATES</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:af58c457e08491f7cfd5a0a46940e11ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f1f00e4a82d34116e1cd8734fabde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a065f1f00e4a82d34116e1cd8734fabde">SOCKET_READ_RETRY_INTERVAL</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="separator:a065f1f00e4a82d34116e1cd8734fabde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04dd5e3e7b7ee262b58476c4611d7b23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a04dd5e3e7b7ee262b58476c4611d7b23">host_is_big_endian</a> ()</td></tr>
<tr class="separator:a04dd5e3e7b7ee262b58476c4611d7b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d26e19c03e782593ba0f1791b7f35b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a9d26e19c03e782593ba0f1791b7f35b5">read_from_socket_errexit</a> (int socket, int num_bytes, unsigned char *buffer, char *format,...)</td></tr>
<tr class="separator:a9d26e19c03e782593ba0f1791b7f35b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9426930d10448b1f16f6afee07777f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a9426930d10448b1f16f6afee07777f88">read_from_socket</a> (int socket, int num_bytes, unsigned char *buffer)</td></tr>
<tr class="separator:a9426930d10448b1f16f6afee07777f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae819deb7254b390e29a1808625acf70f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ae819deb7254b390e29a1808625acf70f">write_to_socket_errexit_with_mutex</a> (int socket, int num_bytes, unsigned char *buffer, lf_mutex_t *mutex, char *format,...)</td></tr>
<tr class="separator:ae819deb7254b390e29a1808625acf70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3b7299eccba74fcd7a27f37642dc7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a0e3b7299eccba74fcd7a27f37642dc7e">write_to_socket_errexit</a> (int socket, int num_bytes, unsigned char *buffer, char *format,...)</td></tr>
<tr class="separator:a0e3b7299eccba74fcd7a27f37642dc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bab7965862259f354a419e4140b564"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ae9bab7965862259f354a419e4140b564">write_to_socket</a> (int socket, int num_bytes, unsigned char *buffer)</td></tr>
<tr class="separator:ae9bab7965862259f354a419e4140b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8cbad5d6dc462c87eb48c6a5519c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a0b8cbad5d6dc462c87eb48c6a5519c33">encode_ll</a> (long long data, unsigned char *buffer)</td></tr>
<tr class="separator:a0b8cbad5d6dc462c87eb48c6a5519c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4312040e137fb9d644f96edaa74075d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#af4312040e137fb9d644f96edaa74075d">encode_int</a> (int data, unsigned char *buffer)</td></tr>
<tr class="separator:af4312040e137fb9d644f96edaa74075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e6a5450e934d80281f626ba25deaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ac91e6a5450e934d80281f626ba25deaa">encode_ushort</a> (unsigned short data, unsigned char *buffer)</td></tr>
<tr class="separator:ac91e6a5450e934d80281f626ba25deaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34227a5f72de6d30571be08cf4ec48f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a34227a5f72de6d30571be08cf4ec48f6">swap_bytes_if_big_endian_int</a> (int src)</td></tr>
<tr class="separator:a34227a5f72de6d30571be08cf4ec48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8030d5345c501ee7d9bbfffa75b85dd5"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a8030d5345c501ee7d9bbfffa75b85dd5">swap_bytes_if_big_endian_ll</a> (long long src)</td></tr>
<tr class="separator:a8030d5345c501ee7d9bbfffa75b85dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667ab204d21ca15a1cd9f8fe26696a31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a667ab204d21ca15a1cd9f8fe26696a31">swap_bytes_if_big_endian_ushort</a> (unsigned short src)</td></tr>
<tr class="separator:a667ab204d21ca15a1cd9f8fe26696a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e1559ae8f31e111cedc00211edded"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a2c3e1559ae8f31e111cedc00211edded">extract_int</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a2c3e1559ae8f31e111cedc00211edded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c03766b3fd76c7ad5901581a766caa8"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a3c03766b3fd76c7ad5901581a766caa8">extract_ll</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a3c03766b3fd76c7ad5901581a766caa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52445dc6792e1d40424c4e0edc18704"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ab52445dc6792e1d40424c4e0edc18704">extract_ushort</a> (unsigned char *bytes)</td></tr>
<tr class="separator:ab52445dc6792e1d40424c4e0edc18704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11217be2cfd106df54dfab0c53218238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a11217be2cfd106df54dfab0c53218238">extract_header</a> (unsigned char *buffer, unsigned short *port_id, unsigned short *federate_id, unsigned int *length)</td></tr>
<tr class="separator:a11217be2cfd106df54dfab0c53218238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9fc45154c83606a54f358e4978b489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a3e9fc45154c83606a54f358e4978b489">extract_timed_header</a> (unsigned char *buffer, unsigned short *port_id, unsigned short *federate_id, unsigned int *length, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="separator:a3e9fc45154c83606a54f358e4978b489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span style="display: none;">.nosp@m.</span>erke<span style="display: none;">.nosp@m.</span>ley.e<span style="display: none;">.nosp@m.</span>du</a>) </dd>
<dd>
Soroush Bateni (<a href="#" onclick="location.href='mai'+'lto:'+'sor'+'ou'+'sh@'+'ut'+'dal'+'la'+'s.e'+'du'; return false;">sorou<span style="display: none;">.nosp@m.</span>sh@u<span style="display: none;">.nosp@m.</span>tdall<span style="display: none;">.nosp@m.</span>as.e<span style="display: none;">.nosp@m.</span>du</a>)</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>Copyright (c) 2020, The University of California at Berkeley.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>Utility functions for a federate in a federated execution. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a065f1f00e4a82d34116e1cd8734fabde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065f1f00e4a82d34116e1cd8734fabde">&#9670;&nbsp;</a></span>SOCKET_READ_RETRY_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_READ_RETRY_INTERVAL&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of nanoseconds to sleep before retrying a socket read. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af4312040e137fb9d644f96edaa74075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4312040e137fb9d644f96edaa74075d">&#9670;&nbsp;</a></span>encode_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). This works for either int or unsigned int. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b8cbad5d6dc462c87eb48c6a5519c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8cbad5d6dc462c87eb48c6a5519c33">&#9670;&nbsp;</a></span>encode_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_ll </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91e6a5450e934d80281f626ba25deaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91e6a5450e934d80281f626ba25deaa">&#9670;&nbsp;</a></span>encode_ushort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_ushort </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11217be2cfd106df54dfab0c53218238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11217be2cfd106df54dfab0c53218238">&#9670;&nbsp;</a></span>extract_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>federate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the core header information that all messages between federates share. The core header information is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, and four bytes with the length of the message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3e1559ae8f31e111cedc00211edded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3e1559ae8f31e111cedc00211edded">&#9670;&nbsp;</a></span>extract_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int extract_int </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract an int from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c03766b3fd76c7ad5901581a766caa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c03766b3fd76c7ad5901581a766caa8">&#9670;&nbsp;</a></span>extract_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long extract_ll </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a long long from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e9fc45154c83606a54f358e4978b489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9fc45154c83606a54f358e4978b489">&#9670;&nbsp;</a></span>extract_timed_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_timed_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>federate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the timed header information for timed messages between federates. This is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, four bytes with the length of the message, eight bytes with a timestamp, and four bytes with a microstep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
    <tr><td class="paramname">tag</td><td>The place to put the tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab52445dc6792e1d40424c4e0edc18704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52445dc6792e1d40424c4e0edc18704">&#9670;&nbsp;</a></span>extract_ushort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short extract_ushort </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract an unsigned short from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04dd5e3e7b7ee262b58476c4611d7b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dd5e3e7b7ee262b58476c4611d7b23">&#9670;&nbsp;</a></span>host_is_big_endian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int host_is_big_endian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true (1) if the host is big endian. Otherwise, return false. </p>

</div>
</div>
<a id="a9426930d10448b1f16f6afee07777f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9426930d10448b1f16f6afee07777f88">&#9670;&nbsp;</a></span>read_from_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_from_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the specified number of bytes from the specified socket into the specified buffer. If a disconnect occurs during this reading, return a negative number. If an EOF occurs during this reading, return 0. Otherwise, return the number of bytes read. This is a version of <a class="el" href="net__util_8c.html#a9d26e19c03e782593ba0f1791b7f35b5">read_from_socket_errexit()</a> that neither closes the socket nor errors out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or 0 when EOF is received or negative for an error. </dd></dl>

</div>
</div>
<a id="a9d26e19c03e782593ba0f1791b7f35b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d26e19c03e782593ba0f1791b7f35b5">&#9670;&nbsp;</a></span>read_from_socket_errexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_from_socket_errexit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the specified number of bytes from the specified socket into the specified buffer. If an error or an EOF occurs during this reading, then if format is non-null, close the socket, report an error and exit. If format is NULL, then just return 0 for EOF and a negative number for any other error.</p>
<p>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string, followed by arguments to fill the string, or NULL to not exit with an error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read, or 0 if an EOF is received, or a negative number for an error. </dd></dl>

</div>
</div>
<a id="a34227a5f72de6d30571be08cf4ec48f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34227a5f72de6d30571be08cf4ec48f6">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swap_bytes_if_big_endian_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8030d5345c501ee7d9bbfffa75b85dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8030d5345c501ee7d9bbfffa75b85dd5">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long swap_bytes_if_big_endian_ll </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a667ab204d21ca15a1cd9f8fe26696a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667ab204d21ca15a1cd9f8fe26696a31">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_ushort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swap_bytes_if_big_endian_ushort </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9bab7965862259f354a419e4140b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bab7965862259f354a419e4140b564">&#9670;&nbsp;</a></span>write_to_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified number of bytes to the specified socket from the specified buffer. If a disconnect or an EOF occurs during this reading, return a negative number or 0 respectively. Otherwise, return the number of bytes written. This is a version of <a class="el" href="net__util_8c.html#a0e3b7299eccba74fcd7a27f37642dc7e">write_to_socket_errexit()</a> that neither closes the socket nor errors out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
<a id="a0e3b7299eccba74fcd7a27f37642dc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3b7299eccba74fcd7a27f37642dc7e">&#9670;&nbsp;</a></span>write_to_socket_errexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_socket_errexit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</p>
<p>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
    <tr><td class="paramname">format</td><td>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
<a id="ae819deb7254b390e29a1808625acf70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae819deb7254b390e29a1808625acf70f">&#9670;&nbsp;</a></span>write_to_socket_errexit_with_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_socket_errexit_with_mutex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lf_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</p>
<p>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
    <tr><td class="paramname">mutex</td><td>If non-NULL, the mutex to unlock before exiting. </td></tr>
    <tr><td class="paramname">format</td><td>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>

<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="net__util_8c" kind="file" language="C++">
    <compoundname>net_util.c</compoundname>
    <includes refid="util_8h" local="yes">util.h</includes>
    <includes refid="net__util_8h" local="yes">net_util.h</includes>
    <includes local="no">errno.h</includes>
    <includes local="no">stdio.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">unistd.h</includes>
    <includes local="no">assert.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">stdarg.h</includes>
    <includes local="no">time.h</includes>
    <includes local="no">math.h</includes>
    <includedby refid="federate_8c" local="yes">/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/federate.c</includedby>
    <includedby refid="rti_8c" local="yes">/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/rti.c</includedby>
    <incdepgraph>
      <node id="2">
        <label>util.h</label>
        <link refid="util_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>stdarg.h</label>
      </node>
      <node id="11">
        <label>assert.h</label>
      </node>
      <node id="9">
        <label>stdlib.h</label>
      </node>
      <node id="7">
        <label>errno.h</label>
      </node>
      <node id="5">
        <label>platform.h</label>
        <link refid="platform_8h_source"/>
      </node>
      <node id="6">
        <label>tag.h</label>
        <link refid="tag_8h"/>
      </node>
      <node id="1">
        <label>/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c</label>
        <link refid="net__util_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>net_util.h</label>
        <link refid="net__util_8h"/>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="12">
        <label>string.h</label>
      </node>
      <node id="10">
        <label>unistd.h</label>
      </node>
      <node id="13">
        <label>time.h</label>
      </node>
      <node id="14">
        <label>math.h</label>
      </node>
      <node id="8">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="2">
        <label>/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/federate.c</label>
        <link refid="federate_8c"/>
      </node>
      <node id="1">
        <label>/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c</label>
        <link refid="net__util_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/rti.c</label>
        <link refid="rti_8c"/>
      </node>
    </invincdepgraph>
      <sectiondef kind="define">
      <memberdef kind="define" id="net__util_8c_1af58c457e08491f7cfd5a0a46940e11ad" prot="public" static="no">
        <name>NUMBER_OF_FEDERATES</name>
        <initializer>1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="46" column="9" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="net__util_8c_1a065f1f00e4a82d34116e1cd8734fabde" prot="public" static="no">
        <name>SOCKET_READ_RETRY_INTERVAL</name>
        <initializer>1000000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Number of nanoseconds to sleep before retrying a socket read. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="50" column="9" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="50" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="net__util_8c_1a04dd5e3e7b7ee262b58476c4611d7b23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int host_is_big_endian</definition>
        <argsstring>()</argsstring>
        <name>host_is_big_endian</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return true (1) if the host is big endian. Otherwise, return false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="55" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="55" bodyend="67"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a9d26e19c03e782593ba0f1791b7f35b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int read_from_socket_errexit</definition>
        <argsstring>(int socket, int num_bytes, unsigned char *buffer, char *format,...)</argsstring>
        <name>read_from_socket_errexit</name>
        <param>
          <type>int</type>
          <declname>socket</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>format</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read the specified number of bytes from the specified socket into the specified buffer. If an error or an EOF occurs during this reading, then if format is non-null, close the socket, report an error and exit. If format is NULL, then just return 0 for EOF and a negative number for any other error.</para>
<para>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>socket</parametername>
</parameternamelist>
<parameterdescription>
<para>The socket ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to read. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer into which to put the bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>format</parametername>
</parameternamelist>
<parameterdescription>
<para>A printf-style format string, followed by arguments to fill the string, or NULL to not exit with an error message. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes read, or 0 if an EOF is received, or a negative number for an error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="89" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="89" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a9426930d10448b1f16f6afee07777f88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int read_from_socket</definition>
        <argsstring>(int socket, int num_bytes, unsigned char *buffer)</argsstring>
        <name>read_from_socket</name>
        <param>
          <type>int</type>
          <declname>socket</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read the specified number of bytes from the specified socket into the specified buffer. If a disconnect occurs during this reading, return a negative number. If an EOF occurs during this reading, return 0. Otherwise, return the number of bytes read. This is a version of <ref refid="net__util_8c_1a9d26e19c03e782593ba0f1791b7f35b5" kindref="member">read_from_socket_errexit()</ref> that neither closes the socket nor errors out.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>socket</parametername>
</parameternamelist>
<parameterdescription>
<para>The socket ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to read. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer into which to put the bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes read or 0 when EOF is received or negative for an error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="141" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="141" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1ae819deb7254b390e29a1808625acf70f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int write_to_socket_errexit_with_mutex</definition>
        <argsstring>(int socket, int num_bytes, unsigned char *buffer, lf_mutex_t *mutex, char *format,...)</argsstring>
        <name>write_to_socket_errexit_with_mutex</name>
        <param>
          <type>int</type>
          <declname>socket</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>lf_mutex_t *</type>
          <declname>mutex</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>format</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</para>
<para>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>socket</parametername>
</parameternamelist>
<parameterdescription>
<para>The socket ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer from which to get the bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>If non-NULL, the mutex to unlock before exiting. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>format</parametername>
</parameternamelist>
<parameterdescription>
<para>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="166" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="166" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a0e3b7299eccba74fcd7a27f37642dc7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int write_to_socket_errexit</definition>
        <argsstring>(int socket, int num_bytes, unsigned char *buffer, char *format,...)</argsstring>
        <name>write_to_socket_errexit</name>
        <param>
          <type>int</type>
          <declname>socket</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>format</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</para>
<para>This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>socket</parametername>
</parameternamelist>
<parameterdescription>
<para>The socket ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer from which to get the bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>format</parametername>
</parameternamelist>
<parameterdescription>
<para>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="218" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="218" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1ae9bab7965862259f354a419e4140b564" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int write_to_socket</definition>
        <argsstring>(int socket, int num_bytes, unsigned char *buffer)</argsstring>
        <name>write_to_socket</name>
        <param>
          <type>int</type>
          <declname>socket</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified number of bytes to the specified socket from the specified buffer. If a disconnect or an EOF occurs during this reading, return a negative number or 0 respectively. Otherwise, return the number of bytes written. This is a version of <ref refid="net__util_8c_1a0e3b7299eccba74fcd7a27f37642dc7e" kindref="member">write_to_socket_errexit()</ref> that neither closes the socket nor errors out.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>socket</parametername>
</parameternamelist>
<parameterdescription>
<para>The socket ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of bytes to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer from which to get the bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="240" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="240" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a0b8cbad5d6dc462c87eb48c6a5519c33" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void encode_ll</definition>
        <argsstring>(long long data, unsigned char *buffer)</argsstring>
        <name>encode_ll</name>
        <param>
          <type>long long</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>The data to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The location to start writing. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="250" column="6" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="250" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1af4312040e137fb9d644f96edaa74075d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void encode_int</definition>
        <argsstring>(int data, unsigned char *buffer)</argsstring>
        <name>encode_int</name>
        <param>
          <type>int</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). This works for either int or unsigned int. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>The data to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The location to start writing. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="267" column="6" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="267" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1ac91e6a5450e934d80281f626ba25deaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void encode_ushort</definition>
        <argsstring>(unsigned short data, unsigned char *buffer)</argsstring>
        <name>encode_ushort</name>
        <param>
          <type>unsigned short</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>The data to write. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The location to start writing. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="282" column="6" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="282" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a34227a5f72de6d30571be08cf4ec48f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swap_bytes_if_big_endian_int</definition>
        <argsstring>(int src)</argsstring>
        <name>swap_bytes_if_big_endian_int</name>
        <param>
          <type>int</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to convert. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="299" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="299" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a8030d5345c501ee7d9bbfffa75b85dd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>long long</type>
        <definition>long long swap_bytes_if_big_endian_ll</definition>
        <argsstring>(long long src)</argsstring>
        <name>swap_bytes_if_big_endian_ll</name>
        <param>
          <type>long long</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to convert. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="326" column="11" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="326" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a667ab204d21ca15a1cd9f8fe26696a31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int swap_bytes_if_big_endian_ushort</definition>
        <argsstring>(unsigned short src)</argsstring>
        <name>swap_bytes_if_big_endian_ushort</name>
        <param>
          <type>unsigned short</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The argument to convert. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="355" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="355" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a2c3e1559ae8f31e111cedc00211edded" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int extract_int</definition>
        <argsstring>(unsigned char *bytes)</argsstring>
        <name>extract_int</name>
        <param>
          <type>unsigned char *</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract an int from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the start of the sequence of bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="375" column="5" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="375" bodyend="383"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a3c03766b3fd76c7ad5901581a766caa8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>long long</type>
        <definition>long long extract_ll</definition>
        <argsstring>(unsigned char *bytes)</argsstring>
        <name>extract_ll</name>
        <param>
          <type>unsigned char *</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract a long long from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the start of the sequence of bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="389" column="11" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="389" bodyend="397"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1ab52445dc6792e1d40424c4e0edc18704" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned short</type>
        <definition>unsigned short extract_ushort</definition>
        <argsstring>(unsigned char *bytes)</argsstring>
        <name>extract_ushort</name>
        <param>
          <type>unsigned char *</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract an unsigned short from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the start of the sequence of bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="403" column="16" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="403" bodyend="411"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a11217be2cfd106df54dfab0c53218238" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void extract_header</definition>
        <argsstring>(unsigned char *buffer, unsigned short *port_id, unsigned short *federate_id, unsigned int *length)</argsstring>
        <name>extract_header</name>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>unsigned short *</type>
          <declname>port_id</declname>
        </param>
        <param>
          <type>unsigned short *</type>
          <declname>federate_id</declname>
        </param>
        <param>
          <type>unsigned int *</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract the core header information that all messages between federates share. The core header information is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, and four bytes with the length of the message. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer to read from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>port_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the port ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>federate_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the federate ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the length. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="423" column="6" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="423" bodyend="442"/>
      </memberdef>
      <memberdef kind="function" id="net__util_8c_1a3e9fc45154c83606a54f358e4978b489" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void extract_timed_header</definition>
        <argsstring>(unsigned char *buffer, unsigned short *port_id, unsigned short *federate_id, unsigned int *length, tag_t *tag)</argsstring>
        <name>extract_timed_header</name>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>unsigned short *</type>
          <declname>port_id</declname>
        </param>
        <param>
          <type>unsigned short *</type>
          <declname>federate_id</declname>
        </param>
        <param>
          <type>unsigned int *</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="structtag__t" kindref="compound">tag_t</ref> *</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract the timed header information for timed messages between federates. This is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, four bytes with the length of the message, eight bytes with a timestamp, and four bytes with a microstep. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>The buffer to read from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>port_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the port ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>federate_id</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the federate ID. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the length. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The place to put the tag. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" line="456" column="6" bodyfile="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c" bodystart="456" bodyend="467"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="author"><para>Edward A. Lee (<ulink url="mailto:eal@berkeley.edu">eal@berkeley.edu</ulink>) </para>
</simplesect>
<simplesect kind="author"><para>Soroush Bateni (<ulink url="mailto:soroush@utdallas.edu">soroush@utdallas.edu</ulink>)</para>
</simplesect>
</para>
<sect1 id="util_8h_1LICENSE">
<title>LICENSE</title>
<para>Copyright (c) 2020, The University of California at Berkeley.</para>
<para>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</para>
<para><orderedlist>
<listitem><para>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</para>
</listitem><listitem><para>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</para>
</listitem></orderedlist>
</para>
<para>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</para>
</sect1>
<sect1 id="util_8h_1DESCRIPTION">
<title>DESCRIPTION</title>
<para>Utility functions for a federate in a federated execution. </para>
</sect1>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"></codeline>
<codeline lineno="33"><highlight class="preprocessor">#include<sp/>&quot;<ref refid="util_8h" kindref="compound">util.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="net__util_8h" kindref="compound">net_util.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;errno.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unistd.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>read(),<sp/>write(),<sp/>and<sp/>close()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;assert.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>memcpy()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdarg.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>va_list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;time.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Defines<sp/>nanosleep()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>sqrtl()<sp/>and<sp/>powl</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>NUMBER_OF_FEDERATES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NUMBER_OF_FEDERATES<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="preprocessor">#define<sp/>SOCKET_READ_RETRY_INTERVAL<sp/>1000000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a04dd5e3e7b7ee262b58476c4611d7b23" kindref="member">host_is_big_endian</ref>()<sp/>{</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>host<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>uint;</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[4];</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>x;</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(host<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Determine<sp/>the<sp/>endianness<sp/>of<sp/>the<sp/>host<sp/>by<sp/>setting<sp/>the<sp/>low-order<sp/>bit.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x.uint<sp/>=<sp/>0x01;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>host<sp/>=<sp/>(x.c[3]<sp/>==<sp/>0x01)<sp/>?<sp/>HOST_BIG_ENDIAN<sp/>:<sp/>HOST_LITTLE_ENDIAN;</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(host<sp/>==<sp/>HOST_BIG_ENDIAN);</highlight></codeline>
<codeline lineno="67"><highlight class="normal">}</highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a9d26e19c03e782593ba0f1791b7f35b5" kindref="member">read_from_socket_errexit</ref>(</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>socket,</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_bytes,</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer,</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>format,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>args;</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(socket<sp/>&lt;<sp/>0<sp/>&amp;&amp;<sp/>format<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a1c6c13db619d78a55e0517405f226cc3" kindref="member">error_print</ref>(</highlight><highlight class="stringliteral">&quot;Socket<sp/>is<sp/>no<sp/>longer<sp/>open.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a7389ef15e70a377a52086e6d6b956d70" kindref="member">error_print_and_exit</ref>(format,<sp/>args);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bytes_read<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(bytes_read<sp/>&lt;<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>more<sp/>=<sp/>read(socket,<sp/>buffer<sp/>+<sp/>bytes_read,<sp/>num_bytes<sp/>-<sp/>bytes_read);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(more<sp/>&lt;=<sp/>0<sp/>&amp;&amp;<sp/>(errno<sp/>==<sp/>EAGAIN<sp/>||<sp/>errno<sp/>==<sp/>EWOULDBLOCK))<sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>error<sp/>code<sp/>set<sp/>by<sp/>the<sp/>socket<sp/>indicates</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>we<sp/>should<sp/>try<sp/>again<sp/>(@see<sp/>man<sp/>errno).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8h_1a0a27a0fa2f8d9461204242121941696c" kindref="member">DEBUG_PRINT</ref>(</highlight><highlight class="stringliteral">&quot;Reading<sp/>from<sp/>socket<sp/>was<sp/>blocked.<sp/>Will<sp/>try<sp/>again.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(more<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(format<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shutdown(socket,<sp/>SHUT_RDWR);</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>close(socket);</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a1c6c13db619d78a55e0517405f226cc3" kindref="member">error_print</ref>(</highlight><highlight class="stringliteral">&quot;Read<sp/>%d<sp/>bytes,<sp/>but<sp/>expected<sp/>%d.&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>more<sp/>+<sp/>bytes_read,<sp/>num_bytes);</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a7389ef15e70a377a52086e6d6b956d70" kindref="member">error_print_and_exit</ref>(format,<sp/>args);</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(more<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>According<sp/>to<sp/>this:<sp/>https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>upon<sp/>receiving<sp/>a<sp/>zero<sp/>length<sp/>packet<sp/>or<sp/>an<sp/>error,<sp/>we<sp/>can<sp/>close<sp/>the<sp/>socket.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>there<sp/>are<sp/>any<sp/>pending<sp/>outgoing<sp/>messages,<sp/>this<sp/>will<sp/>attempt<sp/>to<sp/>send<sp/>those</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>followed<sp/>by<sp/>an<sp/>EOF.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>close(socket);</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>more;</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bytes_read<sp/>+=<sp/>more;</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>bytes_read;</highlight></codeline>
<codeline lineno="126"><highlight class="normal">}</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a9426930d10448b1f16f6afee07777f88" kindref="member">read_from_socket</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>socket,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_bytes,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer)<sp/>{</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a9d26e19c03e782593ba0f1791b7f35b5" kindref="member">read_from_socket_errexit</ref>(socket,<sp/>num_bytes,<sp/>buffer,<sp/>NULL);</highlight></codeline>
<codeline lineno="143"><highlight class="normal">}</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ae819deb7254b390e29a1808625acf70f" kindref="member">write_to_socket_errexit_with_mutex</ref>(</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>socket,</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_bytes,</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer,</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lf_mutex_t*<sp/>mutex,</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>format,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bytes_written<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>args;</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(bytes_written<sp/>&lt;<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>more<sp/>=<sp/>write(socket,<sp/>buffer<sp/>+<sp/>bytes_written,<sp/>num_bytes<sp/>-<sp/>bytes_written);</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(more<sp/>&lt;=<sp/>0<sp/>&amp;&amp;<sp/>(errno<sp/>==<sp/>EAGAIN<sp/>||<sp/>errno<sp/>==<sp/>EWOULDBLOCK))<sp/>{</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>error<sp/>code<sp/>set<sp/>by<sp/>the<sp/>socket<sp/>indicates</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>that<sp/>we<sp/>should<sp/>try<sp/>again<sp/>(@see<sp/>man<sp/>errno).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8h_1a0a27a0fa2f8d9461204242121941696c" kindref="member">DEBUG_PRINT</ref>(</highlight><highlight class="stringliteral">&quot;Writing<sp/>to<sp/>socket<sp/>was<sp/>blocked.<sp/>Will<sp/>try<sp/>again.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(more<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(format<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shutdown(socket,<sp/>SHUT_RDWR);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>close(socket);</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mutex<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lf_mutex_unlock(mutex);</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a1c6c13db619d78a55e0517405f226cc3" kindref="member">error_print</ref>(format,<sp/>args);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="util_8c_1a7389ef15e70a377a52086e6d6b956d70" kindref="member">error_print_and_exit</ref>(</highlight><highlight class="stringliteral">&quot;Code<sp/>%d:<sp/>%s.&quot;</highlight><highlight class="normal">,<sp/>errno,<sp/>strerror(errno));</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>more;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bytes_written<sp/>+=<sp/>more;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>bytes_written;</highlight></codeline>
<codeline lineno="196"><highlight class="normal">}</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a0e3b7299eccba74fcd7a27f37642dc7e" kindref="member">write_to_socket_errexit</ref>(</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>socket,</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_bytes,</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer,</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>format,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ae819deb7254b390e29a1808625acf70f" kindref="member">write_to_socket_errexit_with_mutex</ref>(socket,<sp/>num_bytes,<sp/>buffer,<sp/>NULL,<sp/>format);</highlight></codeline>
<codeline lineno="224"><highlight class="normal">}</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ae9bab7965862259f354a419e4140b564" kindref="member">write_to_socket</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>socket,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_bytes,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer)<sp/>{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ae819deb7254b390e29a1808625acf70f" kindref="member">write_to_socket_errexit_with_mutex</ref>(socket,<sp/>num_bytes,<sp/>buffer,<sp/>NULL,<sp/>NULL);</highlight></codeline>
<codeline lineno="242"><highlight class="normal">}</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a0b8cbad5d6dc462c87eb48c6a5519c33" kindref="member">encode_ll</ref>(</highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer)<sp/>{</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>strategy<sp/>is<sp/>fairly<sp/>brute<sp/>force,<sp/>but<sp/>it<sp/>avoids<sp/>potential</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alignment<sp/>problems.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>shift<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>long);<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>buffer[i]<sp/>=<sp/>(data<sp/>&amp;<sp/>(0xffLL<sp/>&lt;&lt;<sp/>shift))<sp/>&gt;&gt;<sp/>shift;</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shift<sp/>+=<sp/>8;</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="258"><highlight class="normal">}</highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1af4312040e137fb9d644f96edaa74075d" kindref="member">encode_int</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer)<sp/>{</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>strategy<sp/>is<sp/>fairly<sp/>brute<sp/>force,<sp/>but<sp/>it<sp/>avoids<sp/>potential</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alignment<sp/>problems.<sp/><sp/>Note<sp/>that<sp/>this<sp/>assumes<sp/>an<sp/>int<sp/>is<sp/>four<sp/>bytes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[0]<sp/>=<sp/>data<sp/>&amp;<sp/>0xff;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[1]<sp/>=<sp/>(data<sp/>&amp;<sp/>0xff00)<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[2]<sp/>=<sp/>(data<sp/>&amp;<sp/>0xff0000)<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[3]<sp/>=<sp/>(data<sp/>&amp;<sp/>0xff000000)<sp/>&gt;&gt;<sp/>24;</highlight></codeline>
<codeline lineno="274"><highlight class="normal">}</highlight></codeline>
<codeline lineno="275"><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ac91e6a5450e934d80281f626ba25deaa" kindref="member">encode_ushort</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal"><sp/>data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer)<sp/>{</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>strategy<sp/>is<sp/>fairly<sp/>brute<sp/>force,<sp/>but<sp/>it<sp/>avoids<sp/>potential</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alignment<sp/>problems.<sp/>Note<sp/>that<sp/>this<sp/>assumes<sp/>a<sp/>short<sp/>is<sp/>two<sp/>bytes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[0]<sp/>=<sp/>data<sp/>&amp;<sp/>0xff;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/>buffer[1]<sp/>=<sp/>(data<sp/>&amp;<sp/>0xff00)<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="287"><highlight class="normal">}</highlight></codeline>
<codeline lineno="288"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a34227a5f72de6d30571be08cf4ec48f6" kindref="member">swap_bytes_if_big_endian_int</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>src)<sp/>{</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>uint;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[4];</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>x;</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="net__util_8c_1a04dd5e3e7b7ee262b58476c4611d7b23" kindref="member">host_is_big_endian</ref>())<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src;</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Host<sp/>is<sp/>little<sp/>endian.\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/>x.uint<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Before<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Swap<sp/>bytes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[0];<sp/>x.c[0]<sp/>=<sp/>x.c[3];<sp/>x.c[3]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[1];<sp/>x.c[1]<sp/>=<sp/>x.c[2];<sp/>x.c[2]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>After<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x.uint;</highlight></codeline>
<codeline lineno="314"><highlight class="normal">}</highlight></codeline>
<codeline lineno="315"><highlight class="normal"></highlight></codeline>
<codeline lineno="326"><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a8030d5345c501ee7d9bbfffa75b85dd5" kindref="member">swap_bytes_if_big_endian_ll</ref>(</highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>src)<sp/>{</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>ull;</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[8];</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>x;</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="net__util_8c_1a04dd5e3e7b7ee262b58476c4611d7b23" kindref="member">host_is_big_endian</ref>())<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src;</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Host<sp/>is<sp/>little<sp/>endian.\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/>x.ull<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Before<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Swap<sp/>bytes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[0];<sp/>x.c[0]<sp/>=<sp/>x.c[7];<sp/>x.c[7]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[1];<sp/>x.c[1]<sp/>=<sp/>x.c[6];<sp/>x.c[6]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[2];<sp/>x.c[2]<sp/>=<sp/>x.c[5];<sp/>x.c[5]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[3];<sp/>x.c[3]<sp/>=<sp/>x.c[4];<sp/>x.c[4]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>After<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x.ull;</highlight></codeline>
<codeline lineno="343"><highlight class="normal">}</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="355"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a667ab204d21ca15a1cd9f8fe26696a31" kindref="member">swap_bytes_if_big_endian_ushort</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal"><sp/>src)<sp/>{</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal"><sp/>uint;</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[2];</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>x;</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="net__util_8c_1a04dd5e3e7b7ee262b58476c4611d7b23" kindref="member">host_is_big_endian</ref>())<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>src;</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Host<sp/>is<sp/>little<sp/>endian.\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/>x.uint<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Before<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Swap<sp/>bytes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>x.c[0];<sp/>x.c[0]<sp/>=<sp/>x.c[1];<sp/>x.c[1]<sp/>=<sp/>c;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>After<sp/>swapping<sp/>bytes:<sp/>%lld.\n&quot;,<sp/>x.ull);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x.uint;</highlight></codeline>
<codeline lineno="369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="375"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a2c3e1559ae8f31e111cedc00211edded" kindref="member">extract_int</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>bytes)<sp/>{</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>memcpy<sp/>to<sp/>prevent<sp/>possible<sp/>alignment<sp/>problems<sp/>on<sp/>some<sp/>processors.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>uint;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(int)];</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>result;</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(&amp;result.c,<sp/>bytes,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a34227a5f72de6d30571be08cf4ec48f6" kindref="member">swap_bytes_if_big_endian_int</ref>(result.uint);</highlight></codeline>
<codeline lineno="383"><highlight class="normal">}</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a3c03766b3fd76c7ad5901581a766caa8" kindref="member">extract_ll</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>bytes)<sp/>{</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>memcpy<sp/>to<sp/>prevent<sp/>possible<sp/>alignment<sp/>problems<sp/>on<sp/>some<sp/>processors.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>ull;</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>long)];</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>result;</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(&amp;result.c,<sp/>bytes,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a8030d5345c501ee7d9bbfffa75b85dd5" kindref="member">swap_bytes_if_big_endian_ll</ref>(result.ull);</highlight></codeline>
<codeline lineno="397"><highlight class="normal">}</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1ab52445dc6792e1d40424c4e0edc18704" kindref="member">extract_ushort</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>bytes)<sp/>{</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>memcpy<sp/>to<sp/>prevent<sp/>possible<sp/>alignment<sp/>problems<sp/>on<sp/>some<sp/>processors.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal"><sp/><ref refid="reactor_8h_1a3fa7784c89589b49764048e9909d0e07" kindref="member">ushort</ref>;</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>c[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>short)];</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>result;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(&amp;result.c,<sp/>bytes,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a667ab204d21ca15a1cd9f8fe26696a31" kindref="member">swap_bytes_if_big_endian_ushort</ref>(result.ushort);</highlight></codeline>
<codeline lineno="411"><highlight class="normal">}</highlight></codeline>
<codeline lineno="412"><highlight class="normal"></highlight></codeline>
<codeline lineno="423"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a11217be2cfd106df54dfab0c53218238" kindref="member">extract_header</ref>(</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer,</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">*<sp/>port_id,</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">*<sp/>federate_id,</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>length</highlight></codeline>
<codeline lineno="428"><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>first<sp/>two<sp/>bytes<sp/>are<sp/>the<sp/>ID<sp/>of<sp/>the<sp/>destination<sp/>reactor.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/>*port_id<sp/>=<sp/><ref refid="net__util_8c_1ab52445dc6792e1d40424c4e0edc18704" kindref="member">extract_ushort</ref>(buffer);</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>next<sp/>two<sp/>bytes<sp/>are<sp/>the<sp/>ID<sp/>of<sp/>the<sp/>destination<sp/>federate.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/>*federate_id<sp/>=<sp/><ref refid="net__util_8c_1ab52445dc6792e1d40424c4e0edc18704" kindref="member">extract_ushort</ref>(&amp;(buffer[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">)]));</highlight></codeline>
<codeline lineno="434"><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Message<sp/>for<sp/>port<sp/>%d<sp/>of<sp/>federate<sp/>%d.\n&quot;,<sp/>*port_id,<sp/>*federate_id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>FIXME:<sp/>Better<sp/>error<sp/>handling<sp/>needed<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(*federate_id<sp/>&lt;<sp/>NUMBER_OF_FEDERATES);</highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>next<sp/>four<sp/>bytes<sp/>are<sp/>the<sp/>message<sp/>length.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/>*length<sp/>=<sp/><ref refid="net__util_8c_1a2c3e1559ae8f31e111cedc00211edded" kindref="member">extract_int</ref>(&amp;(buffer[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">)]));</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>printf(&quot;DEBUG:<sp/>Federate<sp/>receiving<sp/>message<sp/>to<sp/>port<sp/>%d<sp/>to<sp/>federate<sp/>%d<sp/>of<sp/>length<sp/>%d.\n&quot;,<sp/>port_id,<sp/>federate_id,<sp/>length);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal">}</highlight></codeline>
<codeline lineno="443"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="net__util_8c_1a3e9fc45154c83606a54f358e4978b489" kindref="member">extract_timed_header</ref>(</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>buffer,</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">*<sp/>port_id,</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">short</highlight><highlight class="normal">*<sp/>federate_id,</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>length,</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structtag__t" kindref="compound">tag_t</ref>*<sp/>tag</highlight></codeline>
<codeline lineno="462"><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="net__util_8c_1a11217be2cfd106df54dfab0c53218238" kindref="member">extract_header</ref>(buffer,<sp/>port_id,<sp/>federate_id,<sp/>length);</highlight></codeline>
<codeline lineno="464"><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/>tag-&gt;time<sp/>=<sp/><ref refid="net__util_8c_1a3c03766b3fd76c7ad5901581a766caa8" kindref="member">extract_ll</ref>(&amp;(buffer[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="reactor_8h_1a3fa7784c89589b49764048e9909d0e07" kindref="member">ushort</ref>)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="reactor_8h_1a3fa7784c89589b49764048e9909d0e07" kindref="member">ushort</ref>)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)]));</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/>tag-&gt;microstep<sp/>=<sp/><ref refid="net__util_8c_1a2c3e1559ae8f31e111cedc00211edded" kindref="member">extract_int</ref>(&amp;(buffer[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="reactor_8h_1a3fa7784c89589b49764048e9909d0e07" kindref="member">ushort</ref>)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="reactor_8h_1a3fa7784c89589b49764048e9909d0e07" kindref="member">ushort</ref>)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="tag_8h_1ad740f3189d2a477285138e682eafa8c5" kindref="member">instant_t</ref>)]));</highlight></codeline>
<codeline lineno="467"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/shaokai/lingua-franca-master/git/lingua-franca/org.lflang/src/lib/core/net_util.c"/>
  </compounddef>
</doxygen>
